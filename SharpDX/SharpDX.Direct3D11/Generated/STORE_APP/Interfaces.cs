// <auto-generated/>

namespace SharpDX.Direct3D11
{
    [System.Runtime.InteropServices.GuidAttribute("4b35d0cd-1e15-4258-9c98-1b1333f6dd3b")]
    public partial class Asynchronous : SharpDX.Direct3D11.DeviceChild
    {
        public Asynchronous(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Asynchronous(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Asynchronous(nativePtr);
        /// <summary>
        /// <p>Get the size of the data (in bytes) that is output when calling <strong>ID3D11DeviceContext::GetData</strong>.</p>
        /// </summary>
        /// <doc-id>ff476348</doc-id>
        /// <unmanaged>GetDataSize</unmanaged>
        /// <unmanaged-short>GetDataSize</unmanaged-short>
        public System.Int32 DataSize
        {
            get => GetDataSize();
        }

        /// <summary>
        /// <p>Get the size of the data (in bytes) that is output when calling <strong>ID3D11DeviceContext::GetData</strong>.</p>
        /// </summary>
        /// <returns><p>Size of the data (in bytes) that is output when calling GetData.</p></returns>
        /// <doc-id>ff476348</doc-id>
        /// <unmanaged>unsigned int ID3D11Asynchronous::GetDataSize()</unmanaged>
        /// <unmanaged-short>ID3D11Asynchronous::GetDataSize</unmanaged-short>
        internal unsafe System.Int32 GetDataSize()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[7]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("3015A308-DCBD-47aa-A747-192486D14D4A")]
    public partial class AuthenticatedChannel : SharpDX.Direct3D11.DeviceChild
    {
        public AuthenticatedChannel(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator AuthenticatedChannel(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new AuthenticatedChannel(nativePtr);
        /// <summary>
        /// <p>Gets the size of the driver's certificate chain.</p>
        /// </summary>
        /// <doc-id>hh447688</doc-id>
        /// <unmanaged>GetCertificateSize</unmanaged>
        /// <unmanaged-short>GetCertificateSize</unmanaged-short>
        public System.Int32 CertificateSize
        {
            get
            {
                GetCertificateSize(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets a handle to the authenticated channel.</p>
        /// </summary>
        /// <doc-id>hh447689</doc-id>
        /// <unmanaged>GetChannelHandle</unmanaged>
        /// <unmanaged-short>GetChannelHandle</unmanaged-short>
        public System.IntPtr ChannelHandle
        {
            get
            {
                GetChannelHandle(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the size of the driver's certificate chain.</p>
        /// </summary>
        /// <param name = "certificateSizeRef"><dd> <p>Receives the size of the certificate chain, in bytes.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447688</doc-id>
        /// <unmanaged>HRESULT ID3D11AuthenticatedChannel::GetCertificateSize([Out] unsigned int* pCertificateSize)</unmanaged>
        /// <unmanaged-short>ID3D11AuthenticatedChannel::GetCertificateSize</unmanaged-short>
        internal unsafe void GetCertificateSize(out System.Int32 certificateSizeRef)
        {
            SharpDX.Result __result__;
            fixed (void *certificateSizeRef_ = &certificateSizeRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, certificateSizeRef_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the driver's certificate chain.</p>
        /// </summary>
        /// <param name = "certificateSize"><dd> <p>The size of the <em>pCertificate</em> array, in bytes. To get the size of the certificate chain, call <strong>ID3D11CryptoSession::GetCertificateSize</strong>.</p> </dd></param>
        /// <param name = "certificateRef"><dd> <p>A reference to a byte array that receives the driver's certificate chain. The caller must allocate the array.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447687</doc-id>
        /// <unmanaged>HRESULT ID3D11AuthenticatedChannel::GetCertificate([In] unsigned int CertificateSize,[Out, Buffer] unsigned char* pCertificate)</unmanaged>
        /// <unmanaged-short>ID3D11AuthenticatedChannel::GetCertificate</unmanaged-short>
        public unsafe void GetCertificate(System.Int32 certificateSize, System.Byte[] certificateRef)
        {
            SharpDX.Result __result__;
            fixed (void *certificateRef_ = certificateRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, certificateSize, certificateRef_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets a handle to the authenticated channel.</p>
        /// </summary>
        /// <param name = "channelHandleRef"><dd> <p>Receives a handle to the channel.</p> </dd></param>
        /// <doc-id>hh447689</doc-id>
        /// <unmanaged>void ID3D11AuthenticatedChannel::GetChannelHandle([Out] void** pChannelHandle)</unmanaged>
        /// <unmanaged-short>ID3D11AuthenticatedChannel::GetChannelHandle</unmanaged-short>
        internal unsafe void GetChannelHandle(out System.IntPtr channelHandleRef)
        {
            fixed (void *channelHandleRef_ = &channelHandleRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, channelHandleRef_, (*(void ***)this._nativePointer)[9]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("75b68faa-347d-4159-8f45-a0640f01cd9a")]
    public partial class BlendState : SharpDX.Direct3D11.DeviceChild
    {
        public BlendState(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BlendState(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BlendState(nativePtr);
        /// <summary>
        /// <p>Gets the description for blending state that you used to create the blend-state object.</p>
        /// </summary>
        /// <remarks>
        /// <p>You use the description for blending state in a call to the <strong>ID3D11Device::CreateBlendState</strong> method to create the blend-state object.</p>
        /// </remarks>
        /// <doc-id>ff476350</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.Direct3D11.BlendStateDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the description for blending state that you used to create the blend-state object.</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.BlendStateDescription"/></strong> structure that receives a description of the blend state.</p> </dd></param>
        /// <remarks>
        /// <p>You use the description for blending state in a call to the <strong>ID3D11Device::CreateBlendState</strong> method to create the blend-state object.</p>
        /// </remarks>
        /// <doc-id>ff476350</doc-id>
        /// <unmanaged>void ID3D11BlendState::GetDesc([Out] D3D11_BLEND_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11BlendState::GetDesc</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.Direct3D11.BlendStateDescription descRef)
        {
            SharpDX.Direct3D11.BlendStateDescription.__Native descRef_ = default (SharpDX.Direct3D11.BlendStateDescription.__Native);
            descRef = default (SharpDX.Direct3D11.BlendStateDescription);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, &descRef_, (*(void ***)this._nativePointer)[7]);
            descRef.__MarshalFrom(ref descRef_);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("cc86fabe-da55-401d-85e7-e3c9de2877e9")]
    public partial class BlendState1 : SharpDX.Direct3D11.BlendState
    {
        public BlendState1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BlendState1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BlendState1(nativePtr);
        /// <summary>
        /// <p>Gets the description for blending state that you used to create the blend-state object.</p>
        /// </summary>
        /// <remarks>
        /// <p>You use the description for blending state in a call to the <strong>ID3D11Device1::CreateBlendState1</strong> method to create the blend-state object.</p>
        /// </remarks>
        /// <doc-id>hh404573</doc-id>
        /// <unmanaged>GetDesc1</unmanaged>
        /// <unmanaged-short>GetDesc1</unmanaged-short>
        public SharpDX.Direct3D11.BlendStateDescription1 Description1
        {
            get
            {
                GetDescription1(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the description for blending state that you used to create the blend-state object.</p>
        /// </summary>
        /// <param name = "descRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.BlendStateDescription1"/></strong> structure that receives a description of the blend state. This blend state can specify logical operations as well as blending operations.</p> </dd></param>
        /// <remarks>
        /// <p>You use the description for blending state in a call to the <strong>ID3D11Device1::CreateBlendState1</strong> method to create the blend-state object.</p>
        /// </remarks>
        /// <doc-id>hh404573</doc-id>
        /// <unmanaged>void ID3D11BlendState1::GetDesc1([Out] D3D11_BLEND_DESC1* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11BlendState1::GetDesc1</unmanaged-short>
        internal unsafe void GetDescription1(out SharpDX.Direct3D11.BlendStateDescription1 descRef)
        {
            SharpDX.Direct3D11.BlendStateDescription1.__Native descRef_ = default (SharpDX.Direct3D11.BlendStateDescription1.__Native);
            descRef = default (SharpDX.Direct3D11.BlendStateDescription1);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, &descRef_, (*(void ***)this._nativePointer)[8]);
            descRef.__MarshalFrom(ref descRef_);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("48570b85-d1ee-4fcd-a250-eb350722b037")]
    public partial class Buffer : SharpDX.Direct3D11.Resource
    {
        public Buffer(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Buffer(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Buffer(nativePtr);
        /// <summary>
        /// <p>Get the properties of a buffer resource.</p>
        /// </summary>
        /// <doc-id>ff476352</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.Direct3D11.BufferDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Get the properties of a buffer resource.</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p>Pointer to a resource description (see <strong><see cref = "SharpDX.Direct3D11.BufferDescription"/></strong>) filled in by the method.</p> </dd></param>
        /// <doc-id>ff476352</doc-id>
        /// <unmanaged>void ID3D11Buffer::GetDesc([Out] D3D11_BUFFER_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11Buffer::GetDesc</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.Direct3D11.BufferDescription descRef)
        {
            descRef = default (SharpDX.Direct3D11.BufferDescription);
            fixed (void *descRef_ = &descRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[10]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("a6cd7faa-b0b7-4a2f-9436-8662a65797cb")]
    public partial class ClassInstance : SharpDX.Direct3D11.DeviceChild
    {
        public ClassInstance(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ClassInstance(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ClassInstance(nativePtr);
        /// <summary>
        /// <p> Gets the <strong><see cref = "SharpDX.Direct3D11.ClassLinkage"/></strong> object associated with the current HLSL class. </p>
        /// </summary>
        /// <remarks>
        /// <p> For more information about using the <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong> interface, see Dynamic Linking. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476354</doc-id>
        /// <unmanaged>GetClassLinkage</unmanaged>
        /// <unmanaged-short>GetClassLinkage</unmanaged-short>
        public SharpDX.Direct3D11.ClassLinkage ClassLinkage
        {
            get
            {
                GetClassLinkage(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets a description of the current HLSL class.</p>
        /// </summary>
        /// <remarks>
        /// <p> For more information about using the <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong> interface, see Dynamic Linking. </p><p> An instance is not restricted to being used for a single type in a single shader. An instance is flexible and can be used for any shader that used the same type name or instance name when the instance was generated. </p><ul> <li> A created instance will work for any shader that contains a type of the same type name. For instance, a class instance created with the type name <strong>DefaultShader</strong> would work in any shader that contained a type <strong>DefaultShader</strong> even though several shaders could describe a different type. </li> <li> A gotten instance maps directly to an instance name/index in a shader. A class instance aquired using GetClassInstance will work for any shader that contains a class instance of the name used to generate the runtime instance, the instance does not have to be the same type in all of the shaders it's used in. </li> </ul><p> An instance does not replace the importance of reflection for a particular shader since a gotten instance will not know its slot location and a created instance only specifies a type name. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476355</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.Direct3D11.ClassInstanceDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Gets the <strong><see cref = "SharpDX.Direct3D11.ClassLinkage"/></strong> object associated with the current HLSL class. </p>
        /// </summary>
        /// <param name = "linkageOut">No documentation.</param>
        /// <remarks>
        /// <p> For more information about using the <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong> interface, see Dynamic Linking. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476354</doc-id>
        /// <unmanaged>void ID3D11ClassInstance::GetClassLinkage([Out] ID3D11ClassLinkage** ppLinkage)</unmanaged>
        /// <unmanaged-short>ID3D11ClassInstance::GetClassLinkage</unmanaged-short>
        internal unsafe void GetClassLinkage(out SharpDX.Direct3D11.ClassLinkage linkageOut)
        {
            System.IntPtr linkageOut_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, &linkageOut_, (*(void ***)this._nativePointer)[7]);
            if (linkageOut_ != System.IntPtr.Zero)
                linkageOut = new SharpDX.Direct3D11.ClassLinkage(linkageOut_);
            else
                linkageOut = null;
        }

        /// <summary>
        /// <p>Gets a description of the current HLSL class.</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p> A reference to a <strong><see cref = "SharpDX.Direct3D11.ClassInstanceDescription"/></strong> structure that describes the current HLSL class. </p> </dd></param>
        /// <remarks>
        /// <p> For more information about using the <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong> interface, see Dynamic Linking. </p><p> An instance is not restricted to being used for a single type in a single shader. An instance is flexible and can be used for any shader that used the same type name or instance name when the instance was generated. </p><ul> <li> A created instance will work for any shader that contains a type of the same type name. For instance, a class instance created with the type name <strong>DefaultShader</strong> would work in any shader that contained a type <strong>DefaultShader</strong> even though several shaders could describe a different type. </li> <li> A gotten instance maps directly to an instance name/index in a shader. A class instance aquired using GetClassInstance will work for any shader that contains a class instance of the name used to generate the runtime instance, the instance does not have to be the same type in all of the shaders it's used in. </li> </ul><p> An instance does not replace the importance of reflection for a particular shader since a gotten instance will not know its slot location and a created instance only specifies a type name. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476355</doc-id>
        /// <unmanaged>void ID3D11ClassInstance::GetDesc([Out] D3D11_CLASS_INSTANCE_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11ClassInstance::GetDesc</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.Direct3D11.ClassInstanceDescription descRef)
        {
            descRef = default (SharpDX.Direct3D11.ClassInstanceDescription);
            fixed (void *descRef_ = &descRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[8]);
        }

        /// <summary>
        /// <p>Gets the instance name of the current HLSL class.</p>
        /// </summary>
        /// <param name = "instanceNameRef"><dd>  <p>The instance name of the current HLSL class.</p> </dd></param>
        /// <param name = "bufferLengthRef"><dd>  <p> The length of the <em>pInstanceName</em> parameter. </p> </dd></param>
        /// <remarks>
        /// <p>GetInstanceName will return a valid name only for instances acquired using  <strong>ID3D11ClassLinkage::GetClassInstance</strong>. </p><p> For more information about using the <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong> interface, see  Dynamic Linking. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476356</doc-id>
        /// <unmanaged>void ID3D11ClassInstance::GetInstanceName([Out, Buffer, Optional] char* pInstanceName,[InOut] SIZE_T* pBufferLength)</unmanaged>
        /// <unmanaged-short>ID3D11ClassInstance::GetInstanceName</unmanaged-short>
        internal unsafe void GetInstanceName(System.IntPtr instanceNameRef, ref SharpDX.PointerSize bufferLengthRef)
        {
            fixed (void *bufferLengthRef_ = &bufferLengthRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)instanceNameRef, bufferLengthRef_, (*(void ***)this._nativePointer)[9]);
        }

        /// <summary>
        /// <p>Gets the type of the current HLSL class.</p>
        /// </summary>
        /// <param name = "typeNameRef"><dd>  <p>Type of the current HLSL class.</p> </dd></param>
        /// <param name = "bufferLengthRef"><dd>  <p> The length of the <em>pTypeName</em> parameter. </p> </dd></param>
        /// <remarks>
        /// <p>GetTypeName will return a valid name only for instances acquired using <strong>ID3D11ClassLinkage::GetClassInstance</strong>. </p><p> For more information about using the <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong> interface, see Dynamic Linking. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476357</doc-id>
        /// <unmanaged>void ID3D11ClassInstance::GetTypeName([Out, Buffer, Optional] char* pTypeName,[InOut] SIZE_T* pBufferLength)</unmanaged>
        /// <unmanaged-short>ID3D11ClassInstance::GetTypeName</unmanaged-short>
        internal unsafe void GetTypeName(System.IntPtr typeNameRef, ref SharpDX.PointerSize bufferLengthRef)
        {
            fixed (void *bufferLengthRef_ = &bufferLengthRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)typeNameRef, bufferLengthRef_, (*(void ***)this._nativePointer)[10]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("ddf57cba-9543-46e4-a12b-f207a0fe7fed")]
    public partial class ClassLinkage : SharpDX.Direct3D11.DeviceChild
    {
        public ClassLinkage(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ClassLinkage(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ClassLinkage(nativePtr);
        /// <summary>
        /// <p>Gets the class-instance object that represents the specified HLSL class.</p>
        /// </summary>
        /// <param name = "classInstanceNameRef"><dd>  <p>The name of a class for which to get the class instance.</p> </dd></param>
        /// <param name = "instanceIndex"><dd>  <p>The index of the class instance.</p> </dd></param>
        /// <returns><dd>  <p> The address of a reference to an <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong> interface to initialize. </p> </dd></returns>
        /// <remarks>
        /// <p> For more information about using the <strong><see cref = "SharpDX.Direct3D11.ClassLinkage"/></strong> interface, see Dynamic Linking. </p><p> A class instance must have at least 1 data member in order to be available for the runtime to use with <strong>ID3D11ClassLinkage::GetClassInstance</strong>. Any instance with no members will be optimized out of a compiled shader blob as a zero-sized object. If you have a class with no data members, use <strong>ID3D11ClassLinkage::CreateClassInstance</strong> instead. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476360</doc-id>
        /// <unmanaged>HRESULT ID3D11ClassLinkage::GetClassInstance([In] const char* pClassInstanceName,[In] unsigned int InstanceIndex,[Out] ID3D11ClassInstance** ppInstance)</unmanaged>
        /// <unmanaged-short>ID3D11ClassLinkage::GetClassInstance</unmanaged-short>
        public unsafe SharpDX.Direct3D11.ClassInstance GetClassInstance(System.String classInstanceNameRef, System.Int32 instanceIndex)
        {
            System.IntPtr classInstanceNameRef_;
            SharpDX.Direct3D11.ClassInstance instanceOut;
            System.IntPtr instanceOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            classInstanceNameRef_ = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(classInstanceNameRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)classInstanceNameRef_, instanceIndex, &instanceOut_, (*(void ***)this._nativePointer)[7]);
            if (instanceOut_ != System.IntPtr.Zero)
                instanceOut = new SharpDX.Direct3D11.ClassInstance(instanceOut_);
            else
                instanceOut = null;
            System.Runtime.InteropServices.Marshal.FreeHGlobal(classInstanceNameRef_);
            __result__.CheckError();
            return instanceOut;
        }

        /// <summary>
        /// <p>Initializes a class-instance object that represents an HLSL class instance.</p>
        /// </summary>
        /// <param name = "classTypeNameRef"><dd>  <p>The type name of a class to initialize.</p> </dd></param>
        /// <param name = "constantBufferOffset"><dd>  <p>Identifies the constant buffer that contains the class data.</p> </dd></param>
        /// <param name = "constantVectorOffset"><dd>  <p>The four-component vector offset from the start of the constant buffer where the class data will begin. Consequently, this is not a byte offset.</p> </dd></param>
        /// <param name = "textureOffset"><dd>  <p>The texture slot for the first texture; there may be multiple textures following the offset.</p> </dd></param>
        /// <param name = "samplerOffset"><dd>  <p>The sampler slot for the first sampler; there may be multiple samplers following the offset.</p> </dd></param>
        /// <param name = "instanceOut"><dd>  <p> The address of a reference to an <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong> interface to initialize. </p> </dd></param>
        /// <returns><p> Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns one of the following Direct3D 11 Return Codes. </p></returns>
        /// <remarks>
        /// <p>Instances can be created (or gotten) before or after a shader is created. Use the same shader linkage object to acquire a class instance and create the shader the instance is going to be used in.</p><p> For more information about using the <strong><see cref = "SharpDX.Direct3D11.ClassLinkage"/></strong> interface, see Dynamic Linking. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476359</doc-id>
        /// <unmanaged>HRESULT ID3D11ClassLinkage::CreateClassInstance([In] const char* pClassTypeName,[In] unsigned int ConstantBufferOffset,[In] unsigned int ConstantVectorOffset,[In] unsigned int TextureOffset,[In] unsigned int SamplerOffset,[Out, Fast] ID3D11ClassInstance** ppInstance)</unmanaged>
        /// <unmanaged-short>ID3D11ClassLinkage::CreateClassInstance</unmanaged-short>
        internal unsafe void CreateClassInstance(System.String classTypeNameRef, System.Int32 constantBufferOffset, System.Int32 constantVectorOffset, System.Int32 textureOffset, System.Int32 samplerOffset, SharpDX.Direct3D11.ClassInstance instanceOut)
        {
            System.IntPtr classTypeNameRef_;
            System.IntPtr instanceOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            classTypeNameRef_ = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(classTypeNameRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)classTypeNameRef_, constantBufferOffset, constantVectorOffset, textureOffset, samplerOffset, &instanceOut_, (*(void ***)this._nativePointer)[8]);
            (instanceOut).NativePointer = instanceOut_;
            System.Runtime.InteropServices.Marshal.FreeHGlobal(classTypeNameRef_);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("a24bc4d1-769e-43f7-8013-98ff566c18e2")]
    public partial class CommandList : SharpDX.Direct3D11.DeviceChild
    {
        public CommandList(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator CommandList(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new CommandList(nativePtr);
    }

    [System.Runtime.InteropServices.GuidAttribute("4f5b196e-c2bd-495e-bd01-1fded38e4969")]
    public partial class ComputeShader : SharpDX.Direct3D11.DeviceChild
    {
        public ComputeShader(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ComputeShader(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ComputeShader(nativePtr);
    }

    [System.Runtime.InteropServices.GuidAttribute("c0bfa96c-e089-44fb-8eaf-26f8796190da")]
    public partial class ComputeShaderStage : CommonShaderStage<ComputeShader>
    {
        public ComputeShaderStage(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ComputeShaderStage(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ComputeShaderStage(nativePtr);
                ///<summary>Constant UnorderedAccessViewSlotCount</summary>
        ///<unmanaged>D3D11_PS_CS_UAV_REGISTER_COUNT</unmanaged>
        public const int UnorderedAccessViewSlotCount = unchecked ((int)8);
                ///<summary>Constant DispatchMaximumThreadGroupsPerDimension</summary>
        ///<unmanaged>D3D11_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION</unmanaged>
        public const int DispatchMaximumThreadGroupsPerDimension = unchecked ((int)65535);
                ///<summary>Constant ThreadGroupSharedMemoryRegisterCount</summary>
        ///<unmanaged>D3D11_CS_TGSM_REGISTER_COUNT</unmanaged>
        public const int ThreadGroupSharedMemoryRegisterCount = unchecked ((int)8192);
                ///<summary>Constant ThreadGroupSharedMemoryRegisterReadsPerInst</summary>
        ///<unmanaged>D3D11_CS_TGSM_REGISTER_READS_PER_INST</unmanaged>
        public const int ThreadGroupSharedMemoryRegisterReadsPerInst = unchecked ((int)1);
                ///<summary>Constant ThreadGroupSharedMemoryResourceRegisterComponents</summary>
        ///<unmanaged>D3D11_CS_TGSM_RESOURCE_REGISTER_COMPONENTS</unmanaged>
        public const int ThreadGroupSharedMemoryResourceRegisterComponents = unchecked ((int)1);
                ///<summary>Constant ThreadGroupSharedMemoryResourceRegisterReadPorts</summary>
        ///<unmanaged>D3D11_CS_TGSM_RESOURCE_REGISTER_READ_PORTS</unmanaged>
        public const int ThreadGroupSharedMemoryResourceRegisterReadPorts = unchecked ((int)1);
                ///<summary>Constant ThreadgroupidRegisterComponents</summary>
        ///<unmanaged>D3D11_CS_THREADGROUPID_REGISTER_COMPONENTS</unmanaged>
        public const int ThreadgroupidRegisterComponents = unchecked ((int)3);
                ///<summary>Constant ThreadgroupidRegisterCount</summary>
        ///<unmanaged>D3D11_CS_THREADGROUPID_REGISTER_COUNT</unmanaged>
        public const int ThreadgroupidRegisterCount = unchecked ((int)1);
                ///<summary>Constant ThreadidingroupflattenedRegisterComponents</summary>
        ///<unmanaged>D3D11_CS_THREADIDINGROUPFLATTENED_REGISTER_COMPONENTS</unmanaged>
        public const int ThreadidingroupflattenedRegisterComponents = unchecked ((int)1);
                ///<summary>Constant ThreadidingroupflattenedRegisterCount</summary>
        ///<unmanaged>D3D11_CS_THREADIDINGROUPFLATTENED_REGISTER_COUNT</unmanaged>
        public const int ThreadidingroupflattenedRegisterCount = unchecked ((int)1);
                ///<summary>Constant ThreadidingroupRegisterComponents</summary>
        ///<unmanaged>D3D11_CS_THREADIDINGROUP_REGISTER_COMPONENTS</unmanaged>
        public const int ThreadidingroupRegisterComponents = unchecked ((int)3);
                ///<summary>Constant ThreadidingroupRegisterCount</summary>
        ///<unmanaged>D3D11_CS_THREADIDINGROUP_REGISTER_COUNT</unmanaged>
        public const int ThreadidingroupRegisterCount = unchecked ((int)1);
                ///<summary>Constant ThreadidRegisterComponents</summary>
        ///<unmanaged>D3D11_CS_THREADID_REGISTER_COMPONENTS</unmanaged>
        public const int ThreadidRegisterComponents = unchecked ((int)3);
                ///<summary>Constant ThreadidRegisterCount</summary>
        ///<unmanaged>D3D11_CS_THREADID_REGISTER_COUNT</unmanaged>
        public const int ThreadidRegisterCount = unchecked ((int)1);
                ///<summary>Constant ThreadGroupMaximumThreadsPerGroup</summary>
        ///<unmanaged>D3D11_CS_THREAD_GROUP_MAX_THREADS_PER_GROUP</unmanaged>
        public const int ThreadGroupMaximumThreadsPerGroup = unchecked ((int)1024);
                ///<summary>Constant ThreadGroupMaximumX</summary>
        ///<unmanaged>D3D11_CS_THREAD_GROUP_MAX_X</unmanaged>
        public const int ThreadGroupMaximumX = unchecked ((int)1024);
                ///<summary>Constant ThreadGroupMaximumY</summary>
        ///<unmanaged>D3D11_CS_THREAD_GROUP_MAX_Y</unmanaged>
        public const int ThreadGroupMaximumY = unchecked ((int)1024);
                ///<summary>Constant ThreadGroupMaximumZ</summary>
        ///<unmanaged>D3D11_CS_THREAD_GROUP_MAX_Z</unmanaged>
        public const int ThreadGroupMaximumZ = unchecked ((int)64);
                ///<summary>Constant ThreadGroupMinimumX</summary>
        ///<unmanaged>D3D11_CS_THREAD_GROUP_MIN_X</unmanaged>
        public const int ThreadGroupMinimumX = unchecked ((int)1);
                ///<summary>Constant ThreadGroupMinimumY</summary>
        ///<unmanaged>D3D11_CS_THREAD_GROUP_MIN_Y</unmanaged>
        public const int ThreadGroupMinimumY = unchecked ((int)1);
                ///<summary>Constant ThreadGroupMinimumZ</summary>
        ///<unmanaged>D3D11_CS_THREAD_GROUP_MIN_Z</unmanaged>
        public const int ThreadGroupMinimumZ = unchecked ((int)1);
                ///<summary>Constant ThreadLocalTempRegisterPool</summary>
        ///<unmanaged>D3D11_CS_THREAD_LOCAL_TEMP_REGISTER_POOL</unmanaged>
        public const int ThreadLocalTempRegisterPool = unchecked ((int)16384);
        /// <summary>
        /// <p>Bind an array of shader resources to the compute-shader stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin setting shader resources to (ranges from 0 to <see cref = "InputResourceSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numViews"><dd>  <p>Number of shader resources to set. Up to a maximum of 128 slots are available for shader resources(ranges from 0 to <see cref = "InputResourceSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "shaderResourceViewsOut"><dd>  <p>Array of <strong>shader resource view</strong> interfaces to set to the device.</p> </dd></param>
        /// <remarks>
        /// <p>If an overlapping resource view is already bound to an output slot, such as a render target, then the method will fill the destination shader resource slot with <strong><c>null</c></strong>.</p><p>For information about creating shader-resource views, see <strong>ID3D11Device::CreateShaderResourceView</strong>.</p><p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10.
        /// </p>
        /// </remarks>
        /// <doc-id>ff476403</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::CSSetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[In, Buffer, Optional] const ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::CSSetShaderResources</unmanaged-short>
        internal override unsafe void SetShaderResources(System.Int32 startSlot, System.Int32 numViews, System.IntPtr shaderResourceViewsOut)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numViews, (void *)shaderResourceViewsOut, (*(void ***)this._nativePointer)[67]);
        }

        /// <summary>
        /// <p>Sets an array of views for an unordered resource.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index of the first element in the zero-based array to begin setting  (ranges from 0 to D3D11_1_UAV_SLOT_COUNT - 1). D3D11_1_UAV_SLOT_COUNT is defined as 64.</p> </dd></param>
        /// <param name = "numUAVs"><dd>  <p> Number of views to set (ranges from 0 to D3D11_1_UAV_SLOT_COUNT - <em>StartSlot</em>). </p> </dd></param>
        /// <param name = "unorderedAccessViewsOut"><dd>  <p> A reference to an array of <strong><see cref = "SharpDX.Direct3D11.UnorderedAccessView"/></strong> references to be set by the method. </p> </dd></param>
        /// <param name = "uAVInitialCountsRef"><dd>  <p> An array of append and consume buffer offsets. A value of -1 indicates to keep the current offset. Any other values set the hidden counter for that appendable and consumable UAV. <em>pUAVInitialCounts</em> is only relevant for UAVs that were created with either <strong>D3D11_BUFFER_UAV_FLAG_APPEND</strong> or <strong>D3D11_BUFFER_UAV_FLAG_COUNTER</strong> specified when the UAV was created; otherwise, the argument is ignored. </p> </dd></param>
        /// <remarks>
        /// <p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476404</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::CSSetUnorderedAccessViews([In] unsigned int StartSlot,[In] unsigned int NumUAVs,[In, Buffer, Optional] const ID3D11UnorderedAccessView** ppUnorderedAccessViews,[In, Buffer, Optional] const unsigned int* pUAVInitialCounts)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::CSSetUnorderedAccessViews</unmanaged-short>
        internal override unsafe void SetUnorderedAccessViews(System.Int32 startSlot, System.Int32 numUAVs, System.IntPtr unorderedAccessViewsOut, System.IntPtr uAVInitialCountsRef)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numUAVs, (void *)unorderedAccessViewsOut, (void *)uAVInitialCountsRef, (*(void ***)this._nativePointer)[68]);
        }

        /// <summary>
        /// <p>Set a compute shader to the device.</p>
        /// </summary>
        /// <param name = "computeShaderRef"><dd>  <p>Pointer to a compute shader (see <strong><see cref = "SharpDX.Direct3D11.ComputeShader"/></strong>). Passing in <strong><c>null</c></strong> disables the shader for this pipeline stage.</p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p>A reference to an array of class-instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <strong><c>null</c></strong> if the shader does not use any interfaces.</p> </dd></param>
        /// <param name = "numClassInstances"><dd>  <p>The number of class-instance interfaces in the array.</p> </dd></param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p>The maximum number of instances a shader can have is 256.</p>
        /// </remarks>
        /// <doc-id>ff476402</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::CSSetShader([In, Optional] ID3D11ComputeShader* pComputeShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[In] unsigned int NumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::CSSetShader</unmanaged-short>
        internal override unsafe void SetShader(SharpDX.Direct3D11.ComputeShader computeShaderRef, SharpDX.Direct3D11.ClassInstance[] classInstancesOut, System.Int32 numClassInstances)
        {
            System.IntPtr computeShaderRef_ = System.IntPtr.Zero;
            System.IntPtr*classInstancesOut_;
            classInstancesOut_ = (System.IntPtr*)0;
            if (classInstancesOut != null)
            {
                System.IntPtr*_classInstancesOut = stackalloc System.IntPtr[classInstancesOut.Length];
                classInstancesOut_ = _classInstancesOut;
            }

            computeShaderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.ComputeShader>(computeShaderRef);
            if (classInstancesOut != null)
                for (int i = 0; i < classInstancesOut.Length; ++i)
                    (classInstancesOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.ClassInstance>(classInstancesOut[i]);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)computeShaderRef_, (void *)classInstancesOut_, numClassInstances, (*(void ***)this._nativePointer)[69]);
        }

        /// <summary>
        /// <p>Set an array of sampler states to the compute-shader stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin setting samplers to (ranges from 0 to <see cref = "SamplerSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numSamplers"><dd>  <p>Number of samplers in the array. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to <see cref = "SamplerSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "samplersOut"><dd>  <p>Pointer to an array of sampler-state interfaces (see <strong><see cref = "SharpDX.Direct3D11.SamplerState"/></strong>). See Remarks.</p> </dd></param>
        /// <remarks>
        /// <p>Any sampler may be set to <strong><c>null</c></strong>; this invokes the default state, which is defined to be the following.</p><pre>//Default sampler state:
        /// <see cref = "SharpDX.Direct3D11.SamplerStateDescription"/> SamplerDesc;
        /// SamplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
        /// SamplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
        /// SamplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
        /// SamplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
        /// SamplerDesc.MipLODBias = 0;
        /// SamplerDesc.MaxAnisotropy = 1;
        /// SamplerDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;
        /// SamplerDesc.BorderColor[0] = 1.0f;
        /// SamplerDesc.BorderColor[1] = 1.0f;
        /// SamplerDesc.BorderColor[2] = 1.0f;
        /// SamplerDesc.BorderColor[3] = 1.0f;
        /// SamplerDesc.MinLOD = -FLT_MAX;
        /// SamplerDesc.MaxLOD = FLT_MAX; </pre><p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p>
        /// </remarks>
        /// <doc-id>ff476401</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::CSSetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[In, Buffer, Optional] const ID3D11SamplerState** ppSamplers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::CSSetSamplers</unmanaged-short>
        internal override unsafe void SetSamplers(System.Int32 startSlot, System.Int32 numSamplers, System.IntPtr samplersOut)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numSamplers, (void *)samplersOut, (*(void ***)this._nativePointer)[70]);
        }

        /// <summary>
        /// <p>Sets the constant buffers used by the compute-shader stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the zero-based array to begin setting constant buffers to (ranges from 0 to <strong><see cref = "ConstantBufferApiSlotCount"/></strong> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd>  <p>Number of buffers to set (ranges from 0 to <strong><see cref = "ConstantBufferApiSlotCount"/></strong> - <em>StartSlot</em>).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd>  <p>Array of constant buffers (see <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>) being given to the device.</p> </dd></param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p>The Direct3D 11.1 runtime, which is available starting with Windows?8, can bind a larger number of <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong> resources to the shader than the maximum constant buffer size that is supported by shaders (4096 constants ? 4*32-bit components each).  When you bind such a large buffer, the shader can access only the first 4096 4*32-bit component constants in the buffer, as if 4096 constants is the full size of the buffer.  </p><p>If the application wants the shader to access other parts of the buffer, it must call the <strong>CSSetConstantBuffers1</strong> method instead. </p>
        /// </remarks>
        /// <doc-id>ff476400</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::CSSetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::CSSetConstantBuffers</unmanaged-short>
        internal override unsafe void SetConstantBuffers(System.Int32 startSlot, System.Int32 numBuffers, System.IntPtr constantBuffersOut)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut, (*(void ***)this._nativePointer)[71]);
        }

        /// <summary>
        /// <p>Get the compute-shader resources.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin getting shader resources from (ranges from 0 to <see cref = "InputResourceSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numViews"><dd>  <p>The number of resources to get from the device. Up to a maximum of 128 slots are available for shader resources (ranges from 0 to <see cref = "InputResourceSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "shaderResourceViewsOut"><dd>  <p>Array of <strong>shader resource view</strong> interfaces to be returned by the device.</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476398</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::CSGetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[Out, Buffer, Optional] ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::CSGetShaderResources</unmanaged-short>
        internal override unsafe void GetShaderResources(System.Int32 startSlot, System.Int32 numViews, SharpDX.Direct3D11.ShaderResourceView[] shaderResourceViewsOut)
        {
            System.IntPtr*shaderResourceViewsOut_;
            shaderResourceViewsOut_ = (System.IntPtr*)0;
            if (shaderResourceViewsOut != null)
            {
                System.IntPtr*_shaderResourceViewsOut = stackalloc System.IntPtr[shaderResourceViewsOut.Length];
                shaderResourceViewsOut_ = _shaderResourceViewsOut;
            }

            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numViews, (void *)shaderResourceViewsOut_, (*(void ***)this._nativePointer)[105]);
            if (shaderResourceViewsOut != null)
                for (int i = 0; i < shaderResourceViewsOut.Length; ++i)
                    if ((shaderResourceViewsOut_)[i] != System.IntPtr.Zero)
                        shaderResourceViewsOut[i] = new SharpDX.Direct3D11.ShaderResourceView((shaderResourceViewsOut_)[i]);
                    else
                        shaderResourceViewsOut[i] = null;
        }

        /// <summary>
        /// <p>Gets an array of views for an unordered resource.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index of the first element in the zero-based array to return (ranges from 0 to D3D11_1_UAV_SLOT_COUNT - 1).</p> </dd></param>
        /// <param name = "numUAVs"><dd>  <p>Number of views to get (ranges from 0 to D3D11_1_UAV_SLOT_COUNT - StartSlot).</p> </dd></param>
        /// <param name = "unorderedAccessViewsOut"><dd>  <p>A reference to an array of interface references (see <strong><see cref = "SharpDX.Direct3D11.UnorderedAccessView"/></strong>) to get.</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call <strong>IUnknown::Release</strong> on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476399</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::CSGetUnorderedAccessViews([In] unsigned int StartSlot,[In] unsigned int NumUAVs,[Out, Buffer, Optional] ID3D11UnorderedAccessView** ppUnorderedAccessViews)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::CSGetUnorderedAccessViews</unmanaged-short>
        internal unsafe void GetUnorderedAccessViews(System.Int32 startSlot, System.Int32 numUAVs, SharpDX.Direct3D11.UnorderedAccessView[] unorderedAccessViewsOut)
        {
            System.IntPtr*unorderedAccessViewsOut_;
            unorderedAccessViewsOut_ = (System.IntPtr*)0;
            if (unorderedAccessViewsOut != null)
            {
                System.IntPtr*_unorderedAccessViewsOut = stackalloc System.IntPtr[unorderedAccessViewsOut.Length];
                unorderedAccessViewsOut_ = _unorderedAccessViewsOut;
            }

            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numUAVs, (void *)unorderedAccessViewsOut_, (*(void ***)this._nativePointer)[106]);
            if (unorderedAccessViewsOut != null)
                for (int i = 0; i < unorderedAccessViewsOut.Length; ++i)
                    if ((unorderedAccessViewsOut_)[i] != System.IntPtr.Zero)
                        unorderedAccessViewsOut[i] = new SharpDX.Direct3D11.UnorderedAccessView((unorderedAccessViewsOut_)[i]);
                    else
                        unorderedAccessViewsOut[i] = null;
        }

        /// <summary>
        /// <p>Get the compute shader currently set on the device.</p>
        /// </summary>
        /// <param name = "computeShaderOut"><dd>  <p>Address of a reference to a Compute shader (see <strong><see cref = "SharpDX.Direct3D11.ComputeShader"/></strong>) to be returned by the method.</p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p>Pointer to an array of class instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>).</p> </dd></param>
        /// <param name = "numClassInstancesRef"><dd>  <p>The number of class-instance elements in the array.</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476397</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::CSGetShader([Out, Optional] ID3D11ComputeShader** ppComputeShader,[Out, Buffer, Optional] ID3D11ClassInstance** ppClassInstances,[InOut] unsigned int* pNumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::CSGetShader</unmanaged-short>
        internal override unsafe void GetShader(out SharpDX.Direct3D11.ComputeShader computeShaderOut, SharpDX.Direct3D11.ClassInstance[] classInstancesOut, ref System.Int32 numClassInstancesRef)
        {
            System.IntPtr computeShaderOut_ = System.IntPtr.Zero;
            System.IntPtr*classInstancesOut_;
            classInstancesOut_ = (System.IntPtr*)0;
            if (classInstancesOut != null)
            {
                System.IntPtr*_classInstancesOut = stackalloc System.IntPtr[classInstancesOut.Length];
                classInstancesOut_ = _classInstancesOut;
            }

            fixed (void *numClassInstancesRef_ = &numClassInstancesRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, &computeShaderOut_, (void *)classInstancesOut_, numClassInstancesRef_, (*(void ***)this._nativePointer)[107]);
            if (computeShaderOut_ != System.IntPtr.Zero)
                computeShaderOut = new SharpDX.Direct3D11.ComputeShader(computeShaderOut_);
            else
                computeShaderOut = null;
            if (classInstancesOut != null)
                for (int i = 0; i < classInstancesOut.Length; ++i)
                    if ((classInstancesOut_)[i] != System.IntPtr.Zero)
                        classInstancesOut[i] = new SharpDX.Direct3D11.ClassInstance((classInstancesOut_)[i]);
                    else
                        classInstancesOut[i] = null;
        }

        /// <summary>
        /// <p>Get an array of sampler state interfaces from the compute-shader stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into a zero-based array to begin getting samplers from (ranges from 0 to <see cref = "SamplerSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numSamplers"><dd>  <p>Number of samplers to get from a device context. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to <see cref = "SamplerSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "samplersOut"><dd>  <p>Pointer to an array of sampler-state interfaces (see <strong><see cref = "SharpDX.Direct3D11.SamplerState"/></strong>).</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476396</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::CSGetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[Out, Buffer, Optional] ID3D11SamplerState** ppSamplers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::CSGetSamplers</unmanaged-short>
        internal override unsafe void GetSamplers(System.Int32 startSlot, System.Int32 numSamplers, SharpDX.Direct3D11.SamplerState[] samplersOut)
        {
            System.IntPtr*samplersOut_;
            samplersOut_ = (System.IntPtr*)0;
            if (samplersOut != null)
            {
                System.IntPtr*_samplersOut = stackalloc System.IntPtr[samplersOut.Length];
                samplersOut_ = _samplersOut;
            }

            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numSamplers, (void *)samplersOut_, (*(void ***)this._nativePointer)[108]);
            if (samplersOut != null)
                for (int i = 0; i < samplersOut.Length; ++i)
                    if ((samplersOut_)[i] != System.IntPtr.Zero)
                        samplersOut[i] = new SharpDX.Direct3D11.SamplerState((samplersOut_)[i]);
                    else
                        samplersOut[i] = null;
        }

        /// <summary>
        /// <p>Get the constant buffers used by the compute-shader stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd>  <p>Number of buffers to retrieve (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd>  <p>Array of constant buffer interface references (see <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>) to be returned by the method.</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476395</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::CSGetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[Out, Buffer, Optional] ID3D11Buffer** ppConstantBuffers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::CSGetConstantBuffers</unmanaged-short>
        internal override unsafe void GetConstantBuffers(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.Direct3D11.Buffer[] constantBuffersOut)
        {
            System.IntPtr*constantBuffersOut_;
            constantBuffersOut_ = (System.IntPtr*)0;
            if (constantBuffersOut != null)
            {
                System.IntPtr*_constantBuffersOut = stackalloc System.IntPtr[constantBuffersOut.Length];
                constantBuffersOut_ = _constantBuffersOut;
            }

            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut_, (*(void ***)this._nativePointer)[109]);
            if (constantBuffersOut != null)
                for (int i = 0; i < constantBuffersOut.Length; ++i)
                    if ((constantBuffersOut_)[i] != System.IntPtr.Zero)
                        constantBuffersOut[i] = new SharpDX.Direct3D11.Buffer((constantBuffersOut_)[i]);
                    else
                        constantBuffersOut[i] = null;
        }

        /// <summary>
        /// <p>Set a compute shader to the device.</p>
        /// </summary>
        /// <param name = "computeShaderRef"><dd>  <p>Pointer to a compute shader (see <strong><see cref = "SharpDX.Direct3D11.ComputeShader"/></strong>). Passing in <strong><c>null</c></strong> disables the shader for this pipeline stage.</p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p>A reference to an array of class-instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <strong><c>null</c></strong> if the shader does not use any interfaces.</p> </dd></param>
        /// <param name = "numClassInstances"><dd>  <p>The number of class-instance interfaces in the array.</p> </dd></param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p>The maximum number of instances a shader can have is 256.</p>
        /// </remarks>
        /// <doc-id>ff476402</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::CSSetShader([In, Optional] ID3D11ComputeShader* pComputeShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[In] unsigned int NumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::CSSetShader</unmanaged-short>
        internal override unsafe void SetShader(SharpDX.Direct3D11.ComputeShader computeShaderRef, SharpDX.ComArray<SharpDX.Direct3D11.ClassInstance> classInstancesOut, System.Int32 numClassInstances)
        {
            System.IntPtr computeShaderRef_ = System.IntPtr.Zero;
            computeShaderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.ComputeShader>(computeShaderRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)computeShaderRef_, (void *)(classInstancesOut?.NativePointer ?? System.IntPtr.Zero), numClassInstances, (*(void ***)this._nativePointer)[69]);
        }

        /// <summary>
        /// <p>Set a compute shader to the device.</p>
        /// </summary>
        /// <param name = "computeShaderRef"><dd>  <p>Pointer to a compute shader (see <strong><see cref = "SharpDX.Direct3D11.ComputeShader"/></strong>). Passing in <strong><c>null</c></strong> disables the shader for this pipeline stage.</p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p>A reference to an array of class-instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <strong><c>null</c></strong> if the shader does not use any interfaces.</p> </dd></param>
        /// <param name = "numClassInstances"><dd>  <p>The number of class-instance interfaces in the array.</p> </dd></param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p>The maximum number of instances a shader can have is 256.</p>
        /// </remarks>
        /// <doc-id>ff476402</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::CSSetShader([In, Optional] ID3D11ComputeShader* pComputeShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[In] unsigned int NumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::CSSetShader</unmanaged-short>
        private unsafe void SetShader(System.IntPtr computeShaderRef, System.IntPtr classInstancesOut, System.Int32 numClassInstances)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)computeShaderRef, (void *)classInstancesOut, numClassInstances, (*(void ***)this._nativePointer)[69]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("6e8c49fb-a371-4770-b440-29086022b741")]
    public partial class Counter : SharpDX.Direct3D11.Asynchronous
    {
        public Counter(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Counter(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Counter(nativePtr);
        /// <summary>
        /// <p>Get a counter description.</p>
        /// </summary>
        /// <doc-id>ff476365</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.Direct3D11.CounterDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Get a counter description.</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p>Pointer to a counter description (see <strong><see cref = "SharpDX.Direct3D11.CounterDescription"/></strong>).</p> </dd></param>
        /// <doc-id>ff476365</doc-id>
        /// <unmanaged>void ID3D11Counter::GetDesc([Out] D3D11_COUNTER_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11Counter::GetDesc</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.Direct3D11.CounterDescription descRef)
        {
            descRef = default (SharpDX.Direct3D11.CounterDescription);
            fixed (void *descRef_ = &descRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[8]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("9B32F9AD-BDCC-40a6-A39D-D5C865845720")]
    public partial class CryptoSession : SharpDX.Direct3D11.DeviceChild
    {
        public CryptoSession(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator CryptoSession(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new CryptoSession(nativePtr);
        /// <summary>
        /// <p>Gets the type of encryption that is supported by this session.</p>
        /// </summary>
        /// <remarks>
        /// <p>The application specifies the encryption type when it creates the session.</p>
        /// </remarks>
        /// <doc-id>hh447699</doc-id>
        /// <unmanaged>GetCryptoType</unmanaged>
        /// <unmanaged-short>GetCryptoType</unmanaged-short>
        public System.Guid CryptoType
        {
            get
            {
                GetCryptoType(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the decoding profile of the session.</p>
        /// </summary>
        /// <remarks>
        /// <p>The application specifies the profile when it creates the session.</p>
        /// </remarks>
        /// <doc-id>hh447701</doc-id>
        /// <unmanaged>GetDecoderProfile</unmanaged>
        /// <unmanaged-short>GetDecoderProfile</unmanaged-short>
        public System.Guid DecoderProfile
        {
            get
            {
                GetDecoderProfile(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the size of the driver's certificate chain.</p>
        /// </summary>
        /// <remarks>
        /// <p>To get the certificate, call <strong>ID3D11CryptoSession::GetCertificate</strong>.</p>
        /// </remarks>
        /// <doc-id>hh447695</doc-id>
        /// <unmanaged>GetCertificateSize</unmanaged>
        /// <unmanaged-short>GetCertificateSize</unmanaged-short>
        public System.Int32 CertificateSize
        {
            get
            {
                GetCertificateSize(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets a handle to the cryptographic session.</p>
        /// </summary>
        /// <remarks>
        /// <p>You can use this handle to associate the session with a decoder. This enables the decoder to decrypt data that is encrypted using this session.</p>
        /// </remarks>
        /// <doc-id>hh447697</doc-id>
        /// <unmanaged>GetCryptoSessionHandle</unmanaged>
        /// <unmanaged-short>GetCryptoSessionHandle</unmanaged-short>
        public System.IntPtr CryptoSessionHandle
        {
            get
            {
                GetCryptoSessionHandle(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the type of encryption that is supported by this session.</p>
        /// </summary>
        /// <param name = "cryptoTypeRef"><dd> <p>Receives a <see cref = "System.Guid"/> that specifies the encryption type. The following GUIDs are defined.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>D3D11_CRYPTO_TYPE_AES128_CTR</strong></dt> </dl> </td><td> <p>128-bit Advanced Encryption Standard CTR mode (AES-CTR) block cipher.</p> </td></tr> </table> <p>?</p> </dd></param>
        /// <remarks>
        /// <p>The application specifies the encryption type when it creates the session.</p>
        /// </remarks>
        /// <doc-id>hh447699</doc-id>
        /// <unmanaged>void ID3D11CryptoSession::GetCryptoType([Out] GUID* pCryptoType)</unmanaged>
        /// <unmanaged-short>ID3D11CryptoSession::GetCryptoType</unmanaged-short>
        internal unsafe void GetCryptoType(out System.Guid cryptoTypeRef)
        {
            cryptoTypeRef = default (System.Guid);
            fixed (void *cryptoTypeRef_ = &cryptoTypeRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, cryptoTypeRef_, (*(void ***)this._nativePointer)[7]);
        }

        /// <summary>
        /// <p>Gets the decoding profile of the session.</p>
        /// </summary>
        /// <param name = "decoderProfileRef"><dd> <p>Receives the decoding profile. For a list of possible values, see <strong>ID3D11VideoDevice::GetVideoDecoderProfile</strong>. </p> </dd></param>
        /// <remarks>
        /// <p>The application specifies the profile when it creates the session.</p>
        /// </remarks>
        /// <doc-id>hh447701</doc-id>
        /// <unmanaged>void ID3D11CryptoSession::GetDecoderProfile([Out] GUID* pDecoderProfile)</unmanaged>
        /// <unmanaged-short>ID3D11CryptoSession::GetDecoderProfile</unmanaged-short>
        internal unsafe void GetDecoderProfile(out System.Guid decoderProfileRef)
        {
            decoderProfileRef = default (System.Guid);
            fixed (void *decoderProfileRef_ = &decoderProfileRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, decoderProfileRef_, (*(void ***)this._nativePointer)[8]);
        }

        /// <summary>
        /// <p>Gets the size of the driver's certificate chain.</p>
        /// </summary>
        /// <param name = "certificateSizeRef"><dd> <p>Receives the size of the certificate chain, in bytes. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>To get the certificate, call <strong>ID3D11CryptoSession::GetCertificate</strong>.</p>
        /// </remarks>
        /// <doc-id>hh447695</doc-id>
        /// <unmanaged>HRESULT ID3D11CryptoSession::GetCertificateSize([Out] unsigned int* pCertificateSize)</unmanaged>
        /// <unmanaged-short>ID3D11CryptoSession::GetCertificateSize</unmanaged-short>
        internal unsafe void GetCertificateSize(out System.Int32 certificateSizeRef)
        {
            SharpDX.Result __result__;
            fixed (void *certificateSizeRef_ = &certificateSizeRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, certificateSizeRef_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the driver's certificate chain.</p>
        /// </summary>
        /// <param name = "certificateSize"><dd> <p>The size of the <em>pCertificate</em> array, in bytes. To get the size of the certificate chain, call <strong>ID3D11CryptoSession::GetCertificateSize</strong>.</p> </dd></param>
        /// <param name = "certificateRef"><dd> <p>A reference to a byte array that receives the driver's certificate chain. The caller must allocate the array.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447693</doc-id>
        /// <unmanaged>HRESULT ID3D11CryptoSession::GetCertificate([In] unsigned int CertificateSize,[Out, Buffer] unsigned char* pCertificate)</unmanaged>
        /// <unmanaged-short>ID3D11CryptoSession::GetCertificate</unmanaged-short>
        public unsafe void GetCertificate(System.Int32 certificateSize, System.Byte[] certificateRef)
        {
            SharpDX.Result __result__;
            fixed (void *certificateRef_ = certificateRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, certificateSize, certificateRef_, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets a handle to the cryptographic session.</p>
        /// </summary>
        /// <param name = "cryptoSessionHandleRef"><dd> <p>Receives a handle to the session.</p> </dd></param>
        /// <remarks>
        /// <p>You can use this handle to associate the session with a decoder. This enables the decoder to decrypt data that is encrypted using this session.</p>
        /// </remarks>
        /// <doc-id>hh447697</doc-id>
        /// <unmanaged>void ID3D11CryptoSession::GetCryptoSessionHandle([Out] void** pCryptoSessionHandle)</unmanaged>
        /// <unmanaged-short>ID3D11CryptoSession::GetCryptoSessionHandle</unmanaged-short>
        internal unsafe void GetCryptoSessionHandle(out System.IntPtr cryptoSessionHandleRef)
        {
            fixed (void *cryptoSessionHandleRef_ = &cryptoSessionHandleRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, cryptoSessionHandleRef_, (*(void ***)this._nativePointer)[11]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("03823efb-8d8f-4e1c-9aa2-f64bb2cbfdf1")]
    public partial class DepthStencilState : SharpDX.Direct3D11.DeviceChild
    {
        public DepthStencilState(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DepthStencilState(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DepthStencilState(nativePtr);
        /// <summary>
        /// <p>Gets the description for depth-stencil state that you used to create the depth-stencil-state object.</p>
        /// </summary>
        /// <remarks>
        /// <p>You use the description for depth-stencil state in a call to the <strong>ID3D11Device::CreateDepthStencilState</strong> method to create the depth-stencil-state object.</p>
        /// </remarks>
        /// <doc-id>ff476376</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.Direct3D11.DepthStencilStateDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the description for depth-stencil state that you used to create the depth-stencil-state object.</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.DepthStencilStateDescription"/></strong> structure that receives a description of the depth-stencil state.</p> </dd></param>
        /// <remarks>
        /// <p>You use the description for depth-stencil state in a call to the <strong>ID3D11Device::CreateDepthStencilState</strong> method to create the depth-stencil-state object.</p>
        /// </remarks>
        /// <doc-id>ff476376</doc-id>
        /// <unmanaged>void ID3D11DepthStencilState::GetDesc([Out] D3D11_DEPTH_STENCIL_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11DepthStencilState::GetDesc</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.Direct3D11.DepthStencilStateDescription descRef)
        {
            descRef = default (SharpDX.Direct3D11.DepthStencilStateDescription);
            fixed (void *descRef_ = &descRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[7]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("9fdac92a-1876-48c3-afad-25b94f84a9b6")]
    public partial class DepthStencilView : SharpDX.Direct3D11.ResourceView
    {
        public DepthStencilView(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DepthStencilView(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DepthStencilView(nativePtr);
        /// <summary>
        /// <p>A depth-stencil-view interface accesses a texture resource during depth-stencil testing.</p>
        /// </summary>
        /// <remarks>
        /// <p>To create a depth-stencil view, call <strong>ID3D11Device::CreateDepthStencilView</strong>.</p><p>To bind a depth-stencil view to the pipeline, call <strong>ID3D11DeviceContext::OMSetRenderTargets</strong>.</p>
        /// </remarks>
        /// <doc-id>ff476377</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.Direct3D11.DepthStencilViewDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>A depth-stencil-view interface accesses a texture resource during depth-stencil testing.</p>
        /// </summary>
        /// <param name = "descRef">No documentation.</param>
        /// <remarks>
        /// <p>To create a depth-stencil view, call <strong>ID3D11Device::CreateDepthStencilView</strong>.</p><p>To bind a depth-stencil view to the pipeline, call <strong>ID3D11DeviceContext::OMSetRenderTargets</strong>.</p>
        /// </remarks>
        /// <doc-id>ff476377</doc-id>
        /// <unmanaged>void ID3D11DepthStencilView::GetDesc([Out] D3D11_DEPTH_STENCIL_VIEW_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11DepthStencilView::GetDesc</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.Direct3D11.DepthStencilViewDescription descRef)
        {
            descRef = default (SharpDX.Direct3D11.DepthStencilViewDescription);
            fixed (void *descRef_ = &descRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[8]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("db6f6ddb-ac77-4e88-8253-819df9bbf140")]
    public partial class Device : SharpDX.ComObject
    {
        public Device(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device(nativePtr);
                ///<summary>Constant MultisampleCountMaximum</summary>
        ///<unmanaged>D3D11_MAX_MULTISAMPLE_SAMPLE_COUNT</unmanaged>
        public const int MultisampleCountMaximum = unchecked ((int)32);
        /// <summary>
        /// <p>Gets the feature level of the hardware device.</p>
        /// </summary>
        /// <remarks>
        /// <p> Feature levels determine the capabilities of your device.</p>
        /// </remarks>
        /// <doc-id>ff476528</doc-id>
        /// <unmanaged>GetFeatureLevel</unmanaged>
        /// <unmanaged-short>GetFeatureLevel</unmanaged-short>
        public SharpDX.Direct3D.FeatureLevel FeatureLevel
        {
            get => GetFeatureLevel();
        }

        /// <summary>
        /// <p>Get the flags used during the call to create the device with <strong>D3D11CreateDevice</strong>.</p>
        /// </summary>
        /// <doc-id>ff476525</doc-id>
        /// <unmanaged>GetCreationFlags</unmanaged>
        /// <unmanaged-short>GetCreationFlags</unmanaged-short>
        public SharpDX.Direct3D11.DeviceCreationFlags CreationFlags
        {
            get => GetCreationFlags();
        }

        /// <summary>
        /// <p>Get the reason why the device was removed.</p>
        /// </summary>
        /// <doc-id>ff476526</doc-id>
        /// <unmanaged>GetDeviceRemovedReason</unmanaged>
        /// <unmanaged-short>GetDeviceRemovedReason</unmanaged-short>
        public SharpDX.Result DeviceRemovedReason
        {
            get => GetDeviceRemovedReason();
        }

        /// <summary>
        /// <p>Gets an immediate context, which can play back command lists.</p>
        /// </summary>
        /// <remarks>
        /// <p>The <strong>GetImmediateContext</strong> method returns an <strong><see cref = "SharpDX.Direct3D11.DeviceContext"/></strong> object that represents an immediate context which is used to perform rendering that you want immediately submitted to a device. For most applications, an immediate context is the primary object that is used to draw your scene.</p><p>The <strong>GetImmediateContext</strong> method increments the reference count of the immediate context by one. Therefore, you must call <strong>Release</strong> on the returned interface reference when you are done with it to avoid a memory leak. </p>
        /// </remarks>
        /// <doc-id>ff476529</doc-id>
        /// <unmanaged>GetImmediateContext</unmanaged>
        /// <unmanaged-short>GetImmediateContext</unmanaged-short>
        public SharpDX.Direct3D11.DeviceContext ImmediateContext
        {
            get
            {
                if (this.ImmediateContext__ == null)
                    GetImmediateContext(out ImmediateContext__);
                return this.ImmediateContext__;
            }
        }

        protected internal SharpDX.Direct3D11.DeviceContext ImmediateContext__;
        /// <summary>
        /// <p>Get or sets the exception-mode flags.</p>
        /// </summary>
        /// <remarks>
        /// <p>An exception-mode flag is used to elevate an error condition to a non-continuable exception. </p>
        /// </remarks>
        /// <doc-id>ff476527</doc-id>
        /// <unmanaged>GetExceptionMode / SetExceptionMode</unmanaged>
        /// <unmanaged-short>GetExceptionMode</unmanaged-short>
        public System.Int32 ExceptionMode
        {
            get => GetExceptionMode();
            set => SetExceptionMode(value);
        }

        /// <summary>
        /// <p>Creates a buffer (vertex buffer, index buffer, or shader-constant buffer).</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p> A reference to a <strong><see cref = "SharpDX.Direct3D11.BufferDescription"/></strong> structure that describes the buffer. </p> </dd></param>
        /// <param name = "initialDataRef"><dd>  <p> A reference to a <strong><see cref = "SharpDX.DataBox"/></strong> structure that describes  the initialization data; use <strong><c>null</c></strong> to allocate space only (with the exception that it cannot be <strong><c>null</c></strong> if the usage flag is <strong>D3D11_USAGE_IMMUTABLE</strong>). </p> <p> If you don't pass anything to <em>pInitialData</em>, the initial content of the memory for the buffer is undefined. In this case, you need to write the buffer content some other way before the resource is read. </p> </dd></param>
        /// <param name = "bufferOut"><dd>  <p> Address of a reference to the <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong> interface for the buffer object created. Set this parameter to <strong><c>null</c></strong> to validate the other input parameters (<strong>S_FALSE</strong> indicates a pass). </p> </dd></param>
        /// <returns><p> This method returns <strong>E_OUTOFMEMORY</strong> if there is insufficient memory to create the buffer. See Direct3D 11 Return Codes for other possible return values. </p></returns>
        /// <remarks>
        /// <p> For example code, see How to: Create a Vertex Buffer, How to: Create an Index Buffer or  How to: Create a Constant Buffer. </p><p> For a constant buffer (<strong>BindFlags</strong> of  <strong><see cref = "SharpDX.Direct3D11.BufferDescription"/></strong> set to <strong>D3D11_BIND_CONSTANT_BUFFER</strong>),  you must set the <strong>ByteWidth</strong> value of  <strong><see cref = "SharpDX.Direct3D11.BufferDescription"/></strong> in multiples of 16, and less than or equal to <strong>D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT</strong>. </p><p> The Direct3D 11.1 runtime, which is available on Windows?8 and later operating systems, provides the following new functionality for <strong>CreateBuffer</strong>: </p><p> You can create a constant buffer that is larger than the maximum constant buffer size that a shader can access (4096 32-bit*4-component constants ? 64KB). When you bind the constant buffer to the pipeline (for example, via <strong>PSSetConstantBuffers</strong> or <strong>PSSetConstantBuffers1</strong>),  you can define a range of the buffer that the shader can access that fits within the 4096 constant limit. </p><p> The runtime will emulate this feature for feature level 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3. This feature is always available on new drivers for feature level 10 and higher. On existing drivers that are implemented to feature level 10 and higher, a call to <strong>CreateBuffer</strong> to request a constant buffer that is larger than 4096 fails. </p>
        /// </remarks>
        /// <doc-id>ff476501</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreateBuffer([In] const D3D11_BUFFER_DESC* pDesc,[In, Optional] const D3D11_SUBRESOURCE_DATA* pInitialData,[Out, Fast] ID3D11Buffer** ppBuffer)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreateBuffer</unmanaged-short>
        internal unsafe void CreateBuffer(ref SharpDX.Direct3D11.BufferDescription descRef, SharpDX.DataBox? initialDataRef, SharpDX.Direct3D11.Buffer bufferOut)
        {
            SharpDX.DataBox initialDataRef_;
            System.IntPtr bufferOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (initialDataRef != null)
                initialDataRef_ = initialDataRef.Value;
            fixed (void *descRef_ = &descRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, descRef_, initialDataRef == null ? (void *)0 : &initialDataRef_, &bufferOut_, (*(void ***)this._nativePointer)[3]);
            (bufferOut).NativePointer = bufferOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an array of 1D textures.</p>
        /// </summary>
        /// <param name = "descRef">No documentation.</param>
        /// <param name = "initialDataRef">No documentation.</param>
        /// <param name = "texture1DOut">No documentation.</param>
        /// <returns><p>If the method succeeds, the return code is <see cref = "SharpDX.Result.Ok"/>. See Direct3D 11 Return Codes for failing error codes.</p></returns>
        /// <remarks>
        /// <p><strong>CreateTexture1D</strong> creates a 1D texture resource, which can contain a number of 1D subresources. The number of textures is specified in the texture description. All textures in a resource must have the same format, size, and number of mipmap levels.</p><p>All resources are made up of one or more subresources. To load data into the texture, applications can supply the data initially as an array of <strong><see cref = "SharpDX.DataBox"/></strong> structures pointed to by <em>pInitialData</em>, or they can use one of the D3DX texture functions such as <strong>D3DX11CreateTextureFromFile</strong>.</p><p>For a 32 width texture with a full mipmap chain, the <em>pInitialData</em> array has the following 6 elements:
        /// </p><ul> <li>pInitialData[0] = 32x1</li> <li>pInitialData[1] = 16x1</li> <li>pInitialData[2] = 8x1</li> <li>pInitialData[3] = 4x1
        /// </li> <li>pInitialData[4] = 2x1
        /// </li> <li>pInitialData[5] = 1x1
        /// </li> </ul>
        /// </remarks>
        /// <doc-id>ff476520</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreateTexture1D([In] const D3D11_TEXTURE1D_DESC* pDesc,[In, Buffer, Optional] const D3D11_SUBRESOURCE_DATA* pInitialData,[Out, Fast] ID3D11Texture1D** ppTexture1D)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreateTexture1D</unmanaged-short>
        internal unsafe void CreateTexture1D(ref SharpDX.Direct3D11.Texture1DDescription descRef, SharpDX.DataBox[] initialDataRef, SharpDX.Direct3D11.Texture1D texture1DOut)
        {
            System.IntPtr texture1DOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *initialDataRef_ = initialDataRef)
                fixed (void *descRef_ = &descRef)
                    __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, descRef_, initialDataRef_, &texture1DOut_, (*(void ***)this._nativePointer)[4]);
            (texture1DOut).NativePointer = texture1DOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Create an array of 2D textures.</p>
        /// </summary>
        /// <param name = "descRef">No documentation.</param>
        /// <param name = "initialDataRef">No documentation.</param>
        /// <param name = "texture2DOut">No documentation.</param>
        /// <returns><p>If the method succeeds, the return code is <see cref = "SharpDX.Result.Ok"/>. See Direct3D 11 Return Codes for failing error codes.</p></returns>
        /// <remarks>
        /// <p><strong>CreateTexture2D</strong> creates a 2D texture resource, which can contain a number of 2D subresources. The number of textures is specified in the texture description. All textures in a resource must have the same format, size, and number of mipmap levels.</p><p>All resources are made up of one or more subresources. To load data into the texture, applications can supply the data initially as an array of <strong><see cref = "SharpDX.DataBox"/></strong> structures pointed to by <em>pInitialData</em>, or it may use one of the D3DX texture functions such as <strong>D3DX11CreateTextureFromFile</strong>.</p><p>For a 32 x 32 texture with a full mipmap chain, the <em>pInitialData</em> array has the following 6 elements:
        /// </p><ul> <li>pInitialData[0] = 32x32</li> <li>pInitialData[1] = 16x16</li> <li>pInitialData[2] = 8x8</li> <li>pInitialData[3] = 4x4
        /// </li> <li>pInitialData[4] = 2x2
        /// </li> <li>pInitialData[5] = 1x1
        /// </li> </ul>
        /// </remarks>
        /// <doc-id>ff476521</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreateTexture2D([In] const D3D11_TEXTURE2D_DESC* pDesc,[In, Buffer, Optional] const D3D11_SUBRESOURCE_DATA* pInitialData,[Out, Fast] ID3D11Texture2D** ppTexture2D)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreateTexture2D</unmanaged-short>
        internal unsafe void CreateTexture2D(ref SharpDX.Direct3D11.Texture2DDescription descRef, SharpDX.DataBox[] initialDataRef, SharpDX.Direct3D11.Texture2D texture2DOut)
        {
            System.IntPtr texture2DOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *initialDataRef_ = initialDataRef)
                fixed (void *descRef_ = &descRef)
                    __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, descRef_, initialDataRef_, &texture2DOut_, (*(void ***)this._nativePointer)[5]);
            (texture2DOut).NativePointer = texture2DOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Create a single 3D texture.</p>
        /// </summary>
        /// <param name = "descRef">No documentation.</param>
        /// <param name = "initialDataRef">No documentation.</param>
        /// <param name = "texture3DOut">No documentation.</param>
        /// <returns><p>If the method succeeds, the return code is <see cref = "SharpDX.Result.Ok"/>. See Direct3D 11 Return Codes for failing error codes.</p></returns>
        /// <remarks>
        /// <p><strong>CreateTexture3D</strong> creates a 3D texture resource, which can contain a number of 3D subresources. The number of textures is specified in the texture description. All textures in a resource must have the same format, size, and number of mipmap levels.</p><p>All resources are made up of one or more subresources. To load data into the texture, applications can supply the data initially as an array of <strong><see cref = "SharpDX.DataBox"/></strong> structures pointed to by <em>pInitialData</em>, or they can use one of the D3DX texture functions such as <strong>D3DX11CreateTextureFromFile</strong>.</p><p>Each element of <em>pInitialData</em> provides all of the slices that are defined for a given miplevel. For example, for a 32 x 32 x 4 volume texture with a full mipmap chain, the array has the following 6 elements:</p><ul> <li>pInitialData[0] = 32x32 with 4 slices</li> <li>pInitialData[1] = 16x16 with 2 slices</li> <li>pInitialData[2] = 8x8 with 1 slice</li> <li>pInitialData[3] = 4x4
        /// with 1 slice</li> <li>pInitialData[4] = 2x2
        /// with 1 slice</li> <li>pInitialData[5] = 1x1
        /// with 1 slice</li> </ul>
        /// </remarks>
        /// <doc-id>ff476522</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreateTexture3D([In] const D3D11_TEXTURE3D_DESC* pDesc,[In, Buffer, Optional] const D3D11_SUBRESOURCE_DATA* pInitialData,[Out, Fast] ID3D11Texture3D** ppTexture3D)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreateTexture3D</unmanaged-short>
        internal unsafe void CreateTexture3D(ref SharpDX.Direct3D11.Texture3DDescription descRef, SharpDX.DataBox[] initialDataRef, SharpDX.Direct3D11.Texture3D texture3DOut)
        {
            System.IntPtr texture3DOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *initialDataRef_ = initialDataRef)
                fixed (void *descRef_ = &descRef)
                    __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, descRef_, initialDataRef_, &texture3DOut_, (*(void ***)this._nativePointer)[6]);
            (texture3DOut).NativePointer = texture3DOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Create a shader-resource view for accessing data in a resource.</p>
        /// </summary>
        /// <param name = "resourceRef"><dd>  <p> Pointer to the resource that will serve as input to a shader. This resource must have been created with the <strong> D3D11_BIND_SHADER_RESOURCE </strong> flag. </p> </dd></param>
        /// <param name = "descRef"><dd>  <p> Pointer to a shader-resource view description (see <strong><see cref = "SharpDX.Direct3D11.ShaderResourceViewDescription"/></strong>). Set this parameter to <strong><c>null</c></strong> to create a view that accesses the entire resource (using the format the resource was created with). </p> </dd></param>
        /// <param name = "sRViewOut"><dd>  <p> Address of a reference to an <strong><see cref = "SharpDX.Direct3D11.ShaderResourceView"/></strong>. Set this parameter to <strong><c>null</c></strong> to validate the other input parameters (the method will return <strong>S_FALSE</strong> if the other input parameters pass validation). </p> </dd></param>
        /// <returns><p> This method returns one of the following Direct3D 11 Return Codes. </p></returns>
        /// <remarks>
        /// <p> A resource is made up of one or more subresources; a view identifies which subresources to allow the pipeline to access. In addition, each resource is bound to the pipeline using a view. A shader-resource view is designed to bind any buffer or texture resource to the shader stages using the following API methods: <strong>ID3D11DeviceContext::VSSetShaderResources</strong>, <strong>ID3D11DeviceContext::GSSetShaderResources</strong> and <strong>ID3D11DeviceContext::PSSetShaderResources</strong>. </p><p>Because a view is fully typed, this means that typeless resources become fully typed when bound to the pipeline.</p><strong>Note</strong>?? To successfully create a shader-resource view from a typeless buffer (for example, <strong>DXGI_FORMAT_R32G32B32A32_TYPELESS</strong>), you must set the <strong>D3D11_RESOURCE_MISC_BUFFER_ALLOW_RAW_VIEWS</strong> flag when you create the buffer.?<p> The Direct3D 11.1 runtime, which is available starting with Windows?8, allows you to use <strong>CreateShaderResourceView</strong> for the following new purpose. </p><p> You can create shader-resource views of video resources so that Direct3D shaders can process those shader-resource views. These video resources are either Texture2D or Texture2DArray. The value in the <strong>ViewDimension</strong> member of the <strong><see cref = "SharpDX.Direct3D11.ShaderResourceViewDescription"/></strong> structure for a created shader-resource view must match the type of video resource, D3D11_SRV_DIMENSION_TEXTURE2D          for Texture2D and D3D11_SRV_DIMENSION_TEXTURE2DARRAY for Texture2DArray. Additionally, the format of the underlying video resource restricts the formats that the view can use. The video resource format values on the <strong><see cref = "SharpDX.DXGI.Format"/></strong> reference page specify the format values that views are restricted to. </p><p>The runtime read+write conflict prevention logic (which stops a resource from being bound as an SRV and RTV or UAV at the same time) treats views of different parts of the same video surface as conflicting for simplicity.  Therefore, the runtime does not allow an application to read from luma while the application simultaneously renders to chroma in the same surface even though the hardware might allow these simultaneous operations.</p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476519</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreateShaderResourceView([In] ID3D11Resource* pResource,[In, Optional] const D3D11_SHADER_RESOURCE_VIEW_DESC* pDesc,[Out, Fast] ID3D11ShaderResourceView** ppSRView)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreateShaderResourceView</unmanaged-short>
        internal unsafe void CreateShaderResourceView(SharpDX.Direct3D11.Resource resourceRef, SharpDX.Direct3D11.ShaderResourceViewDescription? descRef, SharpDX.Direct3D11.ShaderResourceView sRViewOut)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.ShaderResourceViewDescription descRef_;
            System.IntPtr sRViewOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(resourceRef);
            if (descRef != null)
                descRef_ = descRef.Value;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)resourceRef_, descRef == null ? (void *)0 : &descRef_, &sRViewOut_, (*(void ***)this._nativePointer)[7]);
            (sRViewOut).NativePointer = sRViewOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a view for accessing an unordered access resource.</p>
        /// </summary>
        /// <param name = "resourceRef">No documentation.</param>
        /// <param name = "descRef">No documentation.</param>
        /// <param name = "uAViewOut">No documentation.</param>
        /// <returns><p>This method returns one of the Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>The Direct3D 11.1 runtime, which is available starting with Windows?8, allows you to use <strong>CreateUnorderedAccessView</strong> for the following new purpose. </p><p>You can create unordered-access views of video resources so that Direct3D shaders can process those unordered-access views. These video resources are either Texture2D or Texture2DArray. The value in the <strong>ViewDimension</strong> member of the <strong><see cref = "SharpDX.Direct3D11.UnorderedAccessViewDescription"/></strong> structure for a created unordered-access view must match the type of video resource, D3D11_UAV_DIMENSION_TEXTURE2D          for Texture2D and D3D11_UAV_DIMENSION_TEXTURE2DARRAY for Texture2DArray. Additionally, the format of the underlying video resource restricts the formats that the view can use. The video resource format values on the <strong><see cref = "SharpDX.DXGI.Format"/></strong> reference page specify the format values that views are restricted to.</p><p>The runtime read+write conflict prevention logic (which stops a resource from being bound as an SRV and RTV or UAV at the same time) treats views of different parts of the same video surface as conflicting for simplicity.  Therefore, the runtime does not allow an application to read from luma while the application simultaneously renders to chroma in the same surface even though the hardware might allow these simultaneous operations.</p>
        /// </remarks>
        /// <doc-id>ff476523</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreateUnorderedAccessView([In] ID3D11Resource* pResource,[In, Optional] const D3D11_UNORDERED_ACCESS_VIEW_DESC* pDesc,[Out, Fast] ID3D11UnorderedAccessView** ppUAView)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreateUnorderedAccessView</unmanaged-short>
        internal unsafe void CreateUnorderedAccessView(SharpDX.Direct3D11.Resource resourceRef, SharpDX.Direct3D11.UnorderedAccessViewDescription? descRef, SharpDX.Direct3D11.UnorderedAccessView uAViewOut)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.UnorderedAccessViewDescription descRef_;
            System.IntPtr uAViewOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(resourceRef);
            if (descRef != null)
                descRef_ = descRef.Value;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)resourceRef_, descRef == null ? (void *)0 : &descRef_, &uAViewOut_, (*(void ***)this._nativePointer)[8]);
            (uAViewOut).NativePointer = uAViewOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a render-target view for accessing resource data.</p>
        /// </summary>
        /// <param name = "resourceRef"><dd>  <p>Pointer to a <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong> that represents a render target. This resource must have been created with the <strong>D3D11_BIND_RENDER_TARGET</strong> flag.</p> </dd></param>
        /// <param name = "descRef"><dd>  <p>Pointer to a <strong><see cref = "SharpDX.Direct3D11.RenderTargetViewDescription"/></strong> that represents a render-target view description. Set this parameter to <strong><c>null</c></strong> to create a view that accesses all of the subresources in mipmap level 0.</p> </dd></param>
        /// <param name = "rTViewOut"><dd>  <p>Address of a reference to an <strong><see cref = "SharpDX.Direct3D11.RenderTargetView"/></strong>. Set this parameter to <strong><c>null</c></strong> to validate the other input parameters (the method will return S_FALSE if the other input parameters pass validation).</p> </dd></param>
        /// <returns><p>This method returns one of the Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>A render-target view can be bound to the output-merger stage by calling <strong>ID3D11DeviceContext::OMSetRenderTargets</strong>.</p><p>The Direct3D 11.1 runtime, which is available starting with Windows?8, allows you to use <strong>CreateRenderTargetView</strong> for the following new purpose. </p><p>You can create render-target views of video resources so that Direct3D shaders can process those render-target views. These video resources are either Texture2D or Texture2DArray. The value in the <strong>ViewDimension</strong> member of the <strong><see cref = "SharpDX.Direct3D11.RenderTargetViewDescription"/></strong> structure for a created render-target view must match the type of video resource, D3D11_RTV_DIMENSION_TEXTURE2D          for Texture2D and D3D11_RTV_DIMENSION_TEXTURE2DARRAY for Texture2DArray. Additionally, the format of the underlying video resource restricts the formats that the view can use. The video resource format values on the <strong><see cref = "SharpDX.DXGI.Format"/></strong> reference page specify the format values that views are restricted to.</p><p>The runtime read+write conflict prevention logic (which stops a resource from being bound as an SRV and RTV or UAV at the same time) treats views of different parts of the same video surface as conflicting for simplicity.  Therefore, the runtime does not allow an application to read from luma while the application simultaneously renders to chroma in the same surface even though the hardware might allow these simultaneous operations.</p>
        /// </remarks>
        /// <doc-id>ff476517</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreateRenderTargetView([In] ID3D11Resource* pResource,[In, Optional] const D3D11_RENDER_TARGET_VIEW_DESC* pDesc,[Out, Fast] ID3D11RenderTargetView** ppRTView)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreateRenderTargetView</unmanaged-short>
        internal unsafe void CreateRenderTargetView(SharpDX.Direct3D11.Resource resourceRef, SharpDX.Direct3D11.RenderTargetViewDescription? descRef, SharpDX.Direct3D11.RenderTargetView rTViewOut)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.RenderTargetViewDescription descRef_;
            System.IntPtr rTViewOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(resourceRef);
            if (descRef != null)
                descRef_ = descRef.Value;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)resourceRef_, descRef == null ? (void *)0 : &descRef_, &rTViewOut_, (*(void ***)this._nativePointer)[9]);
            (rTViewOut).NativePointer = rTViewOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Create a depth-stencil view for accessing resource data.</p>
        /// </summary>
        /// <param name = "resourceRef"><dd>  <p>Pointer to the resource that will serve as the depth-stencil surface. This resource must have been created with the <strong>D3D11_BIND_DEPTH_STENCIL</strong> flag.</p> </dd></param>
        /// <param name = "descRef"><dd>  <p>Pointer to a depth-stencil-view description (see <strong><see cref = "SharpDX.Direct3D11.DepthStencilViewDescription"/></strong>). Set this parameter to <strong><c>null</c></strong> to create a view that accesses mipmap level 0 of the entire resource (using the format the resource was created with).</p> </dd></param>
        /// <param name = "depthStencilViewOut"><dd>  <p>Address of a reference to an <strong><see cref = "SharpDX.Direct3D11.DepthStencilView"/></strong>. Set this parameter to <strong><c>null</c></strong> to validate the other input parameters (the method will return S_FALSE if the other input parameters pass validation).</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>A depth-stencil view can be bound to the output-merger stage by calling <strong>ID3D11DeviceContext::OMSetRenderTargets</strong>.</p>
        /// </remarks>
        /// <doc-id>ff476507</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreateDepthStencilView([In] ID3D11Resource* pResource,[In, Optional] const D3D11_DEPTH_STENCIL_VIEW_DESC* pDesc,[Out, Fast] ID3D11DepthStencilView** ppDepthStencilView)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreateDepthStencilView</unmanaged-short>
        internal unsafe void CreateDepthStencilView(SharpDX.Direct3D11.Resource resourceRef, SharpDX.Direct3D11.DepthStencilViewDescription? descRef, SharpDX.Direct3D11.DepthStencilView depthStencilViewOut)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.DepthStencilViewDescription descRef_;
            System.IntPtr depthStencilViewOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(resourceRef);
            if (descRef != null)
                descRef_ = descRef.Value;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)resourceRef_, descRef == null ? (void *)0 : &descRef_, &depthStencilViewOut_, (*(void ***)this._nativePointer)[10]);
            (depthStencilViewOut).NativePointer = depthStencilViewOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Create an input-layout object to describe the input-buffer data for the input-assembler stage.</p>
        /// </summary>
        /// <param name = "inputElementDescsRef"><dd>  <p> An array of the input-assembler stage input data types; each type is described by an element description (see <strong><see cref = "SharpDX.Direct3D11.InputElement"/></strong>). </p> </dd></param>
        /// <param name = "numElements"><dd>  <p>The number of input-data types in the array of input-elements.</p> </dd></param>
        /// <param name = "shaderBytecodeWithInputSignatureRef"><dd>  <p> A reference to the compiled shader.  The compiled shader code contains a input signature which is validated against the array of elements. See remarks. </p> </dd></param>
        /// <param name = "bytecodeLength"><dd>  <p>Size of the compiled shader.</p> </dd></param>
        /// <param name = "inputLayoutOut"><dd>  <p> A reference to the input-layout object created (see <strong><see cref = "SharpDX.Direct3D11.InputLayout"/></strong>). To validate the other input parameters, set this reference to be <strong><c>null</c></strong> and verify that the method returns S_FALSE. </p> </dd></param>
        /// <returns><p> If the method succeeds, the return code is <see cref = "SharpDX.Result.Ok"/>. See Direct3D 11 Return Codes for failing error codes. </p></returns>
        /// <remarks>
        /// <p>After creating an input layout object, it must be bound to the input-assembler stage before calling a draw API.</p><p>Once an input-layout object is created from a shader signature, the input-layout object can be reused with any other shader that has an identical input signature (semantics included). This can simplify the creation of input-layout objects when you are working with many shaders with identical inputs.</p><p> If a data type in the input-layout declaration does not match the data type in a shader-input signature, CreateInputLayout will generate a warning during compilation. The warning is simply to call attention to the fact that the data may be reinterpreted when read from a register. You may either disregard this warning (if reinterpretation is intentional) or make the data types match in both declarations to eliminate the warning. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476512</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreateInputLayout([In, Buffer] const D3D11_INPUT_ELEMENT_DESC* pInputElementDescs,[In] unsigned int NumElements,[In, Buffer] const void* pShaderBytecodeWithInputSignature,[In] SIZE_T BytecodeLength,[Out, Fast] ID3D11InputLayout** ppInputLayout)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreateInputLayout</unmanaged-short>
        internal unsafe void CreateInputLayout(SharpDX.Direct3D11.InputElement[] inputElementDescsRef, System.Int32 numElements, System.IntPtr shaderBytecodeWithInputSignatureRef, SharpDX.PointerSize bytecodeLength, SharpDX.Direct3D11.InputLayout inputLayoutOut)
        {
            SharpDX.Direct3D11.InputElement.__Native[] inputElementDescsRef_ = new SharpDX.Direct3D11.InputElement.__Native[inputElementDescsRef.Length];
            System.IntPtr inputLayoutOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            for (int i = 0; i < inputElementDescsRef.Length; ++i)
                inputElementDescsRef[i].__MarshalTo(ref (inputElementDescsRef_)[i]);
            fixed (void *_inputElementDescsRef = inputElementDescsRef_)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, _inputElementDescsRef, numElements, (void *)shaderBytecodeWithInputSignatureRef, (void *)bytecodeLength, &inputLayoutOut_, (*(void ***)this._nativePointer)[11]);
            (inputLayoutOut).NativePointer = inputLayoutOut_;
            for (int i = 0; i < inputElementDescsRef.Length; ++i)
                inputElementDescsRef[i].__MarshalFree(ref (inputElementDescsRef_)[i]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Create a vertex-shader object from a compiled shader.</p>
        /// </summary>
        /// <param name = "shaderBytecodeRef"><dd>  <p>A reference to the compiled shader. </p> </dd></param>
        /// <param name = "bytecodeLength"><dd>  <p>Size of the compiled vertex shader.</p> </dd></param>
        /// <param name = "classLinkageRef"><dd>  <p>A reference to a class linkage interface (see <strong><see cref = "SharpDX.Direct3D11.ClassLinkage"/></strong>); the value can be <strong><c>null</c></strong>.</p> </dd></param>
        /// <param name = "vertexShaderOut"><dd>  <p>Address of a reference to a <strong><see cref = "SharpDX.Direct3D11.VertexShader"/></strong> interface. If this is <strong><c>null</c></strong>, all other parameters will be validated, and if all parameters pass validation this API will return <strong>S_FALSE</strong> instead of <strong><see cref = "SharpDX.Result.Ok"/></strong>.</p> </dd></param>
        /// <returns><p>This method returns one of the Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>The Direct3D 11.1 runtime, which is available starting with Windows?8, provides the following new functionality for <strong>CreateVertexShader</strong>.</p><p>The following shader model 5.0 instructions are available to just pixel shaders and compute shaders in the Direct3D 11.0 runtime. For the Direct3D 11.1 runtime, because unordered access views (UAV) are available at all shader stages, you can use these instructions in all shader stages.</p><p>Therefore, if you use the following shader model 5.0 instructions in a vertex shader, you can successfully pass the compiled vertex shader to <em>pShaderBytecode</em>. That is, the call to <strong>CreateVertexShader</strong> succeeds.</p><p>If you pass a compiled shader to <em>pShaderBytecode</em> that uses any of the following instructions on a device that doesn?t support UAVs at every shader stage (including existing drivers that are not implemented to support UAVs at every shader stage), <strong>CreateVertexShader</strong> fails.  <strong>CreateVertexShader</strong> also fails if the shader tries to use a UAV slot beyond the set of UAV slots that the hardware supports.</p><ul> <li> dcl_uav_typed </li> <li> dcl_uav_raw </li> <li> dcl_uav_structured </li> <li> ld_raw </li> <li> ld_structured </li> <li> ld_uav_typed </li> <li> store_raw </li> <li> store_structured </li> <li> store_uav_typed </li> <li> sync_uglobal </li> <li>All atomics and immediate atomics (for example, atomic_and and imm_atomic_and)</li> </ul>
        /// </remarks>
        /// <doc-id>ff476524</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreateVertexShader([In, Buffer] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[In, Optional] ID3D11ClassLinkage* pClassLinkage,[Out, Fast] ID3D11VertexShader** ppVertexShader)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreateVertexShader</unmanaged-short>
        internal unsafe void CreateVertexShader(System.IntPtr shaderBytecodeRef, SharpDX.PointerSize bytecodeLength, SharpDX.Direct3D11.ClassLinkage classLinkageRef, SharpDX.Direct3D11.VertexShader vertexShaderOut)
        {
            System.IntPtr classLinkageRef_ = System.IntPtr.Zero;
            System.IntPtr vertexShaderOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            classLinkageRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.ClassLinkage>(classLinkageRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)shaderBytecodeRef, (void *)bytecodeLength, (void *)classLinkageRef_, &vertexShaderOut_, (*(void ***)this._nativePointer)[12]);
            (vertexShaderOut).NativePointer = vertexShaderOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Create a geometry shader.</p>
        /// </summary>
        /// <param name = "shaderBytecodeRef"><dd>  <p>A reference to the compiled shader.  </p> </dd></param>
        /// <param name = "bytecodeLength"><dd>  <p>Size of the compiled geometry shader.</p> </dd></param>
        /// <param name = "classLinkageRef"><dd>  <p>A reference to a class linkage interface (see <strong><see cref = "SharpDX.Direct3D11.ClassLinkage"/></strong>); the value can be <strong><c>null</c></strong>.</p> </dd></param>
        /// <param name = "geometryShaderOut"><dd>  <p>Address of a reference to a <strong><see cref = "SharpDX.Direct3D11.GeometryShader"/></strong> interface. If this is <strong><c>null</c></strong>, all other parameters will be validated, and if all parameters pass validation this API will return S_FALSE instead of <see cref = "SharpDX.Result.Ok"/>.</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>After it is created, the shader can be set to the device by calling <strong>ID3D11DeviceContext::GSSetShader</strong>.</p><p>The Direct3D 11.1 runtime, which is available starting with Windows?8, provides the following new functionality for <strong>CreateGeometryShader</strong>.</p><p>The following shader model 5.0 instructions are available to just pixel shaders and compute shaders in the Direct3D 11.0 runtime. For the Direct3D 11.1 runtime, because unordered access views (UAV) are available at all shader stages, you can use these instructions in all shader stages.</p><p>Therefore, if you use the following shader model 5.0 instructions in a geometry shader, you can successfully pass the compiled geometry shader to <em>pShaderBytecode</em>. That is, the call to <strong>CreateGeometryShader</strong> succeeds.</p><p>If you pass a compiled shader to <em>pShaderBytecode</em> that uses any of the following instructions on a device that doesn?t support UAVs at every shader stage (including existing drivers that are not implemented to support UAVs at every shader stage), <strong>CreateGeometryShader</strong> fails.  <strong>CreateGeometryShader</strong> also fails if the shader tries to use a UAV slot beyond the set of UAV slots that the hardware supports.</p><ul> <li> dcl_uav_typed </li> <li> dcl_uav_raw </li> <li> dcl_uav_structured </li> <li> ld_raw </li> <li> ld_structured </li> <li> ld_uav_typed </li> <li> store_raw </li> <li> store_structured </li> <li> store_uav_typed </li> <li> sync_uglobal </li> <li>All atomics and immediate atomics (for example, atomic_and and imm_atomic_and)</li> </ul>
        /// </remarks>
        /// <doc-id>ff476509</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreateGeometryShader([In, Buffer] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[In, Optional] ID3D11ClassLinkage* pClassLinkage,[Out, Fast] ID3D11GeometryShader** ppGeometryShader)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreateGeometryShader</unmanaged-short>
        internal unsafe void CreateGeometryShader(System.IntPtr shaderBytecodeRef, SharpDX.PointerSize bytecodeLength, SharpDX.Direct3D11.ClassLinkage classLinkageRef, SharpDX.Direct3D11.GeometryShader geometryShaderOut)
        {
            System.IntPtr classLinkageRef_ = System.IntPtr.Zero;
            System.IntPtr geometryShaderOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            classLinkageRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.ClassLinkage>(classLinkageRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)shaderBytecodeRef, (void *)bytecodeLength, (void *)classLinkageRef_, &geometryShaderOut_, (*(void ***)this._nativePointer)[13]);
            (geometryShaderOut).NativePointer = geometryShaderOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a geometry shader that can write to streaming output buffers.</p>
        /// </summary>
        /// <param name = "shaderBytecodeRef"><dd>  <p> A reference to the compiled geometry shader for a standard geometry shader plus stream output. For info on how to get this reference, see Getting a Pointer to a Compiled Shader.</p> <p> To create the stream output without using a geometry shader, pass a reference to the output signature for the prior stage. To obtain this output signature, call the <strong>D3DGetOutputSignatureBlob</strong> compiler function. You can also pass a reference to the compiled shader for the prior stage (for example, the vertex-shader stage or domain-shader stage). This compiled shader provides the output signature for the data. </p> </dd></param>
        /// <param name = "bytecodeLength"><dd>  <p>Size of the compiled geometry shader.</p> </dd></param>
        /// <param name = "sODeclarationRef"><dd>  <p> Pointer to a <strong><see cref = "SharpDX.Direct3D11.StreamOutputElement"/></strong> array. Cannot be <strong><c>null</c></strong> if NumEntries &gt; 0. </p> </dd></param>
        /// <param name = "numEntries"><dd>  <p>The number of entries in the stream output declaration ( ranges from 0 to <see cref = "StreamOutputStreamCount"/> * <see cref = "StreamOutputOutputComponentCount"/> ).</p> </dd></param>
        /// <param name = "bufferStridesRef"><dd>  <p>An array of buffer strides; each stride is the size of an element for that buffer.</p> </dd></param>
        /// <param name = "numStrides"><dd>  <p> The number of strides (or buffers) in <em>pBufferStrides</em> (ranges from 0 to <see cref = "StreamOutputBufferSlotCount"/>). </p> </dd></param>
        /// <param name = "rasterizedStream"><dd>  <p> The index number of the stream to be sent to the rasterizer stage (ranges from 0 to <see cref = "StreamOutputStreamCount"/> - 1). Set to <see cref = "StreamOutputNoRasterizedStream"/> if no stream is to be rasterized. </p> </dd></param>
        /// <param name = "classLinkageRef"><dd>  <p> A reference to a class linkage interface (see <strong><see cref = "SharpDX.Direct3D11.ClassLinkage"/></strong>); the value can be <strong><c>null</c></strong>. </p> </dd></param>
        /// <param name = "geometryShaderOut"><dd>  <p> Address of a reference to an <strong><see cref = "SharpDX.Direct3D11.GeometryShader"/></strong> interface, representing the geometry shader that was created. Set this to <strong><c>null</c></strong> to validate the other parameters; if validation passes, the method will return S_FALSE instead of <see cref = "SharpDX.Result.Ok"/>. </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 11 Return Codes. </p></returns>
        /// <remarks>
        /// <p> For more info about using <strong>CreateGeometryShaderWithStreamOutput</strong>, see Create a Geometry-Shader Object with Stream Output. </p><p> The Direct3D 11.1 runtime, which is available starting with Windows?8, provides the following new functionality for <strong>CreateGeometryShaderWithStreamOutput</strong>. </p><p>The following shader model 5.0 instructions are available to just pixel shaders and compute shaders in the Direct3D 11.0 runtime. For the Direct3D 11.1 runtime, because unordered access views (UAV) are available at all shader stages, you can use these instructions in all shader stages.</p><p> Therefore, if you use the following shader model 5.0 instructions in a geometry shader, you can successfully pass the compiled geometry shader to <em>pShaderBytecode</em>. That is, the call to <strong>CreateGeometryShaderWithStreamOutput</strong> succeeds. </p><p> If you pass a compiled shader to <em>pShaderBytecode</em> that uses any of the following instructions on a device that doesn?t support UAVs at every shader stage (including existing drivers that are not implemented to support UAVs at every shader stage), <strong>CreateGeometryShaderWithStreamOutput</strong> fails.  <strong>CreateGeometryShaderWithStreamOutput</strong> also fails if the shader tries to use a UAV slot beyond the set of UAV slots that the hardware supports. </p><ul> <li> dcl_uav_typed </li> <li> dcl_uav_raw </li> <li> dcl_uav_structured </li> <li> ld_raw </li> <li> ld_structured </li> <li> ld_uav_typed </li> <li> store_raw </li> <li> store_structured </li> <li> store_uav_typed </li> <li> sync_uglobal </li> <li> All atomics and immediate atomics (for example, atomic_and and imm_atomic_and) </li> </ul><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476510</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreateGeometryShaderWithStreamOutput([In, Buffer] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[In, Buffer, Optional] const D3D11_SO_DECLARATION_ENTRY* pSODeclaration,[In] unsigned int NumEntries,[In, Buffer, Optional] const unsigned int* pBufferStrides,[In] unsigned int NumStrides,[In] unsigned int RasterizedStream,[In, Optional] ID3D11ClassLinkage* pClassLinkage,[Out, Fast] ID3D11GeometryShader** ppGeometryShader)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreateGeometryShaderWithStreamOutput</unmanaged-short>
        internal unsafe void CreateGeometryShaderWithStreamOutput(System.IntPtr shaderBytecodeRef, SharpDX.PointerSize bytecodeLength, SharpDX.Direct3D11.StreamOutputElement[] sODeclarationRef, System.Int32 numEntries, System.Int32[] bufferStridesRef, System.Int32 numStrides, System.Int32 rasterizedStream, SharpDX.Direct3D11.ClassLinkage classLinkageRef, SharpDX.Direct3D11.GeometryShader geometryShaderOut)
        {
            SharpDX.Direct3D11.StreamOutputElement.__Native[] sODeclarationRef_ = sODeclarationRef == null ? null : new SharpDX.Direct3D11.StreamOutputElement.__Native[sODeclarationRef.Length];
            System.IntPtr classLinkageRef_ = System.IntPtr.Zero;
            System.IntPtr geometryShaderOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (sODeclarationRef != null)
                for (int i = 0; i < sODeclarationRef.Length; ++i)
                    if (sODeclarationRef != null)
                        sODeclarationRef[i].__MarshalTo(ref (sODeclarationRef_)[i]);
            classLinkageRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.ClassLinkage>(classLinkageRef);
            fixed (void *bufferStridesRef_ = bufferStridesRef)
                fixed (void *_sODeclarationRef = sODeclarationRef_)
                    __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)shaderBytecodeRef, (void *)bytecodeLength, _sODeclarationRef, numEntries, bufferStridesRef_, numStrides, rasterizedStream, (void *)classLinkageRef_, &geometryShaderOut_, (*(void ***)this._nativePointer)[14]);
            (geometryShaderOut).NativePointer = geometryShaderOut_;
            if (sODeclarationRef != null)
                for (int i = 0; i < sODeclarationRef.Length; ++i)
                    if (sODeclarationRef != null)
                        sODeclarationRef[i].__MarshalFree(ref (sODeclarationRef_)[i]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Create a pixel shader.</p>
        /// </summary>
        /// <param name = "shaderBytecodeRef"><dd>  <p>A reference to the compiled shader. </p> </dd></param>
        /// <param name = "bytecodeLength"><dd>  <p>Size of the compiled pixel shader.</p> </dd></param>
        /// <param name = "classLinkageRef"><dd>  <p>A reference to a class linkage interface (see <strong><see cref = "SharpDX.Direct3D11.ClassLinkage"/></strong>); the value can be <strong><c>null</c></strong>.</p> </dd></param>
        /// <param name = "pixelShaderOut"><dd>  <p>Address of a reference to a <strong><see cref = "SharpDX.Direct3D11.PixelShader"/></strong> interface. If this is <strong><c>null</c></strong>, all other parameters will be validated, and if all parameters pass validation this API will return S_FALSE instead of <see cref = "SharpDX.Result.Ok"/>.</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>After creating the pixel shader, you can set it to the device using <strong>ID3D11DeviceContext::PSSetShader</strong>.</p>
        /// </remarks>
        /// <doc-id>ff476513</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreatePixelShader([In, Buffer] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[In, Optional] ID3D11ClassLinkage* pClassLinkage,[Out, Fast] ID3D11PixelShader** ppPixelShader)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreatePixelShader</unmanaged-short>
        internal unsafe void CreatePixelShader(System.IntPtr shaderBytecodeRef, SharpDX.PointerSize bytecodeLength, SharpDX.Direct3D11.ClassLinkage classLinkageRef, SharpDX.Direct3D11.PixelShader pixelShaderOut)
        {
            System.IntPtr classLinkageRef_ = System.IntPtr.Zero;
            System.IntPtr pixelShaderOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            classLinkageRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.ClassLinkage>(classLinkageRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)shaderBytecodeRef, (void *)bytecodeLength, (void *)classLinkageRef_, &pixelShaderOut_, (*(void ***)this._nativePointer)[15]);
            (pixelShaderOut).NativePointer = pixelShaderOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Create a hull shader.</p>
        /// </summary>
        /// <param name = "shaderBytecodeRef">No documentation.</param>
        /// <param name = "bytecodeLength">No documentation.</param>
        /// <param name = "classLinkageRef">No documentation.</param>
        /// <param name = "hullShaderOut">No documentation.</param>
        /// <returns><p>This method returns one of the Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>The Direct3D 11.1 runtime, which is available starting with Windows?8, provides the following new functionality for <strong>CreateHullShader</strong>.</p><p>The following shader model 5.0 instructions are available to just pixel shaders and compute shaders in the Direct3D 11.0 runtime. For the Direct3D 11.1 runtime, because unordered access views (UAV) are available at all shader stages, you can use these instructions in all shader stages.</p><p>Therefore, if you use the following shader model 5.0 instructions in a hull shader, you can successfully pass the compiled hull shader to <em>pShaderBytecode</em>. That is, the call to <strong>CreateHullShader</strong> succeeds.</p><p>If you pass a compiled shader to <em>pShaderBytecode</em> that uses any of the following instructions on a device that doesn?t support UAVs at every shader stage (including existing drivers that are not implemented to support UAVs at every shader stage), <strong>CreateHullShader</strong> fails.  <strong>CreateHullShader</strong> also fails if the shader tries to use a UAV slot beyond the set of UAV slots that the hardware supports.</p><ul> <li> dcl_uav_typed </li> <li> dcl_uav_raw </li> <li> dcl_uav_structured </li> <li> ld_raw </li> <li> ld_structured </li> <li> ld_uav_typed </li> <li> store_raw </li> <li> store_structured </li> <li> store_uav_typed </li> <li> sync_uglobal </li> <li>All atomics and immediate atomics (for example, atomic_and and imm_atomic_and)</li> </ul>
        /// </remarks>
        /// <doc-id>ff476511</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreateHullShader([In, Buffer] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[In, Optional] ID3D11ClassLinkage* pClassLinkage,[Out, Fast] ID3D11HullShader** ppHullShader)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreateHullShader</unmanaged-short>
        internal unsafe void CreateHullShader(System.IntPtr shaderBytecodeRef, SharpDX.PointerSize bytecodeLength, SharpDX.Direct3D11.ClassLinkage classLinkageRef, SharpDX.Direct3D11.HullShader hullShaderOut)
        {
            System.IntPtr classLinkageRef_ = System.IntPtr.Zero;
            System.IntPtr hullShaderOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            classLinkageRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.ClassLinkage>(classLinkageRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)shaderBytecodeRef, (void *)bytecodeLength, (void *)classLinkageRef_, &hullShaderOut_, (*(void ***)this._nativePointer)[16]);
            (hullShaderOut).NativePointer = hullShaderOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Create a domain shader .</p>
        /// </summary>
        /// <param name = "shaderBytecodeRef">No documentation.</param>
        /// <param name = "bytecodeLength">No documentation.</param>
        /// <param name = "classLinkageRef">No documentation.</param>
        /// <param name = "domainShaderOut">No documentation.</param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>The Direct3D 11.1 runtime, which is available starting with Windows?8, provides the following new functionality for <strong>CreateDomainShader</strong>.</p><p>The following shader model 5.0 instructions are available to just pixel shaders and compute shaders in the Direct3D 11.0 runtime. For the Direct3D 11.1 runtime, because unordered access views (UAV) are available at all shader stages, you can use these instructions in all shader stages.</p><p>Therefore, if you use the following shader model 5.0 instructions in a domain shader, you can successfully pass the compiled domain shader to <em>pShaderBytecode</em>. That is, the call to <strong>CreateDomainShader</strong> succeeds.</p><p>If you pass a compiled shader to <em>pShaderBytecode</em> that uses any of the following instructions on a device that doesn?t support UAVs at every shader stage (including existing drivers that are not implemented to support UAVs at every shader stage), <strong>CreateDomainShader</strong> fails.  <strong>CreateDomainShader</strong> also fails if the shader tries to use a UAV slot beyond the set of UAV slots that the hardware supports.</p><ul> <li> dcl_uav_typed </li> <li> dcl_uav_raw </li> <li> dcl_uav_structured </li> <li> ld_raw </li> <li> ld_structured </li> <li> ld_uav_typed </li> <li> store_raw </li> <li> store_structured </li> <li> store_uav_typed </li> <li> sync_uglobal </li> <li>All atomics and immediate atomics (for example, atomic_and and imm_atomic_and)</li> </ul>
        /// </remarks>
        /// <doc-id>ff476508</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreateDomainShader([In, Buffer] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[In, Optional] ID3D11ClassLinkage* pClassLinkage,[Out, Fast] ID3D11DomainShader** ppDomainShader)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreateDomainShader</unmanaged-short>
        internal unsafe void CreateDomainShader(System.IntPtr shaderBytecodeRef, SharpDX.PointerSize bytecodeLength, SharpDX.Direct3D11.ClassLinkage classLinkageRef, SharpDX.Direct3D11.DomainShader domainShaderOut)
        {
            System.IntPtr classLinkageRef_ = System.IntPtr.Zero;
            System.IntPtr domainShaderOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            classLinkageRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.ClassLinkage>(classLinkageRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)shaderBytecodeRef, (void *)bytecodeLength, (void *)classLinkageRef_, &domainShaderOut_, (*(void ***)this._nativePointer)[17]);
            (domainShaderOut).NativePointer = domainShaderOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Create a compute shader.</p>
        /// </summary>
        /// <param name = "shaderBytecodeRef">No documentation.</param>
        /// <param name = "bytecodeLength">No documentation.</param>
        /// <param name = "classLinkageRef">No documentation.</param>
        /// <param name = "computeShaderOut">No documentation.</param>
        /// <returns><p>This method returns E_OUTOFMEMORY if there is insufficient memory to create the compute shader.   See Direct3D 11 Return Codes for other possible return values.</p></returns>
        /// <remarks>
        /// <p>For an example, see How To: Create a Compute Shader and HDRToneMappingCS11 Sample.</p>
        /// </remarks>
        /// <doc-id>ff476503</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreateComputeShader([In, Buffer] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[In, Optional] ID3D11ClassLinkage* pClassLinkage,[Out, Fast] ID3D11ComputeShader** ppComputeShader)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreateComputeShader</unmanaged-short>
        internal unsafe void CreateComputeShader(System.IntPtr shaderBytecodeRef, SharpDX.PointerSize bytecodeLength, SharpDX.Direct3D11.ClassLinkage classLinkageRef, SharpDX.Direct3D11.ComputeShader computeShaderOut)
        {
            System.IntPtr classLinkageRef_ = System.IntPtr.Zero;
            System.IntPtr computeShaderOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            classLinkageRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.ClassLinkage>(classLinkageRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)shaderBytecodeRef, (void *)bytecodeLength, (void *)classLinkageRef_, &computeShaderOut_, (*(void ***)this._nativePointer)[18]);
            (computeShaderOut).NativePointer = computeShaderOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates class linkage libraries to enable dynamic shader linkage.</p>
        /// </summary>
        /// <param name = "linkageOut"><dd>  <p>A reference to a class-linkage interface reference (see <strong><see cref = "SharpDX.Direct3D11.ClassLinkage"/></strong>).</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>The <strong><see cref = "SharpDX.Direct3D11.ClassLinkage"/></strong> interface returned in <em>ppLinkage</em> is associated with a shader by passing it as a parameter to one of the <strong><see cref = "SharpDX.Direct3D11.Device"/></strong> create shader methods such as <strong>ID3D11Device::CreatePixelShader</strong>.</p>
        /// </remarks>
        /// <doc-id>ff476502</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreateClassLinkage([Out, Fast] ID3D11ClassLinkage** ppLinkage)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreateClassLinkage</unmanaged-short>
        internal unsafe void CreateClassLinkage(SharpDX.Direct3D11.ClassLinkage linkageOut)
        {
            System.IntPtr linkageOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &linkageOut_, (*(void ***)this._nativePointer)[19]);
            (linkageOut).NativePointer = linkageOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Create a blend-state object that encapsules blend state for the output-merger stage.</p>
        /// </summary>
        /// <param name = "blendStateDescRef"><dd>  <p> Pointer to a blend-state description (see <strong><see cref = "SharpDX.Direct3D11.BlendStateDescription"/></strong>). </p> </dd></param>
        /// <param name = "blendStateOut"><dd>  <p> Address of a reference to the blend-state object created (see <strong><see cref = "SharpDX.Direct3D11.BlendState"/></strong>). </p> </dd></param>
        /// <returns><p> This method returns E_OUTOFMEMORY if there is insufficient memory to create the blend-state object. See Direct3D 11 Return Codes for other possible return values. </p></returns>
        /// <remarks>
        /// <p> An application can create up to 4096 unique blend-state objects. For each object created, the runtime checks to see if a previous object has the same state. If such a previous object exists, the runtime will return a reference to previous instance instead of creating a duplicate object. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476500</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreateBlendState([In] const D3D11_BLEND_DESC* pBlendStateDesc,[Out, Fast] ID3D11BlendState** ppBlendState)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreateBlendState</unmanaged-short>
        internal unsafe void CreateBlendState(ref SharpDX.Direct3D11.BlendStateDescription blendStateDescRef, SharpDX.Direct3D11.BlendState blendStateOut)
        {
            SharpDX.Direct3D11.BlendStateDescription.__Native blendStateDescRef_ = default (SharpDX.Direct3D11.BlendStateDescription.__Native);
            System.IntPtr blendStateOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            blendStateDescRef.__MarshalTo(ref blendStateDescRef_);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &blendStateDescRef_, &blendStateOut_, (*(void ***)this._nativePointer)[20]);
            (blendStateOut).NativePointer = blendStateOut_;
            blendStateDescRef.__MarshalFree(ref blendStateDescRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Create a depth-stencil state object that encapsulates depth-stencil test information for the output-merger stage.</p>
        /// </summary>
        /// <param name = "depthStencilDescRef"><dd>  <p>Pointer to a depth-stencil state description (see <strong><see cref = "SharpDX.Direct3D11.DepthStencilStateDescription"/></strong>).</p> </dd></param>
        /// <param name = "depthStencilStateOut"><dd>  <p>Address of a reference to the depth-stencil state object created (see <strong><see cref = "SharpDX.Direct3D11.DepthStencilState"/></strong>).</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>4096 unique depth-stencil state objects can be created on a device at a time.</p><p>If an application attempts to create a depth-stencil-state interface with the same state as an existing interface, the same interface will be returned and the total number of unique depth-stencil state objects will stay the same.</p>
        /// </remarks>
        /// <doc-id>ff476506</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreateDepthStencilState([In] const D3D11_DEPTH_STENCIL_DESC* pDepthStencilDesc,[Out, Fast] ID3D11DepthStencilState** ppDepthStencilState)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreateDepthStencilState</unmanaged-short>
        internal unsafe void CreateDepthStencilState(ref SharpDX.Direct3D11.DepthStencilStateDescription depthStencilDescRef, SharpDX.Direct3D11.DepthStencilState depthStencilStateOut)
        {
            System.IntPtr depthStencilStateOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *depthStencilDescRef_ = &depthStencilDescRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, depthStencilDescRef_, &depthStencilStateOut_, (*(void ***)this._nativePointer)[21]);
            (depthStencilStateOut).NativePointer = depthStencilStateOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Create a rasterizer state object that tells the rasterizer stage how to behave.</p>
        /// </summary>
        /// <param name = "rasterizerDescRef"><dd>  <p>Pointer to a rasterizer state description (see <strong><see cref = "SharpDX.Direct3D11.RasterizerStateDescription"/></strong>).</p> </dd></param>
        /// <param name = "rasterizerStateOut"><dd>  <p>Address of a reference to the rasterizer state object created (see <strong><see cref = "SharpDX.Direct3D11.RasterizerState"/></strong>).</p> </dd></param>
        /// <returns><p>This method returns E_OUTOFMEMORY if there is insufficient memory to create the compute shader.  See Direct3D 11 Return Codes for other possible return values.</p></returns>
        /// <remarks>
        /// <p>4096 unique rasterizer state objects can be created on a device at a time.</p><p>If an application attempts to create a rasterizer-state interface with the same state as an existing interface, the same interface will be returned and the total number of unique rasterizer state objects will stay the same.</p>
        /// </remarks>
        /// <doc-id>ff476516</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreateRasterizerState([In] const D3D11_RASTERIZER_DESC* pRasterizerDesc,[Out, Fast] ID3D11RasterizerState** ppRasterizerState)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreateRasterizerState</unmanaged-short>
        internal unsafe void CreateRasterizerState(ref SharpDX.Direct3D11.RasterizerStateDescription rasterizerDescRef, SharpDX.Direct3D11.RasterizerState rasterizerStateOut)
        {
            System.IntPtr rasterizerStateOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *rasterizerDescRef_ = &rasterizerDescRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, rasterizerDescRef_, &rasterizerStateOut_, (*(void ***)this._nativePointer)[22]);
            (rasterizerStateOut).NativePointer = rasterizerStateOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Create a sampler-state object that encapsulates sampling information for a texture.</p>
        /// </summary>
        /// <param name = "samplerDescRef"><dd>  <p>Pointer to a sampler state description (see <strong><see cref = "SharpDX.Direct3D11.SamplerStateDescription"/></strong>).</p> </dd></param>
        /// <param name = "samplerStateOut"><dd>  <p>Address of a reference to the sampler state object created (see <strong><see cref = "SharpDX.Direct3D11.SamplerState"/></strong>).</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>4096 unique sampler state objects can be created on a device at a time.</p><p>If an application attempts to create a sampler-state interface with the same state as an existing interface, the same interface will be returned and the total number of unique sampler state objects will stay the same.</p>
        /// </remarks>
        /// <doc-id>ff476518</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreateSamplerState([In] const D3D11_SAMPLER_DESC* pSamplerDesc,[Out, Fast] ID3D11SamplerState** ppSamplerState)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreateSamplerState</unmanaged-short>
        internal unsafe void CreateSamplerState(ref SharpDX.Direct3D11.SamplerStateDescription samplerDescRef, SharpDX.Direct3D11.SamplerState samplerStateOut)
        {
            System.IntPtr samplerStateOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *samplerDescRef_ = &samplerDescRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, samplerDescRef_, &samplerStateOut_, (*(void ***)this._nativePointer)[23]);
            (samplerStateOut).NativePointer = samplerStateOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>This interface encapsulates methods for querying information from the GPU.</p>
        /// </summary>
        /// <param name = "queryDescRef"><dd>  <p>Pointer to a query description (see <strong><see cref = "SharpDX.Direct3D11.QueryDescription"/></strong>).</p> </dd></param>
        /// <param name = "queryOut"><dd>  <p>Address of a reference to the query object created (see <strong><see cref = "SharpDX.Direct3D11.Query"/></strong>).</p> </dd></param>
        /// <returns><p>This method returns E_OUTOFMEMORY if there is insufficient memory to create the query object.   See Direct3D 11 Return Codes for other possible return values.</p></returns>
        /// <doc-id>ff476515</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreateQuery([In] const D3D11_QUERY_DESC* pQueryDesc,[Out, Fast] ID3D11Query** ppQuery)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreateQuery</unmanaged-short>
        internal unsafe void CreateQuery(SharpDX.Direct3D11.QueryDescription queryDescRef, SharpDX.Direct3D11.Query queryOut)
        {
            System.IntPtr queryOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &queryDescRef, &queryOut_, (*(void ***)this._nativePointer)[24]);
            (queryOut).NativePointer = queryOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a predicate.</p>
        /// </summary>
        /// <param name = "predicateDescRef"><dd>  <p>Pointer to a query description where the type of query must be a D3D11_QUERY_SO_OVERFLOW_PREDICATE or D3D11_QUERY_OCCLUSION_PREDICATE (see <strong><see cref = "SharpDX.Direct3D11.QueryDescription"/></strong>).</p> </dd></param>
        /// <param name = "predicateOut"><dd>  <p>Address of a reference to a predicate (see <strong><see cref = "SharpDX.Direct3D11.Predicate"/></strong>).</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <doc-id>ff476514</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreatePredicate([In] const D3D11_QUERY_DESC* pPredicateDesc,[Out, Fast] ID3D11Predicate** ppPredicate)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreatePredicate</unmanaged-short>
        internal unsafe void CreatePredicate(SharpDX.Direct3D11.QueryDescription predicateDescRef, SharpDX.Direct3D11.Predicate predicateOut)
        {
            System.IntPtr predicateOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &predicateDescRef, &predicateOut_, (*(void ***)this._nativePointer)[25]);
            (predicateOut).NativePointer = predicateOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Create a counter object for measuring GPU performance.</p>
        /// </summary>
        /// <param name = "counterDescRef"><dd>  <p>Pointer to a counter description (see <strong><see cref = "SharpDX.Direct3D11.CounterDescription"/></strong>).</p> </dd></param>
        /// <param name = "counterOut"><dd>  <p>Address of a reference to a counter (see <strong><see cref = "SharpDX.Direct3D11.Counter"/></strong>).</p> </dd></param>
        /// <returns><p>If this function succeeds, it will return <see cref = "SharpDX.Result.Ok"/>. If it fails, possible return values are: S_FALSE, E_OUTOFMEMORY, <see cref = "Unsupported"/>, <see cref = "Nonexclusive"/>, or E_INVALIDARG.</p><p><see cref = "Unsupported"/> is returned whenever the application requests to create a well-known counter, but the current device does not support it.</p><p><see cref = "Nonexclusive"/> indicates that another device object is currently using the counters, so they cannot be used by this device at the moment.</p><p>E_INVALIDARG is returned whenever an out-of-range well-known or device-dependent counter is requested, or when the simulataneously active counters have been exhausted.</p></returns>
        /// <doc-id>ff476504</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreateCounter([In] const D3D11_COUNTER_DESC* pCounterDesc,[Out, Fast] ID3D11Counter** ppCounter)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreateCounter</unmanaged-short>
        internal unsafe void CreateCounter(SharpDX.Direct3D11.CounterDescription counterDescRef, SharpDX.Direct3D11.Counter counterOut)
        {
            System.IntPtr counterOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &counterDescRef, &counterOut_, (*(void ***)this._nativePointer)[26]);
            (counterOut).NativePointer = counterOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a deferred context, which can record command lists. </p>
        /// </summary>
        /// <param name = "contextFlags"><dd>  <p> Reserved for future use. Pass 0. </p> </dd></param>
        /// <param name = "deferredContextOut"><dd>  <p> Upon completion of the method, the passed reference to an <strong><see cref = "SharpDX.Direct3D11.DeviceContext"/></strong> interface reference is initialized. </p> </dd></param>
        /// <returns><p> Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns one of the following: </p><ul> <li> Returns <strong><see cref = "DeviceRemoved"/></strong> if the video card has been physically removed from the system, or a driver upgrade for the video card has occurred. If this error occurs, you should destroy and recreate the device. </li> <li> Returns <strong><see cref = "InvalidCall"/></strong> if the <strong>CreateDeferredContext</strong> method cannot be called from the current context. For example, if the device was created with the <strong>D3D11_CREATE_DEVICE_SINGLETHREADED</strong> value,  <strong>CreateDeferredContext</strong> returns <strong><see cref = "InvalidCall"/></strong>. </li> <li> Returns <strong>E_INVALIDARG</strong> if the <em>ContextFlags</em> parameter is invalid. </li> <li> Returns <strong>E_OUTOFMEMORY</strong> if the application has exhausted available memory. </li> </ul></returns>
        /// <remarks>
        /// <p> A deferred context is a thread-safe context that you can use to record graphics commands on a thread other than the main rendering thread. Using a deferred context, you can record graphics commands into a command list that is encapsulated by the <strong><see cref = "SharpDX.Direct3D11.CommandList"/></strong> interface. After all scene items are recorded, you can then submit them to the main render thread for final rendering. In this manner, you can perform rendering tasks concurrently across multiple threads and potentially improve performance in multi-core CPU scenarios. </p><p> You can create multiple deferred contexts. </p><strong>Note</strong>?? If you use the <strong>D3D11_CREATE_DEVICE_SINGLETHREADED</strong> value to create the device that is represented by <strong><see cref = "SharpDX.Direct3D11.Device"/></strong>, the <strong>CreateDeferredContext</strong> method will fail, and you will not be able to create a deferred context.?<p> For more information about deferred contexts, see Immediate and Deferred Rendering. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476505</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CreateDeferredContext([In] unsigned int ContextFlags,[Out, Fast] ID3D11DeviceContext** ppDeferredContext)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CreateDeferredContext</unmanaged-short>
        internal unsafe void CreateDeferredContext(System.Int32 contextFlags, SharpDX.Direct3D11.DeviceContext deferredContextOut)
        {
            System.IntPtr deferredContextOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, contextFlags, &deferredContextOut_, (*(void ***)this._nativePointer)[27]);
            (deferredContextOut).NativePointer = deferredContextOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Give a device access to a shared resource created on a different device.</p>
        /// </summary>
        /// <param name = "hResource"><dd>  <p>A resource handle. See remarks.</p> </dd></param>
        /// <param name = "returnedInterface"><dd>  <p>The globally unique identifier (<see cref = "System.Guid"/>) for the resource interface. See remarks.</p> </dd></param>
        /// <param name = "resourceOut"><dd>  <p>Address of a reference to the resource we are gaining access to.</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>The REFIID, or <see cref = "System.Guid"/>, of the interface to the resource can be obtained by using the __uuidof() macro. For example, __uuidof(<see cref = "SharpDX.Direct3D11.Buffer"/>) will get the <see cref = "System.Guid"/> of the interface to a buffer resource.</p><p>The unique handle of the resource is obtained differently depending on the type of device that originally created the resource.</p><p>To share a resource between two Direct3D 11 devices the resource must have been created with the  <strong>D3D11_RESOURCE_MISC_SHARED</strong> flag, if it was created using the <see cref = "SharpDX.Direct3D11.Device"/> interface.  If it was created using a DXGI device interface, then the resource is always shared.</p><p>The REFIID, or <see cref = "System.Guid"/>, of the interface to the resource can be obtained by using the __uuidof() macro.  For example, __uuidof(<see cref = "SharpDX.Direct3D11.Buffer"/>) will get the <see cref = "System.Guid"/> of the interface to a buffer resource.</p><p>When sharing a resource between two Direct3D 10/11 devices the unique handle of the resource can be obtained by querying the resource for the <strong><see cref = "SharpDX.DXGI.Resource"/></strong> interface and then calling <strong>GetSharedHandle</strong>.</p><pre> <see cref = "SharpDX.DXGI.Resource"/>* pOtherResource(<c>null</c>);
        /// hr = pOtherDeviceResource-&gt;QueryInterface( __uuidof(<see cref = "SharpDX.DXGI.Resource"/>), (void**)&amp;pOtherResource );
        /// HANDLE sharedHandle;
        /// pOtherResource-&gt;GetSharedHandle(&amp;sharedHandle); </pre><p>The only resources that can be shared are 2D non-mipmapped textures.</p><p>To share a resource between a Direct3D 9 device and a Direct3D 11 device the texture must have been created using  the <em>pSharedHandle</em> argument of <strong>CreateTexture</strong>.   The shared Direct3D 9 handle is then passed to OpenSharedResource in the <em>hResource</em> argument.</p><p>The following code illustrates the method calls involved.</p><pre> sharedHandle = <c>null</c>; // must be set to <c>null</c> to create, can use a valid handle here to open in D3D9 
        /// pDevice9-&gt;CreateTexture(..., pTex2D_9, &amp;sharedHandle); 
        /// ... 
        /// pDevice11-&gt;OpenSharedResource(sharedHandle, __uuidof(<see cref = "SharpDX.Direct3D11.Resource"/>), (void**)(&amp;tempResource11)); 
        /// tempResource11-&gt;QueryInterface(__uuidof(<see cref = "SharpDX.Direct3D11.Texture2D"/>), (void**)(&amp;pTex2D_11)); 
        /// tempResource11-&gt;Release(); 
        /// // now use pTex2D_11 with pDevice11    </pre><p>Textures being shared from D3D9 to D3D11 have the following restrictions.</p><ul> <li>Textures must be 2D</li> <li>Only 1 mip level is allowed</li> <li>Texture must have default usage</li> <li>Texture must be write only</li> <li>MSAA textures are not allowed</li> <li>Bind flags must have SHADER_RESOURCE and RENDER_TARGET set</li> <li>Only R10G10B10A2_UNORM, R16G16B16A16_FLOAT and R8G8B8A8_UNORM formats are allowed</li> </ul><p>If a shared texture is updated on one device <strong>ID3D11DeviceContext::Flush</strong> must be called on that device.</p>
        /// </remarks>
        /// <doc-id>ff476531</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::OpenSharedResource([In] void* hResource,[In] const GUID&amp; ReturnedInterface,[Out, Optional] void** ppResource)</unmanaged>
        /// <unmanaged-short>ID3D11Device::OpenSharedResource</unmanaged-short>
        internal unsafe void OpenSharedResource(System.IntPtr hResource, System.Guid returnedInterface, out System.IntPtr resourceOut)
        {
            SharpDX.Result __result__;
            fixed (void *resourceOut_ = &resourceOut)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)hResource, &returnedInterface, resourceOut_, (*(void ***)this._nativePointer)[28]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get the support of a given format on the installed video device.</p>
        /// </summary>
        /// <param name = "format"><dd>  <p>A <strong><see cref = "SharpDX.DXGI.Format"/></strong> enumeration that describes a format for which to check for support.</p> </dd></param>
        /// <returns><dd>  <p>A bitfield of <strong><see cref = "SharpDX.Direct3D11.FormatSupport"/></strong> enumeration values describing how the specified format is supported on the installed device.  The values are ORed together.</p> </dd></returns>
        /// <doc-id>ff476498</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CheckFormatSupport([In] DXGI_FORMAT Format,[Out] unsigned int* pFormatSupport)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CheckFormatSupport</unmanaged-short>
        public unsafe SharpDX.Direct3D11.FormatSupport CheckFormatSupport(SharpDX.DXGI.Format format)
        {
            SharpDX.Direct3D11.FormatSupport formatSupportRef;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)format), &formatSupportRef, (*(void ***)this._nativePointer)[29]);
            return formatSupportRef;
        }

        /// <summary>
        /// <p>Get the number of quality levels available during multisampling.</p>
        /// </summary>
        /// <param name = "format"><dd>  <p>The texture format. See <strong><see cref = "SharpDX.DXGI.Format"/></strong>.</p> </dd></param>
        /// <param name = "sampleCount"><dd>  <p>The number of samples during multisampling.</p> </dd></param>
        /// <returns><dd>  <p>Number of quality levels supported by the adapter. See remarks.</p> </dd></returns>
        /// <remarks>
        /// <p>When multisampling a texture, the number of quality levels available for an adapter is dependent on the texture format used and the number of  samples requested. The maximum number of quality levels is defined by <see cref = "MultisampleCountMaximum"/> in D3D11.h. If this method returns 0, the format  and sample count combination is not supported for the installed adapter.</p><p>Furthermore, the definition of a quality level is up to each hardware vendor to define, however no facility is provided by Direct3D to help discover  this information.</p><p>Note that FEATURE_LEVEL_10_1 devices are required to support 4x MSAA for all render targets except R32G32B32A32 and R32G32B32. FEATURE_LEVEL_11_0 devices are required to support 4x MSAA for all render target formats, and 8x MSAA for all render target formats  except R32G32B32A32 formats.</p>
        /// </remarks>
        /// <doc-id>ff476499</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CheckMultisampleQualityLevels([In] DXGI_FORMAT Format,[In] unsigned int SampleCount,[Out] unsigned int* pNumQualityLevels)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CheckMultisampleQualityLevels</unmanaged-short>
        public unsafe System.Int32 CheckMultisampleQualityLevels(SharpDX.DXGI.Format format, System.Int32 sampleCount)
        {
            System.Int32 numQualityLevelsRef;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)format), sampleCount, &numQualityLevelsRef, (*(void ***)this._nativePointer)[30]);
            return numQualityLevelsRef;
        }

        /// <summary>
        /// <p>Get a counter's information.</p>
        /// </summary>
        /// <doc-id>ff476496</doc-id>
        /// <unmanaged>void ID3D11Device::CheckCounterInfo([Out] D3D11_COUNTER_INFO* pCounterInfo)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CheckCounterInfo</unmanaged-short>
        public unsafe SharpDX.Direct3D11.CounterCapabilities GetCounterCapabilities()
        {
            SharpDX.Direct3D11.CounterCapabilities counterInfoRef;
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, &counterInfoRef, (*(void ***)this._nativePointer)[31]);
            return counterInfoRef;
        }

        /// <summary>
        /// <p>Get the type, name, units of measure, and a description of an existing counter.</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p> Pointer to a counter description (see <strong><see cref = "SharpDX.Direct3D11.CounterDescription"/></strong>). Specifies which counter information is to be retrieved about. </p> </dd></param>
        /// <param name = "typeRef"><dd>  <p> Pointer to the data type of a counter (see <strong><see cref = "SharpDX.Direct3D11.CounterType"/></strong>). Specifies the data type of the counter being retrieved. </p> </dd></param>
        /// <param name = "activeCountersRef"><dd>  <p>Pointer to the number of hardware counters that are needed for this counter type to be created. All instances of the same counter type use the same hardware counters.</p> </dd></param>
        /// <param name = "szName"><dd>  <p> String to be filled with a brief name for the counter. May be <strong><c>null</c></strong> if the application is not interested in the name of the counter. </p> </dd></param>
        /// <param name = "nameLengthRef"><dd>  <p> Length of the string returned to szName. Can be <strong><c>null</c></strong>. </p> </dd></param>
        /// <param name = "szUnits"><dd>  <p> Name of the units a counter measures, provided the memory the reference points to has enough room to hold the string. Can be <strong><c>null</c></strong>. The returned string will always be in English. </p> </dd></param>
        /// <param name = "unitsLengthRef"><dd>  <p> Length of the string returned to szUnits. Can be <strong><c>null</c></strong>. </p> </dd></param>
        /// <param name = "szDescription"><dd>  <p> A description of the counter, provided the memory the reference points to has enough room to hold the string. Can be <strong><c>null</c></strong>. The returned string will always be in English. </p> </dd></param>
        /// <param name = "descriptionLengthRef"><dd>  <p> Length of the string returned to szDescription. Can be <strong><c>null</c></strong>. </p> </dd></param>
        /// <returns><p> This method returns one of the following Direct3D 11 Return Codes. </p></returns>
        /// <remarks>
        /// <p> Length parameters can be <strong><c>null</c></strong>, which indicates the application is not interested in the length nor the corresponding string value. When a length parameter is non-<strong><c>null</c></strong> and the corresponding string is <strong><c>null</c></strong>, the input value of the length parameter is ignored, and the length of the corresponding string (including terminating <strong><c>null</c></strong>) will be returned through the length parameter. When length and the corresponding parameter are both non-<strong><c>null</c></strong>, the input value of length is checked to ensure there is enough room, and then the length of the string (including terminating <strong><c>null</c></strong> character) is passed out through the length parameter. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476495</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CheckCounter([In] const D3D11_COUNTER_DESC* pDesc,[Out] D3D11_COUNTER_TYPE* pType,[Out] unsigned int* pActiveCounters,[Out, Buffer, Optional] char* szName,[InOut, Optional] unsigned int* pNameLength,[Out, Buffer, Optional] char* szUnits,[InOut, Optional] unsigned int* pUnitsLength,[Out, Buffer, Optional] char* szDescription,[InOut, Optional] unsigned int* pDescriptionLength)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CheckCounter</unmanaged-short>
        internal unsafe void CheckCounter(SharpDX.Direct3D11.CounterDescription descRef, out SharpDX.Direct3D11.CounterType typeRef, out System.Int32 activeCountersRef, System.IntPtr szName, System.IntPtr nameLengthRef, System.IntPtr szUnits, System.IntPtr unitsLengthRef, System.IntPtr szDescription, System.IntPtr descriptionLengthRef)
        {
            SharpDX.Result __result__;
            fixed (void *activeCountersRef_ = &activeCountersRef)
                fixed (void *typeRef_ = &typeRef)
                    __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &descRef, typeRef_, activeCountersRef_, (void *)szName, (void *)nameLengthRef, (void *)szUnits, (void *)unitsLengthRef, (void *)szDescription, (void *)descriptionLengthRef, (*(void ***)this._nativePointer)[32]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets information about the features that are supported by the current graphics driver.</p>
        /// </summary>
        /// <param name = "feature"><dd>  <p>A member of the <strong><see cref = "SharpDX.Direct3D11.Feature"/></strong> enumerated type that describes which feature to query for support.</p> </dd></param>
        /// <param name = "featureSupportDataRef"><dd>  <p>Upon completion of the method, the passed structure is filled with data that describes the feature support.</p> </dd></param>
        /// <param name = "featureSupportDataSize"><dd>  <p>The size of the structure passed to the <em>pFeatureSupportData</em> parameter.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns E_INVALIDARG if an unsupported data type is passed to the <em>pFeatureSupportData</em> parameter  or a size mismatch is detected for the <em>FeatureSupportDataSize</em> parameter.</p></returns>
        /// <remarks>
        /// <p>To query for multi-threading support, pass the <strong>D3D11_FEATURE_THREADING</strong> value to the <em>Feature</em> parameter, pass  the <strong><see cref = "SharpDX.Direct3D11.FeatureDataThreading"/></strong> structure to the  <em>pFeatureSupportData</em> parameter, and pass the size of  the <strong><see cref = "SharpDX.Direct3D11.FeatureDataThreading"/></strong> structure to the <em>FeatureSupportDataSize</em> parameter.</p><p>Calling CheckFeatureSupport with <em>Feature</em> set to D3D11_FEATURE_FORMAT_SUPPORT causes the method to return the same information that would be returned  by <strong>ID3D11Device::CheckFormatSupport</strong>.</p>
        /// </remarks>
        /// <doc-id>ff476497</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::CheckFeatureSupport([In] D3D11_FEATURE Feature,[Out, Buffer] void* pFeatureSupportData,[In] unsigned int FeatureSupportDataSize)</unmanaged>
        /// <unmanaged-short>ID3D11Device::CheckFeatureSupport</unmanaged-short>
        internal unsafe SharpDX.Result CheckFeatureSupport(SharpDX.Direct3D11.Feature feature, System.IntPtr featureSupportDataRef, System.Int32 featureSupportDataSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)feature), (void *)featureSupportDataRef, featureSupportDataSize, (*(void ***)this._nativePointer)[33]);
            return __result__;
        }

        /// <summary>
        /// <p>Get application-defined data from a device.</p>
        /// </summary>
        /// <param name = "guid"><dd>  <p>Guid associated with the data.</p> </dd></param>
        /// <param name = "dataSizeRef"><dd>  <p>A reference to a variable that on input contains the size, in bytes, of the buffer that <em>pData</em> points to, and on output contains the size, in bytes, of the amount of data that <strong>GetPrivateData</strong> retrieved.</p> </dd></param>
        /// <param name = "dataRef"><dd>  <p>A reference to a buffer that <strong>GetPrivateData</strong> fills with data from the device if <em>pDataSize</em> points to a value that specifies a buffer large enough to hold the data.</p> </dd></param>
        /// <returns><p>This method returns one of the codes described in the topic Direct3D 11 Return Codes.</p></returns>
        /// <doc-id>ff476530</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::GetPrivateData([In] const GUID&amp; guid,[InOut] unsigned int* pDataSize,[Out, Buffer, Optional] void* pData)</unmanaged>
        /// <unmanaged-short>ID3D11Device::GetPrivateData</unmanaged-short>
        public unsafe SharpDX.Result GetPrivateData(System.Guid guid, ref System.Int32 dataSizeRef, System.IntPtr dataRef)
        {
            SharpDX.Result __result__;
            fixed (void *dataSizeRef_ = &dataSizeRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &guid, dataSizeRef_, (void *)dataRef, (*(void ***)this._nativePointer)[34]);
            return __result__;
        }

        /// <summary>
        /// <p>Set data to a device and associate that data with a guid.</p>
        /// </summary>
        /// <param name = "guid"><dd>  <p>Guid associated with the data.</p> </dd></param>
        /// <param name = "dataSize"><dd>  <p>Size of the data.</p> </dd></param>
        /// <param name = "dataRef"><dd>  <p>Pointer to the data to be stored with this device. If pData is <strong><c>null</c></strong>, DataSize must also be 0, and any data previously associated with the guid will be destroyed.</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>The data stored in the device with this method can be retrieved with <strong>ID3D11Device::GetPrivateData</strong>.</p><p>The data and guid set with this method will typically be application-defined.</p><p>The debug layer reports memory leaks by outputting a list of object interface references along with their friendly names. The default friendly name is "&lt;unnamed&gt;". You can set the friendly name so that you can determine if the corresponding object interface reference caused the leak. To set the friendly name, use the <strong>SetPrivateData</strong> method and the <strong><see cref = "DebugObjectName"/></strong> <see cref = "System.Guid"/> that is in D3Dcommon.h. For example, to give pContext a friendly name of <em>My name</em>, use the following code:</p><pre> static const char c_szName[] = "My name";
        /// hr = pContext-&gt;SetPrivateData( <see cref = "DebugObjectName"/>, sizeof( c_szName ) - 1, c_szName );
        /// </pre>
        /// </remarks>
        /// <doc-id>ff476533</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::SetPrivateData([In] const GUID&amp; guid,[In] unsigned int DataSize,[In, Buffer, Optional] const void* pData)</unmanaged>
        /// <unmanaged-short>ID3D11Device::SetPrivateData</unmanaged-short>
        public unsafe void SetPrivateData(System.Guid guid, System.Int32 dataSize, System.IntPtr dataRef)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &guid, dataSize, (void *)dataRef, (*(void ***)this._nativePointer)[35]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Associate an <see cref = "SharpDX.IUnknown"/>-derived interface with this device child and associate that interface with an application-defined guid.</p>
        /// </summary>
        /// <param name = "guid"><dd>  <p>Guid associated with the interface.</p> </dd></param>
        /// <param name = "dataRef"><dd>  <p>Pointer to an <see cref = "SharpDX.IUnknown"/>-derived interface to be associated with the device child.</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <doc-id>ff476534</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::SetPrivateDataInterface([In] const GUID&amp; guid,[In, Optional] const IUnknown* pData)</unmanaged>
        /// <unmanaged-short>ID3D11Device::SetPrivateDataInterface</unmanaged-short>
        public unsafe void SetPrivateDataInterface(System.Guid guid, SharpDX.IUnknown dataRef)
        {
            System.IntPtr dataRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            dataRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(dataRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &guid, (void *)dataRef_, (*(void ***)this._nativePointer)[36]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the feature level of the hardware device.</p>
        /// </summary>
        /// <returns><p>A member of the <strong><see cref = "SharpDX.Direct3D.FeatureLevel"/></strong> enumerated type that describes the feature level of the hardware device.</p></returns>
        /// <remarks>
        /// <p> Feature levels determine the capabilities of your device.</p>
        /// </remarks>
        /// <doc-id>ff476528</doc-id>
        /// <unmanaged>D3D_FEATURE_LEVEL ID3D11Device::GetFeatureLevel()</unmanaged>
        /// <unmanaged-short>ID3D11Device::GetFeatureLevel</unmanaged-short>
        internal unsafe SharpDX.Direct3D.FeatureLevel GetFeatureLevel()
        {
            SharpDX.Direct3D.FeatureLevel __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallSharpDXDirect3DFeatureLevel(this._nativePointer, (*(void ***)this._nativePointer)[37]);
            return __result__;
        }

        /// <summary>
        /// <p>Get the flags used during the call to create the device with <strong>D3D11CreateDevice</strong>.</p>
        /// </summary>
        /// <returns><p>A bitfield containing the flags used to create the device. See <strong><see cref = "SharpDX.Direct3D11.DeviceCreationFlags"/></strong>.</p></returns>
        /// <doc-id>ff476525</doc-id>
        /// <unmanaged>unsigned int ID3D11Device::GetCreationFlags()</unmanaged>
        /// <unmanaged-short>ID3D11Device::GetCreationFlags</unmanaged-short>
        internal unsafe SharpDX.Direct3D11.DeviceCreationFlags GetCreationFlags()
        {
            SharpDX.Direct3D11.DeviceCreationFlags __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallSharpDXDirect3D11DeviceCreationFlags(this._nativePointer, (*(void ***)this._nativePointer)[38]);
            return __result__;
        }

        /// <summary>
        /// <p>Get the reason why the device was removed.</p>
        /// </summary>
        /// <returns><p>Possible return values include:  </p><ul> <li><see cref = "DeviceHung"/></li> <li><see cref = "DeviceRemoved"/></li> <li><see cref = "DeviceReset"/></li> <li><see cref = "DriverInternalError"/></li> <li><see cref = "InvalidCall"/></li> <li><see cref = "SharpDX.Result.Ok"/></li> </ul><p>For more detail on these return codes, see DXGI_ERROR.</p></returns>
        /// <doc-id>ff476526</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::GetDeviceRemovedReason()</unmanaged>
        /// <unmanaged-short>ID3D11Device::GetDeviceRemovedReason</unmanaged-short>
        internal unsafe SharpDX.Result GetDeviceRemovedReason()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[39]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets an immediate context, which can play back command lists.</p>
        /// </summary>
        /// <param name = "immediateContextOut"><dd>  <p>Upon completion of the method, the passed reference to an <strong><see cref = "SharpDX.Direct3D11.DeviceContext"/></strong> interface reference is initialized.</p> </dd></param>
        /// <remarks>
        /// <p>The <strong>GetImmediateContext</strong> method returns an <strong><see cref = "SharpDX.Direct3D11.DeviceContext"/></strong> object that represents an immediate context which is used to perform rendering that you want immediately submitted to a device. For most applications, an immediate context is the primary object that is used to draw your scene.</p><p>The <strong>GetImmediateContext</strong> method increments the reference count of the immediate context by one. Therefore, you must call <strong>Release</strong> on the returned interface reference when you are done with it to avoid a memory leak. </p>
        /// </remarks>
        /// <doc-id>ff476529</doc-id>
        /// <unmanaged>void ID3D11Device::GetImmediateContext([Out] ID3D11DeviceContext** ppImmediateContext)</unmanaged>
        /// <unmanaged-short>ID3D11Device::GetImmediateContext</unmanaged-short>
        internal unsafe void GetImmediateContext(out SharpDX.Direct3D11.DeviceContext immediateContextOut)
        {
            System.IntPtr immediateContextOut_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, &immediateContextOut_, (*(void ***)this._nativePointer)[40]);
            if (immediateContextOut_ != System.IntPtr.Zero)
                immediateContextOut = new SharpDX.Direct3D11.DeviceContext(immediateContextOut_);
            else
                immediateContextOut = null;
        }

        /// <summary>
        /// <p>Get the exception-mode flags.</p>
        /// </summary>
        /// <param name = "raiseFlags"><dd>  <p>A value that contains one or more exception flags; each flag specifies a condition which will cause an exception to be raised. The flags are listed in <strong>D3D11_RAISE_FLAG</strong>. A default value of 0 means there are no flags.</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>Set an exception-mode flag to elevate an error condition to a non-continuable exception. </p><p>Whenever an error occurs, a Direct3D device enters the DEVICEREMOVED state and if the appropriate exception flag has been set, an exception is raised. A raised exception is designed to terminate an application. Before termination, the last chance an application has to persist data is by using an UnhandledExceptionFilter (see Structured Exception Handling). In general, UnhandledExceptionFilters are leveraged to try to persist data when an application is crashing (to disk, for example). Any code that executes during an UnhandledExceptionFilter is not guaranteed to reliably execute (due to possible process corruption). Any data that the UnhandledExceptionFilter manages to persist, before the UnhandledExceptionFilter crashes again, should be treated as suspect, and therefore inspected by a new, non-corrupted process to see if it is usable.</p>
        /// </remarks>
        /// <doc-id>ff476532</doc-id>
        /// <unmanaged>HRESULT ID3D11Device::SetExceptionMode([In] unsigned int RaiseFlags)</unmanaged>
        /// <unmanaged-short>ID3D11Device::SetExceptionMode</unmanaged-short>
        internal unsafe void SetExceptionMode(System.Int32 raiseFlags)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, raiseFlags, (*(void ***)this._nativePointer)[41]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get the exception-mode flags.</p>
        /// </summary>
        /// <returns><p>A value that contains one or more exception flags; each flag specifies a condition which will cause an exception to be raised. The flags are listed in <strong>D3D11_RAISE_FLAG</strong>. A default value of 0 means there are no flags.</p></returns>
        /// <remarks>
        /// <p>An exception-mode flag is used to elevate an error condition to a non-continuable exception. </p>
        /// </remarks>
        /// <doc-id>ff476527</doc-id>
        /// <unmanaged>unsigned int ID3D11Device::GetExceptionMode()</unmanaged>
        /// <unmanaged-short>ID3D11Device::GetExceptionMode</unmanaged-short>
        internal unsafe System.Int32 GetExceptionMode()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[42]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("a04bfb29-08ef-43d6-a49c-a9bdbdcbe686")]
    public partial class Device1 : SharpDX.Direct3D11.Device
    {
        public Device1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device1(nativePtr);
        /// <summary>
        /// <p>Gets an immediate context, which can play back command lists.</p>
        /// </summary>
        /// <remarks>
        /// <p><strong>GetImmediateContext1</strong> returns an <strong><see cref = "SharpDX.Direct3D11.DeviceContext1"/></strong> object that represents an immediate context. You can use this immediate context to perform rendering that you want immediately submitted to a device. For most applications, an immediate context is the primary object that is used to draw your scene.</p><p><strong>GetImmediateContext1</strong> increments the reference count of the immediate context by one. So, call <strong>Release</strong> on the returned interface reference when you are done with it to avoid a memory leak. </p>
        /// </remarks>
        /// <doc-id>hh404589</doc-id>
        /// <unmanaged>GetImmediateContext1</unmanaged>
        /// <unmanaged-short>GetImmediateContext1</unmanaged-short>
        public SharpDX.Direct3D11.DeviceContext1 ImmediateContext1
        {
            get
            {
                if (this.ImmediateContext1__ == null)
                    GetImmediateContext1(out ImmediateContext1__);
                return this.ImmediateContext1__;
            }
        }

        protected internal SharpDX.Direct3D11.DeviceContext1 ImmediateContext1__;
        /// <summary>
        /// <p>Gets an immediate context, which can play back command lists.</p>
        /// </summary>
        /// <param name = "immediateContextOut"><dd> <p>Upon completion of the method, the passed reference to an <strong><see cref = "SharpDX.Direct3D11.DeviceContext1"/></strong> interface reference is initialized.</p> </dd></param>
        /// <remarks>
        /// <p><strong>GetImmediateContext1</strong> returns an <strong><see cref = "SharpDX.Direct3D11.DeviceContext1"/></strong> object that represents an immediate context. You can use this immediate context to perform rendering that you want immediately submitted to a device. For most applications, an immediate context is the primary object that is used to draw your scene.</p><p><strong>GetImmediateContext1</strong> increments the reference count of the immediate context by one. So, call <strong>Release</strong> on the returned interface reference when you are done with it to avoid a memory leak. </p>
        /// </remarks>
        /// <doc-id>hh404589</doc-id>
        /// <unmanaged>void ID3D11Device1::GetImmediateContext1([Out] ID3D11DeviceContext1** ppImmediateContext)</unmanaged>
        /// <unmanaged-short>ID3D11Device1::GetImmediateContext1</unmanaged-short>
        internal unsafe void GetImmediateContext1(out SharpDX.Direct3D11.DeviceContext1 immediateContextOut)
        {
            System.IntPtr immediateContextOut_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, &immediateContextOut_, (*(void ***)this._nativePointer)[43]);
            if (immediateContextOut_ != System.IntPtr.Zero)
                immediateContextOut = new SharpDX.Direct3D11.DeviceContext1(immediateContextOut_);
            else
                immediateContextOut = null;
        }

        /// <summary>
        /// <p> Creates a deferred context, which can record command lists. </p>
        /// </summary>
        /// <param name = "contextFlags"><dd> <p> Reserved for future use. Pass 0. </p> </dd></param>
        /// <param name = "deferredContextOut"><dd> <p> Upon completion of the method, the passed reference to an <strong><see cref = "SharpDX.Direct3D11.DeviceContext1"/></strong> interface reference is initialized. </p> </dd></param>
        /// <returns><p> Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns one of the following: </p><ul> <li> Returns <strong><see cref = "DeviceRemoved"/></strong> if the graphics adapter has been physically removed from the computer or a driver upgrade for the graphics adapter has occurred. If this error occurs, you should destroy and re-create the device. </li> <li> Returns <strong><see cref = "InvalidCall"/></strong> if the <strong>CreateDeferredContext1</strong> method cannot be called from the current context. For example, if the device was created with the <strong>D3D11_CREATE_DEVICE_SINGLETHREADED</strong> value,  <strong>CreateDeferredContext1</strong> returns <strong><see cref = "InvalidCall"/></strong>. </li> <li> Returns <strong>E_INVALIDARG</strong> if the <em>ContextFlags</em> parameter is invalid. </li> <li> Returns <strong>E_OUTOFMEMORY</strong> if the application has exhausted available memory. </li> </ul></returns>
        /// <remarks>
        /// <p> A deferred context is a thread-safe context that you can use to record graphics commands on a thread other than the main rendering thread. By using a deferred context, you can record graphics commands into a command list that is encapsulated by the <strong><see cref = "SharpDX.Direct3D11.CommandList"/></strong> interface. After you record all scene items, you can then submit them to the main render thread for final rendering. In this manner, you can perform rendering tasks concurrently across multiple threads and potentially improve performance in multi-core CPU scenarios. </p><p> You can create multiple deferred contexts. </p><strong>Note</strong>?? If you use the <strong>D3D11_CREATE_DEVICE_SINGLETHREADED</strong> value to create the device that is represented by <strong><see cref = "SharpDX.Direct3D11.Device1"/></strong>, the <strong>CreateDeferredContext1</strong> method will fail, and you will not be able to create a deferred context.?<p> For more information about deferred contexts, see Immediate and Deferred Rendering. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>hh404580</doc-id>
        /// <unmanaged>HRESULT ID3D11Device1::CreateDeferredContext1([In] unsigned int ContextFlags,[Out, Fast] ID3D11DeviceContext1** ppDeferredContext)</unmanaged>
        /// <unmanaged-short>ID3D11Device1::CreateDeferredContext1</unmanaged-short>
        internal unsafe void CreateDeferredContext1(System.Int32 contextFlags, SharpDX.Direct3D11.DeviceContext1 deferredContextOut)
        {
            System.IntPtr deferredContextOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, contextFlags, &deferredContextOut_, (*(void ***)this._nativePointer)[44]);
            (deferredContextOut).NativePointer = deferredContextOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a blend-state object that encapsulates blend state for the output-merger stage and allows the configuration of logic operations.</p>
        /// </summary>
        /// <param name = "blendStateDescRef">No documentation.</param>
        /// <param name = "blendStateOut">No documentation.</param>
        /// <returns><p>This method returns E_OUTOFMEMORY if there is insufficient memory to create the blend-state object.   See Direct3D 11 Return Codes for other possible return values.</p></returns>
        /// <remarks>
        /// <p>The logical operations (those that enable bitwise logical operations between pixel shader output and render target contents, refer to <strong><see cref = "SharpDX.Direct3D11.RenderTargetBlendDescription1"/></strong> ) are only available on certain feature levels; call <strong>CheckFeatureSupport</strong> with D3D11_FEATURE_D3D11_OPTIONS set, to ensure support by checking the boolean field  <em>OutputMergerLogicOp</em> of <strong><see cref = "SharpDX.Direct3D11.FeatureDataD3D11Options"/></strong>.</p><p>An app can create up to 4096 unique blend-state objects. For each object created, the runtime checks to see if a previous object  has the same state. If such a previous object exists, the runtime will return a reference to previous instance instead of creating a duplicate object.</p>
        /// </remarks>
        /// <doc-id>hh404577</doc-id>
        /// <unmanaged>HRESULT ID3D11Device1::CreateBlendState1([In] const D3D11_BLEND_DESC1* pBlendStateDesc,[Out, Fast] ID3D11BlendState1** ppBlendState)</unmanaged>
        /// <unmanaged-short>ID3D11Device1::CreateBlendState1</unmanaged-short>
        internal unsafe void CreateBlendState1(ref SharpDX.Direct3D11.BlendStateDescription1 blendStateDescRef, SharpDX.Direct3D11.BlendState1 blendStateOut)
        {
            SharpDX.Direct3D11.BlendStateDescription1.__Native blendStateDescRef_ = default (SharpDX.Direct3D11.BlendStateDescription1.__Native);
            System.IntPtr blendStateOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            blendStateDescRef.__MarshalTo(ref blendStateDescRef_);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &blendStateDescRef_, &blendStateOut_, (*(void ***)this._nativePointer)[45]);
            (blendStateOut).NativePointer = blendStateOut_;
            blendStateDescRef.__MarshalFree(ref blendStateDescRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a rasterizer state object that informs the rasterizer stage how to behave and forces the sample count while UAV rendering or rasterizing.</p>
        /// </summary>
        /// <param name = "rasterizerDescRef">No documentation.</param>
        /// <param name = "rasterizerStateOut">No documentation.</param>
        /// <returns><p>This method returns E_OUTOFMEMORY if there is insufficient memory to create the rasterizer state object.  See Direct3D 11 Return Codes for other possible return values.</p></returns>
        /// <remarks>
        /// <p>An app can create up to 4096 unique rasterizer state objects. For each object created, the runtime checks to see if a previous object  has the same state. If such a previous object exists, the runtime will return a reference to previous instance instead of creating a duplicate object.</p>
        /// </remarks>
        /// <doc-id>hh404586</doc-id>
        /// <unmanaged>HRESULT ID3D11Device1::CreateRasterizerState1([In] const D3D11_RASTERIZER_DESC1* pRasterizerDesc,[Out, Fast] ID3D11RasterizerState1** ppRasterizerState)</unmanaged>
        /// <unmanaged-short>ID3D11Device1::CreateRasterizerState1</unmanaged-short>
        internal unsafe void CreateRasterizerState1(ref SharpDX.Direct3D11.RasterizerStateDescription1 rasterizerDescRef, SharpDX.Direct3D11.RasterizerState1 rasterizerStateOut)
        {
            System.IntPtr rasterizerStateOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *rasterizerDescRef_ = &rasterizerDescRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, rasterizerDescRef_, &rasterizerStateOut_, (*(void ***)this._nativePointer)[46]);
            (rasterizerStateOut).NativePointer = rasterizerStateOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a context state object that holds all Microsoft Direct3D state and some Direct3D behavior. </p>
        /// </summary>
        /// <param name = "flags"><dd> <p> A combination of  <strong><see cref = "SharpDX.Direct3D11.CreateDeviceContextStateFlags"/></strong> values that are combined by using a bitwise <strong>OR</strong> operation.  The resulting value specifies how to create the context state object.  The  <strong>D3D11_1_CREATE_DEVICE_CONTEXT_STATE_SINGLETHREADED</strong> flag is currently the only defined flag.  If the original device was created with  <strong>D3D11_CREATE_DEVICE_SINGLETHREADED</strong>,  you must create all context state objects from that device with the  <strong>D3D11_1_CREATE_DEVICE_CONTEXT_STATE_SINGLETHREADED</strong> flag. </p> <p></p> <p>If you set the single-threaded flag for both the context state object and the device, you guarantee that you will call the whole set of context methods and device methods only from one thread.  You therefore do not need to use critical sections to synchronize access to the device context, and the runtime can avoid working with those processor-intensive critical sections.</p> </dd></param>
        /// <param name = "featureLevelsRef"><dd> <p> A reference to an array of <strong><see cref = "SharpDX.Direct3D.FeatureLevel"/></strong> values. The array can contain elements from the following list and determines the order of feature levels for which creation is attempted. Unlike <strong>D3D11CreateDevice</strong>, you can't set <em>pFeatureLevels</em> to <strong><c>null</c></strong> because  there is no default feature level array. </p>  <pre>{ D3D_FEATURE_LEVEL_11_1, D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_10_0, D3D_FEATURE_LEVEL_9_3, D3D_FEATURE_LEVEL_9_2, D3D_FEATURE_LEVEL_9_1,}; </pre>  </dd></param>
        /// <param name = "featureLevels"><dd> <p> The number of elements in <em>pFeatureLevels</em>. Unlike <strong>D3D11CreateDevice</strong>, you must set <em>FeatureLevels</em> to greater than 0 because you can't set <em>pFeatureLevels</em> to <strong><c>null</c></strong>. </p> </dd></param>
        /// <param name = "sDKVersion"><dd> <p> The SDK version. You must set this parameter to <strong><see cref = "SdkVersion"/></strong>. </p> </dd></param>
        /// <param name = "emulatedInterface"><dd> <p> The globally unique identifier (<see cref = "System.Guid"/>) for the emulated interface. This value specifies the behavior of the device when the context state object is active. Valid values are  obtained by using the <strong>__uuidof</strong> operator on the <strong>ID3D10Device</strong>, <strong>ID3D10Device1</strong>, <strong><see cref = "SharpDX.Direct3D11.Device"/></strong>, and <strong><see cref = "SharpDX.Direct3D11.Device1"/></strong> interfaces. See Remarks. </p> </dd></param>
        /// <param name = "chosenFeatureLevelRef"><dd> <p> A reference to a variable that receives a <strong><see cref = "SharpDX.Direct3D.FeatureLevel"/></strong> value from the <em>pFeatureLevels</em> array. This is the first array value with which <strong>CreateDeviceContextState</strong> succeeded in creating the context state object. If the call to <strong>CreateDeviceContextState</strong> fails, the variable pointed to by <em>pChosenFeatureLevel</em> is set to zero. </p> </dd></param>
        /// <param name = "contextStateOut"><dd> <p> The address of a reference to an <strong><see cref = "SharpDX.Direct3D11.DeviceContextState"/></strong> object that represents the state of a Direct3D device. </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 11 Return Codes. </p></returns>
        /// <remarks>
        /// <p> The  <strong>REFIID</strong> value of the emulated interface is a <see cref = "System.Guid"/> obtained by use of the <strong>__uuidof</strong> operator. For example, <code>__uuidof(<see cref = "SharpDX.Direct3D11.Device"/>)</code> gets the <see cref = "System.Guid"/> of the interface to a Microsoft Direct3D?11 device. </p><p> Call the <strong>ID3D11DeviceContext1::SwapDeviceContextState</strong> method to activate the context state object. When the context state object is active, the device behaviors that are associated with both the context state object's feature level and its compatible interface are activated on the Direct3D device until the next call to <strong>SwapDeviceContextState</strong>. </p><p> When a context state object is active, the runtime disables certain methods on the device and context interfaces. For example, a context state object that is created with <code>__uuidof(<see cref = "SharpDX.Direct3D11.Device"/>)</code> will cause the runtime to turn off most of the Microsoft Direct3D?10 device interfaces, and a context state object that is created with <code>__uuidof(ID3D10Device1)</code> or <code>__uuidof(ID3D10Device)</code> will cause the runtime to turn off most of the <strong><see cref = "SharpDX.Direct3D11.DeviceContext"/></strong> methods. This behavior ensures that a user of either emulated interface cannot set device state that the other emulated interface is unable to express. This restriction helps guarantee that the <strong>ID3D10Device1</strong> emulated interface accurately reflects the full state of the pipeline and that the emulated interface will not operate contrary to its original interface definition. </p><p> For example, suppose the tessellation stage is made active through the <strong><see cref = "SharpDX.Direct3D11.DeviceContext"/></strong> interface when you create the device through <strong>D3D11CreateDevice</strong> or <strong>D3D11CreateDeviceAndSwapChain</strong>,  instead of through the Direct3D?10 equivalents. Because  the Direct3D?11 context is active, a Direct3D?10 interface is inactive when you first retrieve it via <strong>QueryInterface</strong>. This means that you cannot  immediately pass a Direct3D?10 interface that you retrieved from a Direct3D?11 device to a function. You must first call <strong>SwapDeviceContextState</strong> to activate a Direct3D?10-compatible context state object. </p><p> The following table shows the methods that are active and inactive for each emulated interface.</p><table> <tr><th> Emulated interface </th><th>Active device or immediate context  interfaces </th><th>Inactive device or immediate context  interfaces</th></tr> <tr><td> <p> <strong><see cref = "SharpDX.Direct3D11.Device"/></strong> or </p> <p> <strong><see cref = "SharpDX.Direct3D11.Device1"/></strong> </p> </td><td> <p> <strong><see cref = "SharpDX.Direct3D11.Device"/></strong> </p> <p> <strong><see cref = "SharpDX.DXGI.Device"/></strong> + </p> <p> <strong><see cref = "SharpDX.DXGI.Device1"/></strong> + </p> <p> <strong><see cref = "SharpDX.DXGI.Device2"/></strong> </p> <p> <strong><see cref = "SharpDX.Direct3D.DeviceMultithread"/></strong> </p> </td><td> <strong>ID3D10Device</strong> </td></tr> <tr><td> <p> <strong>ID3D10Device1</strong> or </p> <p> <strong>ID3D10Device</strong> </p> </td><td> <p> <strong>ID3D10Device</strong> </p> <p> <strong>ID3D10Device1</strong> </p> <p> <strong><see cref = "SharpDX.DXGI.Device"/></strong> + </p> <p> <strong><see cref = "SharpDX.DXGI.Device1"/></strong> </p> <p> <strong><see cref = "SharpDX.Direct3D.DeviceMultithread"/></strong> </p> </td><td> <p> <strong><see cref = "SharpDX.Direct3D11.Device"/></strong> </p> <p> <strong><see cref = "SharpDX.Direct3D11.DeviceContext"/></strong> (As published by the immediate context. The Direct3D?10 or Microsoft Direct3D?10.1 emulated interface has no effect on deferred contexts.) </p> </td></tr> </table><p>?</p><p> The following table shows the immediate context methods that the runtime disables when the indicated context state objects are active.</p><table> <tr><th> Methods of <strong><see cref = "SharpDX.Direct3D11.DeviceContext"/></strong> when <code>__uuidof(ID3D10Device1)</code> or <code>__uuidof(ID3D10Device)</code> is active </th><th> Methods of <strong>ID3D10Device</strong> when <code>__uuidof(<see cref = "SharpDX.Direct3D11.Device"/>)</code> is active </th></tr> <tr><td> <p> <strong>ClearDepthStencilView</strong> </p> </td><td> <p> <strong>ClearDepthStencilView</strong> </p> </td></tr> <tr><td> <p> <strong>ClearRenderTargetView</strong> </p> </td><td> <p> <strong>ClearRenderTargetView</strong> </p> </td></tr> <tr><td> <p> <strong>ClearState</strong> </p> </td><td> <p> <strong>ClearState</strong> </p> </td></tr> <tr><td> <p> <strong>ClearUnorderedAccessViewUint</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>ClearUnorderedAccessViewFloat</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>CopyResource</strong> </p> </td><td> <p> <strong>CopyResource</strong> </p> </td></tr> <tr><td> <p> <strong>CopyStructureCount</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>CopySubresourceRegion</strong> </p> </td><td> <p> <strong>CopySubresourceRegion</strong> </p> </td></tr> <tr><td> <p> <strong>CSGetConstantBuffers</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>CSGetSamplers</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>CSGetShader</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>CSGetShaderResources</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>CSGetUnorderedAccessViews</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>CSSetConstantBuffers</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>CSSetSamplers</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>CSSetShader</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>CSSetShaderResources</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>CSSetUnorderedAccessViews</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>Dispatch</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>DispatchIndirect</strong> </p> </td><td></td></tr> <tr><td></td><td> <p> <strong>CreateBlendState</strong> </p> </td></tr> <tr><td> <p> <strong>Draw</strong> </p> </td><td> <p> <strong>Draw</strong> </p> </td></tr> <tr><td> <p> <strong>DrawAuto</strong> </p> </td><td> <p> <strong>DrawAuto</strong> </p> </td></tr> <tr><td> <p> <strong>DrawIndexed</strong> </p> </td><td> <p> <strong>DrawIndexed</strong> </p> </td></tr> <tr><td> <p> <strong>DrawIndexedInstanced</strong> </p> </td><td> <p> <strong>DrawIndexedInstanced</strong> </p> </td></tr> <tr><td> <p> <strong>DrawIndexedInstancedIndirect</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>DrawInstanced</strong> </p> </td><td> <p> <strong>DrawInstanced</strong> </p> </td></tr> <tr><td> <p> <strong>DrawInstancedIndirect</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>DSGetConstantBuffers</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>DSGetSamplers</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>DSGetShader</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>DSGetShaderResources</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>DSSetConstantBuffers</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>DSSetSamplers</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>DSSetShader</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>DSSetShaderResources</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>ExecuteCommandList</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>FinishCommandList</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>Flush</strong> </p> </td><td> <p> <strong>Flush</strong> </p> </td></tr> <tr><td> <p> <strong>GenerateMips</strong> </p> </td><td> <p> <strong>GenerateMips</strong> </p> </td></tr> <tr><td> <p> <strong>GetPredication</strong> </p> </td><td> <p> <strong>GetPredication</strong> </p> </td></tr> <tr><td> <p> <strong>GetResourceMinLOD</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>GetType</strong> </p> </td><td></td></tr> <tr><td></td><td> <p> <strong>GetTextFilterSize</strong> </p> </td></tr> <tr><td> <p> <strong>GSGetConstantBuffers</strong> </p> </td><td> <p> <strong>GSGetConstantBuffers</strong> </p> </td></tr> <tr><td> <p> <strong>GSGetSamplers</strong> </p> </td><td> <p> <strong>GSGetSamplers</strong> </p> </td></tr> <tr><td> <p> <strong>GSGetShader</strong> </p> </td><td> <p> <strong>GSGetShader</strong> </p> </td></tr> <tr><td> <p> <strong>GSGetShaderResources</strong> </p> </td><td> <p> <strong>GSGetShaderResources</strong> </p> </td></tr> <tr><td> <p> <strong>GSSetConstantBuffers</strong> </p> </td><td> <p> <strong>GSSetConstantBuffers</strong> </p> </td></tr> <tr><td> <p> <strong>GSSetSamplers</strong> </p> </td><td> <p> <strong>GSSetSamplers</strong> </p> </td></tr> <tr><td> <p> <strong>GSSetShader</strong> </p> </td><td> <p> <strong>GSSetShader</strong> </p> </td></tr> <tr><td> <p> <strong>GSSetShaderResources</strong> </p> </td><td> <p> <strong>GSSetShaderResources</strong> </p> </td></tr> <tr><td> <p> <strong>HSGetConstantBuffers</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>HSGetSamplers</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>HSGetShader</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>HSGetShaderResources</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>HSSetConstantBuffers</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>HSSetSamplers</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>HSSetShader</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>HSSetShaderResources</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>IAGetIndexBuffer</strong> </p> </td><td> <p> <strong>IAGetIndexBuffer</strong> </p> </td></tr> <tr><td> <p> <strong>IAGetInputLayout</strong> </p> </td><td> <p> <strong>IAGetInputLayout</strong> </p> </td></tr> <tr><td> <p> <strong>IAGetPrimitiveTopology</strong> </p> </td><td> <p> <strong>IAGetPrimitiveTopology</strong> </p> </td></tr> <tr><td> <strong>IAGetVertexBuffers</strong> </td><td> <p> <strong>IAGetVertexBuffers</strong> </p> </td></tr> <tr><td> <strong>IASetIndexBuffer</strong> </td><td> <p> <strong>IASetIndexBuffer</strong> </p> </td></tr> <tr><td> <strong>IASetInputLayout</strong> </td><td> <p> <strong>IASetInputLayout</strong> </p> </td></tr> <tr><td> <strong>IASetPrimitiveTopology</strong> </td><td> <p> <strong>IASetPrimitiveTopology</strong> </p> </td></tr> <tr><td> <strong>IASetVertexBuffers</strong> </td><td> <p> <strong>IASetVertexBuffers</strong> </p> </td></tr> <tr><td> <p> <strong>OMGetBlendState</strong> </p> </td><td> <p> <strong>OMGetBlendState</strong> </p> </td></tr> <tr><td> <p> <strong>OMGetDepthStencilState</strong> </p> </td><td> <p> <strong>OMGetDepthStencilState</strong> </p> </td></tr> <tr><td> <p> <strong>OMGetRenderTargets</strong> </p> </td><td> <p> <strong>OMGetRenderTargets</strong> </p> </td></tr> <tr><td> <p> <strong>OMGetRenderTargetsAndUnorderedAccessViews</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>OMSetBlendState</strong> </p> </td><td> <p> <strong>OMSetBlendState</strong> </p> </td></tr> <tr><td> <p> <strong>OMSetDepthStencilState</strong> </p> </td><td> <p> <strong>OMSetDepthStencilState</strong> </p> </td></tr> <tr><td> <p> <strong>OMSetRenderTargets</strong> </p> </td><td> <p> <strong>OMSetRenderTargets</strong> </p> </td></tr> <tr><td> <p> <strong>OMSetRenderTargetsAndUnorderedAccessViews</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>PSGetConstantBuffers</strong> </p> </td><td> <p> <strong>PSGetConstantBuffers</strong> </p> </td></tr> <tr><td> <p> <strong>PSGetSamplers</strong> </p> </td><td> <p> <strong>PSGetSamplers</strong> </p> </td></tr> <tr><td> <p> <strong>PSGetShader</strong> </p> </td><td> <p> <strong>PSGetShader</strong> </p> </td></tr> <tr><td> <p> <strong>PSGetShaderResources</strong> </p> </td><td> <p> <strong>PSGetShaderResources</strong> </p> </td></tr> <tr><td> <p> <strong>PSSetConstantBuffers</strong> </p> </td><td> <p> <strong>PSSetConstantBuffers</strong> </p> </td></tr> <tr><td> <p> <strong>PSSetSamplers</strong> </p> </td><td> <p> <strong>PSSetSamplers</strong> </p> </td></tr> <tr><td> <p> <strong>PSSetShader</strong> </p> </td><td> <p> <strong>PSSetShader</strong> </p> </td></tr> <tr><td> <p> <strong>PSSetShaderResources</strong> </p> </td><td> <p> <strong>PSSetShaderResources</strong> </p> </td></tr> <tr><td> <p> <strong>ResolveSubresource</strong> </p> </td><td> <p> <strong>ResolveSubresource</strong> </p> </td></tr> <tr><td> <p> <strong>RSGetScissorRects</strong> </p> </td><td> <p> <strong>RSGetScissorRects</strong> </p> </td></tr> <tr><td> <p> <strong>RSGetState</strong> </p> </td><td> <p> <strong>RSGetState</strong> </p> </td></tr> <tr><td> <p> <strong>RSGetViewports</strong> </p> </td><td> <p> <strong>RSGetViewports</strong> </p> </td></tr> <tr><td> <p> <strong>RSSetScissorRects</strong> </p> </td><td> <p> <strong>RSSetScissorRects</strong> </p> </td></tr> <tr><td> <p> <strong>RSSetState</strong> </p> </td><td> <p> <strong>RSSetState</strong> </p> </td></tr> <tr><td> <p> <strong>RSSetViewports</strong> </p> </td><td> <p> <strong>RSSetViewports</strong> </p> </td></tr> <tr><td> <p> <strong>SetPredication</strong> </p> </td><td> <p> <strong>SetPredication</strong> </p> </td></tr> <tr><td> <p> <strong>SetResourceMinLOD</strong> </p> </td><td></td></tr> <tr><td></td><td> <p> <strong>SetTextFilterSize</strong> </p> </td></tr> <tr><td> <p> <strong>SOGetTargets</strong> </p> </td><td> <p> <strong>SOGetTargets</strong> </p> </td></tr> <tr><td> <p> <strong>SOSetTargets</strong> </p> </td><td> <p> <strong>SOSetTargets</strong> </p> </td></tr> <tr><td> <p> <strong>UpdateSubresource</strong> </p> </td><td> <p> <strong>UpdateSubresource</strong> </p> </td></tr> <tr><td> <p> <strong>VSGetConstantBuffers</strong> </p> </td><td> <p> <strong>VSGetConstantBuffers</strong> </p> </td></tr> <tr><td> <p> <strong>VSGetSamplers</strong> </p> </td><td> <p> <strong>VSGetSamplers</strong> </p> </td></tr> <tr><td> <p> <strong>VSGetShader</strong> </p> </td><td> <p> <strong>VSGetShader</strong> </p> </td></tr> <tr><td> <p> <strong>VSGetShaderResources</strong> </p> </td><td> <p> <strong>VSGetShaderResources</strong> </p> </td></tr> <tr><td> <p> <strong>VSSetConstantBuffers</strong> </p> </td><td> <p> <strong>VSSetConstantBuffers</strong> </p> </td></tr> <tr><td> <p> <strong>VSSetSamplers</strong> </p> </td><td> <p> <strong>VSSetSamplers</strong> </p> </td></tr> <tr><td> <p> <strong>VSSetShader</strong> </p> </td><td> <p> <strong>VSSetShader</strong> </p> </td></tr> <tr><td> <p> <strong>VSSetShaderResources</strong> </p> </td><td> <p> <strong>VSSetShaderResources</strong> </p> </td></tr> </table><p>?</p><p> The following table shows the immediate context methods that the runtime does not disable when the indicated context state objects are active.</p><table> <tr><th> Methods of <strong><see cref = "SharpDX.Direct3D11.DeviceContext"/></strong> when <code>__uuidof(ID3D10Device1)</code> or <code>__uuidof(ID3D10Device)</code> is active </th><th> Methods of <strong>ID3D10Device</strong> when <code>__uuidof(<see cref = "SharpDX.Direct3D11.Device"/>)</code> is active </th></tr> <tr><td> <p> <strong>Begin</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>End</strong> </p> </td><td></td></tr> <tr><td></td><td> <p> <strong>GetCreationFlags</strong> </p> </td></tr> <tr><td></td><td> <p> <strong>GetPrivateData</strong> </p> </td></tr> <tr><td> <p> <strong>GetContextFlags</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>GetData</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>Map</strong> </p> </td><td></td></tr> <tr><td> <p> <strong>Unmap</strong> </p> </td><td></td></tr> </table><p>?</p><p> The following table shows the <strong>ID3D10Device</strong> interface methods that the runtime does not disable because they are not immediate context methods.</p><table> <tr><th> Methods of <strong>ID3D10Device</strong> </th></tr> <tr><td> <p> <strong>CheckCounter</strong> </p> </td></tr> <tr><td> <p> <strong>CheckCounterInfo</strong> </p> </td></tr> <tr><td> <p> Create*, like <strong>CreateQuery</strong> </p> </td></tr> <tr><td> <p> <strong>GetDeviceRemovedReason</strong> </p> </td></tr> <tr><td> <p> <strong>GetExceptionMode</strong> </p> </td></tr> <tr><td> <p> <strong>OpenSharedResource</strong> </p> </td></tr> <tr><td> <p> <strong>SetExceptionMode</strong> </p> </td></tr> <tr><td> <p> <strong>SetPrivateData</strong> </p> </td></tr> <tr><td> <p> <strong>SetPrivateDataInterface</strong> </p> </td></tr> </table><p>?</p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>hh404583</doc-id>
        /// <unmanaged>HRESULT ID3D11Device1::CreateDeviceContextState([In] unsigned int Flags,[In, Buffer] const D3D_FEATURE_LEVEL* pFeatureLevels,[In] unsigned int FeatureLevels,[In] unsigned int SDKVersion,[In] const GUID&amp; EmulatedInterface,[Out, Optional] D3D_FEATURE_LEVEL* pChosenFeatureLevel,[Out, Fast] ID3DDeviceContextState** ppContextState)</unmanaged>
        /// <unmanaged-short>ID3D11Device1::CreateDeviceContextState</unmanaged-short>
        internal unsafe void CreateDeviceContextState(SharpDX.Direct3D11.CreateDeviceContextStateFlags flags, SharpDX.Direct3D.FeatureLevel[] featureLevelsRef, System.Int32 featureLevels, System.Int32 sDKVersion, System.Guid emulatedInterface, out SharpDX.Direct3D.FeatureLevel chosenFeatureLevelRef, SharpDX.Direct3D11.DeviceContextState contextStateOut)
        {
            System.IntPtr contextStateOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *chosenFeatureLevelRef_ = &chosenFeatureLevelRef)
                fixed (void *featureLevelsRef_ = featureLevelsRef)
                    __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)flags), featureLevelsRef_, featureLevels, sDKVersion, &emulatedInterface, chosenFeatureLevelRef_, &contextStateOut_, (*(void ***)this._nativePointer)[47]);
            (contextStateOut).NativePointer = contextStateOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Give a device access to a shared resource created on a different device.</p>
        /// </summary>
        /// <param name = "hResource"><dd>  <p>A resource handle. See remarks.</p> </dd></param>
        /// <param name = "returnedInterface"><dd>  <p>The globally unique identifier (<see cref = "System.Guid"/>) for the resource interface. See remarks.</p> </dd></param>
        /// <param name = "resourceOut"><dd>  <p>Address of a reference to the resource we are gaining access to.</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>The REFIID, or <see cref = "System.Guid"/>, of the interface to the resource can be obtained by using the __uuidof() macro. For example, __uuidof(<see cref = "SharpDX.Direct3D11.Buffer"/>) will get the <see cref = "System.Guid"/> of the interface to a buffer resource.</p><p>The unique handle of the resource is obtained differently depending on the type of device that originally created the resource.</p><p>To share a resource between two Direct3D 11 devices the resource must have been created with the  <strong>D3D11_RESOURCE_MISC_SHARED</strong> flag, if it was created using the <see cref = "SharpDX.Direct3D11.Device"/> interface.  If it was created using a DXGI device interface, then the resource is always shared.</p><p>The REFIID, or <see cref = "System.Guid"/>, of the interface to the resource can be obtained by using the __uuidof() macro.  For example, __uuidof(<see cref = "SharpDX.Direct3D11.Buffer"/>) will get the <see cref = "System.Guid"/> of the interface to a buffer resource.</p><p>When sharing a resource between two Direct3D 10/11 devices the unique handle of the resource can be obtained by querying the resource for the <strong><see cref = "SharpDX.DXGI.Resource"/></strong> interface and then calling <strong>GetSharedHandle</strong>.</p><pre> <see cref = "SharpDX.DXGI.Resource"/>* pOtherResource(<c>null</c>);
        /// hr = pOtherDeviceResource-&gt;QueryInterface( __uuidof(<see cref = "SharpDX.DXGI.Resource"/>), (void**)&amp;pOtherResource );
        /// HANDLE sharedHandle;
        /// pOtherResource-&gt;GetSharedHandle(&amp;sharedHandle); </pre><p>The only resources that can be shared are 2D non-mipmapped textures.</p><p>To share a resource between a Direct3D 9 device and a Direct3D 11 device the texture must have been created using  the <em>pSharedHandle</em> argument of <strong>CreateTexture</strong>.   The shared Direct3D 9 handle is then passed to OpenSharedResource in the <em>hResource</em> argument.</p><p>The following code illustrates the method calls involved.</p><pre> sharedHandle = <c>null</c>; // must be set to <c>null</c> to create, can use a valid handle here to open in D3D9 
        /// pDevice9-&gt;CreateTexture(..., pTex2D_9, &amp;sharedHandle); 
        /// ... 
        /// pDevice11-&gt;OpenSharedResource(sharedHandle, __uuidof(<see cref = "SharpDX.Direct3D11.Resource"/>), (void**)(&amp;tempResource11)); 
        /// tempResource11-&gt;QueryInterface(__uuidof(<see cref = "SharpDX.Direct3D11.Texture2D"/>), (void**)(&amp;pTex2D_11)); 
        /// tempResource11-&gt;Release(); 
        /// // now use pTex2D_11 with pDevice11    </pre><p>Textures being shared from D3D9 to D3D11 have the following restrictions.</p><ul> <li>Textures must be 2D</li> <li>Only 1 mip level is allowed</li> <li>Texture must have default usage</li> <li>Texture must be write only</li> <li>MSAA textures are not allowed</li> <li>Bind flags must have SHADER_RESOURCE and RENDER_TARGET set</li> <li>Only R10G10B10A2_UNORM, R16G16B16A16_FLOAT and R8G8B8A8_UNORM formats are allowed</li> </ul><p>If a shared texture is updated on one device <strong>ID3D11DeviceContext::Flush</strong> must be called on that device.</p>
        /// </remarks>
        /// <doc-id>ff476531</doc-id>
        /// <unmanaged>HRESULT ID3D11Device1::OpenSharedResource1([In] void* hResource,[In] const GUID&amp; returnedInterface,[Out] void** ppResource)</unmanaged>
        /// <unmanaged-short>ID3D11Device1::OpenSharedResource1</unmanaged-short>
        internal unsafe void OpenSharedResource1(System.IntPtr hResource, System.Guid returnedInterface, out System.IntPtr resourceOut)
        {
            SharpDX.Result __result__;
            fixed (void *resourceOut_ = &resourceOut)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)hResource, &returnedInterface, resourceOut_, (*(void ***)this._nativePointer)[48]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gives a device access to a shared resource that is referenced by name and that was created on a different device. You must have previously created the resource as shared and specified that it uses NT handles (that is, you set the <strong>D3D11_RESOURCE_MISC_SHARED_NTHANDLE</strong> flag).</p>
        /// </summary>
        /// <param name = "lpName">No documentation.</param>
        /// <param name = "dwDesiredAccess">No documentation.</param>
        /// <param name = "returnedInterface">No documentation.</param>
        /// <param name = "resourceOut">No documentation.</param>
        /// <returns><p>This method returns one of the Direct3D 11 return codes. This method also returns E_ACCESSDENIED if the permissions to access the resource aren't valid.</p><p><strong>Platform Update for Windows?7:??</strong>On Windows?7 or Windows Server?2008?R2 with the Platform Update for Windows?7 installed, <strong>OpenSharedResourceByName</strong> fails with E_NOTIMPL because NTHANDLES are used. For more info about the Platform Update for Windows?7, see Platform Update for Windows 7. </p></returns>
        /// <remarks>
        /// <p>The behavior of <strong>OpenSharedResourceByName</strong> is similar to the behavior of the <strong>ID3D11Device1::OpenSharedResource1</strong> method; each call to <strong>OpenSharedResourceByName</strong> to access a resource creates a new resource object.  In other words, if you call <strong>OpenSharedResourceByName</strong> twice and pass the same resource name to <em>lpName</em>, you receive two resource  objects with different <strong><see cref = "SharpDX.IUnknown"/></strong> references.</p><p><strong>To share a resource between two devices</strong></p><ol> <li>Create the resource as shared and specify that it uses NT handles, by setting the <strong>D3D11_RESOURCE_MISC_SHARED_NTHANDLE</strong> flag.</li> <li>Obtain the REFIID, or <see cref = "System.Guid"/>, of the interface to the resource by using the __uuidof() macro. For example, __uuidof(<strong><see cref = "SharpDX.Direct3D11.Texture2D"/></strong>) retrieves the <see cref = "System.Guid"/> of the interface to a 2D texture.</li> <li>Query the resource for the <strong><see cref = "SharpDX.DXGI.Resource1"/></strong> interface.</li> <li>Call the <strong>IDXGIResource1::CreateSharedHandle</strong> method to obtain the unique handle to the resource. In this <strong>IDXGIResource1::CreateSharedHandle</strong> call, you must pass a name for the resource if you want to subsequently call <strong>OpenSharedResourceByName</strong> to access the resource by name. </li> </ol>
        /// </remarks>
        /// <doc-id>hh404595</doc-id>
        /// <unmanaged>HRESULT ID3D11Device1::OpenSharedResourceByName([In] const wchar_t* lpName,[In] DWORD dwDesiredAccess,[In] const GUID&amp; returnedInterface,[Out] void** ppResource)</unmanaged>
        /// <unmanaged-short>ID3D11Device1::OpenSharedResourceByName</unmanaged-short>
        internal unsafe void OpenSharedResourceByName(System.String lpName, SharpDX.DXGI.SharedResourceFlags dwDesiredAccess, System.Guid returnedInterface, out System.IntPtr resourceOut)
        {
            SharpDX.Result __result__;
            fixed (void *resourceOut_ = &resourceOut)
                fixed (char *lpName_ = lpName)
                    __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)lpName_, unchecked ((System.Int32)dwDesiredAccess), &returnedInterface, resourceOut_, (*(void ***)this._nativePointer)[49]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("85611e73-70a9-490e-9614-a9e302777904")]
    public partial class Device11On12 : SharpDX.ComObject
    {
        public Device11On12(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device11On12(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device11On12(nativePtr);
        /// <summary>
        /// <p> This method creates D3D11 resources for use with D3D 11on12. </p>
        /// </summary>
        /// <param name = "resource12Ref"><dd>  <p> A reference to an already-created D3D12 resource or heap. </p> </dd></param>
        /// <param name = "flags11Ref"><dd>  <p> A <strong><see cref = "SharpDX.Direct3D11.D3D11ResourceFlags"/></strong> structure that enables an application to override flags that would be inferred by the resource/heap properties. The <see cref = "SharpDX.Direct3D11.D3D11ResourceFlags"/> structure contains bind flags, misc flags, and CPU access flags. </p> </dd></param>
        /// <param name = "inState"><dd>  <p> The use of the resource on input, as a bitwise-OR'd combination of <strong><see cref = "SharpDX.Direct3D12.ResourceStates"/></strong> enumeration constants. </p> </dd></param>
        /// <param name = "outState"><dd>  <p> The use of the resource on output, as a bitwise-OR'd combination of <strong><see cref = "SharpDX.Direct3D12.ResourceStates"/></strong> enumeration constants. </p> </dd></param>
        /// <param name = "riid"><dd>  <p> The globally unique identifier (<strong><see cref = "System.Guid"/></strong>) for the wrapped resource interface. The <strong>REFIID</strong>, or <strong><see cref = "System.Guid"/></strong>, of the interface to the wrapped resource can be obtained by using the __uuidof() macro. For example, __uuidof(<strong><see cref = "SharpDX.Direct3D12.Resource"/></strong>) will get the <strong><see cref = "System.Guid"/></strong> of the interface to a wrapped resource. </p> </dd></param>
        /// <param name = "resource11Out"><dd>  <p> After the method returns, points to the newly created wrapped D3D11 resource or heap. </p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 12 Return Codes. </p></returns>
        /// <doc-id>dn913199</doc-id>
        /// <unmanaged>HRESULT ID3D11On12Device::CreateWrappedResource([In] IUnknown* pResource12,[In] const D3D11_RESOURCE_FLAGS* pFlags11,[In] int InState,[In] int OutState,[In] const GUID&amp; riid,[Out, Optional] void** ppResource11)</unmanaged>
        /// <unmanaged-short>ID3D11On12Device::CreateWrappedResource</unmanaged-short>
        public unsafe void CreateWrappedResource(SharpDX.IUnknown resource12Ref, SharpDX.Direct3D11.D3D11ResourceFlags flags11Ref, System.Int32 inState, System.Int32 outState, System.Guid riid, out SharpDX.Direct3D11.Resource resource11Out)
        {
            System.IntPtr resource12Ref_ = System.IntPtr.Zero;
            System.IntPtr resource11Out_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            resource12Ref_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(resource12Ref);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)resource12Ref_, &flags11Ref, inState, outState, &riid, &resource11Out_, (*(void ***)this._nativePointer)[3]);
            if (resource11Out_ != System.IntPtr.Zero)
                resource11Out = new SharpDX.Direct3D11.Resource(resource11Out_);
            else
                resource11Out = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Releases D3D11 resources that were wrapped for D3D 11on12. </p>
        /// </summary>
        /// <param name = "resourcesOut"><dd>  <p> Specifies a reference to a set of D3D11 resources, defined by <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong>. </p> </dd></param>
        /// <param name = "numResources"><dd>  <p> Count of the number of resources. </p> </dd></param>
        /// <remarks>
        /// <p> Call this method prior to calling Flush, to insert resource barriers to the appropriate "out" state, and to mark that they should then be expected to be in the "in" state. If no resource list is provided, all wrapped resources are transitioned. These resources will be marked as ?not acquired? in hazard tracking until <strong>ID3D11On12Device::AcquireWrappedResources</strong> is called. </p><p> Keyed mutex resources cannot be provided to this method; use <strong>IDXGIKeyedMutex::ReleaseSync</strong> instead. </p>
        /// </remarks>
        /// <doc-id>dn913200</doc-id>
        /// <unmanaged>void ID3D11On12Device::ReleaseWrappedResources([In, Buffer] const ID3D11Resource** ppResources,[In] unsigned int NumResources)</unmanaged>
        /// <unmanaged-short>ID3D11On12Device::ReleaseWrappedResources</unmanaged-short>
        public unsafe void ReleaseWrappedResources(SharpDX.Direct3D11.Resource[] resourcesOut, System.Int32 numResources)
        {
            System.IntPtr*resourcesOut_;
            resourcesOut_ = (System.IntPtr*)0;
            if (resourcesOut != null)
            {
                System.IntPtr*_resourcesOut = stackalloc System.IntPtr[resourcesOut.Length];
                resourcesOut_ = _resourcesOut;
            }

            if (resourcesOut != null)
                for (int i = 0; i < resourcesOut.Length; ++i)
                    (resourcesOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(resourcesOut[i]);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)resourcesOut_, numResources, (*(void ***)this._nativePointer)[4]);
        }

        /// <summary>
        /// <p> Acquires D3D11 resources for use with D3D 11on12. Indicates that rendering to the wrapped resources can begin again. </p>
        /// </summary>
        /// <param name = "resourcesOut"><dd>  <p> Specifies a reference to a set of D3D11 resources, defined by <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong>. </p> </dd></param>
        /// <param name = "numResources"><dd>  <p> Count of the number of resources. </p> </dd></param>
        /// <remarks>
        /// <p> This method marks the resources as "acquired" in hazard tracking. </p><p> Keyed mutex resources cannot be provided to this method; use <strong>IDXGIKeyedMutex::AcquireSync</strong> instead. </p>
        /// </remarks>
        /// <doc-id>dn913198</doc-id>
        /// <unmanaged>void ID3D11On12Device::AcquireWrappedResources([In, Buffer] const ID3D11Resource** ppResources,[In] unsigned int NumResources)</unmanaged>
        /// <unmanaged-short>ID3D11On12Device::AcquireWrappedResources</unmanaged-short>
        public unsafe void AcquireWrappedResources(SharpDX.Direct3D11.Resource[] resourcesOut, System.Int32 numResources)
        {
            System.IntPtr*resourcesOut_;
            resourcesOut_ = (System.IntPtr*)0;
            if (resourcesOut != null)
            {
                System.IntPtr*_resourcesOut = stackalloc System.IntPtr[resourcesOut.Length];
                resourcesOut_ = _resourcesOut;
            }

            if (resourcesOut != null)
                for (int i = 0; i < resourcesOut.Length; ++i)
                    (resourcesOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(resourcesOut[i]);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)resourcesOut_, numResources, (*(void ***)this._nativePointer)[5]);
        }

        /// <summary>
        /// <p> Releases D3D11 resources that were wrapped for D3D 11on12. </p>
        /// </summary>
        /// <param name = "resourcesOut"><dd>  <p> Specifies a reference to a set of D3D11 resources, defined by <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong>. </p> </dd></param>
        /// <param name = "numResources"><dd>  <p> Count of the number of resources. </p> </dd></param>
        /// <remarks>
        /// <p> Call this method prior to calling Flush, to insert resource barriers to the appropriate "out" state, and to mark that they should then be expected to be in the "in" state. If no resource list is provided, all wrapped resources are transitioned. These resources will be marked as ?not acquired? in hazard tracking until <strong>ID3D11On12Device::AcquireWrappedResources</strong> is called. </p><p> Keyed mutex resources cannot be provided to this method; use <strong>IDXGIKeyedMutex::ReleaseSync</strong> instead. </p>
        /// </remarks>
        /// <doc-id>dn913200</doc-id>
        /// <unmanaged>void ID3D11On12Device::ReleaseWrappedResources([In, Buffer] const ID3D11Resource** ppResources,[In] unsigned int NumResources)</unmanaged>
        /// <unmanaged-short>ID3D11On12Device::ReleaseWrappedResources</unmanaged-short>
        public unsafe void ReleaseWrappedResources(SharpDX.ComArray<SharpDX.Direct3D11.Resource> resourcesOut, System.Int32 numResources)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)(resourcesOut?.NativePointer ?? System.IntPtr.Zero), numResources, (*(void ***)this._nativePointer)[4]);
        }

        /// <summary>
        /// <p> Releases D3D11 resources that were wrapped for D3D 11on12. </p>
        /// </summary>
        /// <param name = "resourcesOut"><dd>  <p> Specifies a reference to a set of D3D11 resources, defined by <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong>. </p> </dd></param>
        /// <param name = "numResources"><dd>  <p> Count of the number of resources. </p> </dd></param>
        /// <remarks>
        /// <p> Call this method prior to calling Flush, to insert resource barriers to the appropriate "out" state, and to mark that they should then be expected to be in the "in" state. If no resource list is provided, all wrapped resources are transitioned. These resources will be marked as ?not acquired? in hazard tracking until <strong>ID3D11On12Device::AcquireWrappedResources</strong> is called. </p><p> Keyed mutex resources cannot be provided to this method; use <strong>IDXGIKeyedMutex::ReleaseSync</strong> instead. </p>
        /// </remarks>
        /// <doc-id>dn913200</doc-id>
        /// <unmanaged>void ID3D11On12Device::ReleaseWrappedResources([In, Buffer] const ID3D11Resource** ppResources,[In] unsigned int NumResources)</unmanaged>
        /// <unmanaged-short>ID3D11On12Device::ReleaseWrappedResources</unmanaged-short>
        private unsafe void ReleaseWrappedResources(System.IntPtr resourcesOut, System.Int32 numResources)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)resourcesOut, numResources, (*(void ***)this._nativePointer)[4]);
        }

        /// <summary>
        /// <p> Acquires D3D11 resources for use with D3D 11on12. Indicates that rendering to the wrapped resources can begin again. </p>
        /// </summary>
        /// <param name = "resourcesOut"><dd>  <p> Specifies a reference to a set of D3D11 resources, defined by <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong>. </p> </dd></param>
        /// <param name = "numResources"><dd>  <p> Count of the number of resources. </p> </dd></param>
        /// <remarks>
        /// <p> This method marks the resources as "acquired" in hazard tracking. </p><p> Keyed mutex resources cannot be provided to this method; use <strong>IDXGIKeyedMutex::AcquireSync</strong> instead. </p>
        /// </remarks>
        /// <doc-id>dn913198</doc-id>
        /// <unmanaged>void ID3D11On12Device::AcquireWrappedResources([In, Buffer] const ID3D11Resource** ppResources,[In] unsigned int NumResources)</unmanaged>
        /// <unmanaged-short>ID3D11On12Device::AcquireWrappedResources</unmanaged-short>
        public unsafe void AcquireWrappedResources(SharpDX.ComArray<SharpDX.Direct3D11.Resource> resourcesOut, System.Int32 numResources)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)(resourcesOut?.NativePointer ?? System.IntPtr.Zero), numResources, (*(void ***)this._nativePointer)[5]);
        }

        /// <summary>
        /// <p> Acquires D3D11 resources for use with D3D 11on12. Indicates that rendering to the wrapped resources can begin again. </p>
        /// </summary>
        /// <param name = "resourcesOut"><dd>  <p> Specifies a reference to a set of D3D11 resources, defined by <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong>. </p> </dd></param>
        /// <param name = "numResources"><dd>  <p> Count of the number of resources. </p> </dd></param>
        /// <remarks>
        /// <p> This method marks the resources as "acquired" in hazard tracking. </p><p> Keyed mutex resources cannot be provided to this method; use <strong>IDXGIKeyedMutex::AcquireSync</strong> instead. </p>
        /// </remarks>
        /// <doc-id>dn913198</doc-id>
        /// <unmanaged>void ID3D11On12Device::AcquireWrappedResources([In, Buffer] const ID3D11Resource** ppResources,[In] unsigned int NumResources)</unmanaged>
        /// <unmanaged-short>ID3D11On12Device::AcquireWrappedResources</unmanaged-short>
        private unsafe void AcquireWrappedResources(System.IntPtr resourcesOut, System.Int32 numResources)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)resourcesOut, numResources, (*(void ***)this._nativePointer)[5]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("9d06dffa-d1e5-4d07-83a8-1bb123f2f841")]
    public partial class Device2 : SharpDX.Direct3D11.Device1
    {
        public Device2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device2(nativePtr);
        /// <summary>
        /// <p>Gets an immediate context, which can play back command lists. </p>
        /// </summary>
        /// <remarks>
        /// <p>The <strong>GetImmediateContext2</strong> method returns an <strong><see cref = "SharpDX.Direct3D11.DeviceContext2"/></strong> object that represents an immediate context, which is used to perform rendering that you want immediately submitted to a device. For most apps, an immediate context is the primary object that is used to draw your scene.</p><p>The <strong>GetImmediateContext2</strong> method increments the reference count of the immediate context by one. Therefore, you must call <strong>Release</strong> on the returned interface reference when you are done with it to avoid a memory leak. </p>
        /// </remarks>
        /// <doc-id>dn280496</doc-id>
        /// <unmanaged>GetImmediateContext2</unmanaged>
        /// <unmanaged-short>GetImmediateContext2</unmanaged-short>
        public SharpDX.Direct3D11.DeviceContext2 ImmediateContext2
        {
            get
            {
                if (this.ImmediateContext2__ == null)
                    GetImmediateContext2(out ImmediateContext2__);
                return this.ImmediateContext2__;
            }
        }

        protected internal SharpDX.Direct3D11.DeviceContext2 ImmediateContext2__;
        /// <summary>
        /// <p>Gets an immediate context, which can play back command lists. </p>
        /// </summary>
        /// <param name = "immediateContextOut">No documentation.</param>
        /// <remarks>
        /// <p>The <strong>GetImmediateContext2</strong> method returns an <strong><see cref = "SharpDX.Direct3D11.DeviceContext2"/></strong> object that represents an immediate context, which is used to perform rendering that you want immediately submitted to a device. For most apps, an immediate context is the primary object that is used to draw your scene.</p><p>The <strong>GetImmediateContext2</strong> method increments the reference count of the immediate context by one. Therefore, you must call <strong>Release</strong> on the returned interface reference when you are done with it to avoid a memory leak. </p>
        /// </remarks>
        /// <doc-id>dn280496</doc-id>
        /// <unmanaged>void ID3D11Device2::GetImmediateContext2([Out] ID3D11DeviceContext2** ppImmediateContext)</unmanaged>
        /// <unmanaged-short>ID3D11Device2::GetImmediateContext2</unmanaged-short>
        internal unsafe void GetImmediateContext2(out SharpDX.Direct3D11.DeviceContext2 immediateContextOut)
        {
            System.IntPtr immediateContextOut_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, &immediateContextOut_, (*(void ***)this._nativePointer)[50]);
            if (immediateContextOut_ != System.IntPtr.Zero)
                immediateContextOut = new SharpDX.Direct3D11.DeviceContext2(immediateContextOut_);
            else
                immediateContextOut = null;
        }

        /// <summary>
        /// <p> Creates a deferred context, which can record command lists. </p>
        /// </summary>
        /// <param name = "contextFlags">No documentation.</param>
        /// <param name = "deferredContextOut">No documentation.</param>
        /// <returns><p> Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns one of the following: </p><ul> <li> Returns <strong><see cref = "DeviceRemoved"/></strong> if the video card has been physically removed from the system, or a driver upgrade for the video card has occurred. If this error occurs, you should destroy and recreate the device. </li> <li> Returns <strong><see cref = "InvalidCall"/></strong> if the <strong>CreateDeferredContext2</strong> method can't be called from the current context. For example, if the device was created with the <strong>D3D11_CREATE_DEVICE_SINGLETHREADED</strong> value,  <strong>CreateDeferredContext2</strong> returns <strong><see cref = "InvalidCall"/></strong>. </li> <li> Returns <strong>E_INVALIDARG</strong> if the <em>ContextFlags</em> parameter is invalid. </li> <li> Returns <strong>E_OUTOFMEMORY</strong> if the app has exhausted available memory. </li> </ul></returns>
        /// <remarks>
        /// <p> A deferred context is a thread-safe context that you can use to record graphics commands on a thread other than the main rendering thread. By using a deferred context, you can record graphics commands into a command list that is encapsulated by the <strong><see cref = "SharpDX.Direct3D11.CommandList"/></strong> interface. After you record all scene items, you can then submit them to the main render thread for final rendering. In this manner, you can perform rendering tasks concurrently across multiple threads and potentially improve performance in multi-core CPU scenarios. </p><p> You can create multiple deferred contexts. </p><strong>Note</strong>?? If you use the <strong>D3D11_CREATE_DEVICE_SINGLETHREADED</strong> value to create the device, <strong>CreateDeferredContext2</strong> fails with <strong><see cref = "InvalidCall"/></strong>, and you can't create a deferred context.?<p> For more information about deferred contexts, see Immediate and Deferred Rendering. </p>
        /// </remarks>
        /// <doc-id>dn280495</doc-id>
        /// <unmanaged>HRESULT ID3D11Device2::CreateDeferredContext2([In] unsigned int ContextFlags,[Out, Fast] ID3D11DeviceContext2** ppDeferredContext)</unmanaged>
        /// <unmanaged-short>ID3D11Device2::CreateDeferredContext2</unmanaged-short>
        internal unsafe void CreateDeferredContext2(System.Int32 contextFlags, SharpDX.Direct3D11.DeviceContext2 deferredContextOut)
        {
            System.IntPtr deferredContextOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, contextFlags, &deferredContextOut_, (*(void ***)this._nativePointer)[51]);
            (deferredContextOut).NativePointer = deferredContextOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets info about how a tiled resource is broken into tiles.</p>
        /// </summary>
        /// <param name = "tiledResourceRef"><dd>  <p>A reference to the tiled resource to get info about.</p> </dd></param>
        /// <param name = "numTilesForEntireResourceRef"><dd>  <p>A reference to a variable that receives the number of tiles needed to store the entire tiled resource. </p> </dd></param>
        /// <param name = "packedMipDescRef"><dd>  <p> A reference to a <strong><see cref = "SharpDX.Direct3D11.PackedMipDescription"/></strong> structure that <strong>GetResourceTiling</strong> fills with info about how the tiled resource's mipmaps are packed. </p> </dd></param>
        /// <param name = "standardTileShapeForNonPackedMipsRef"><dd>  <p> A reference to a <strong><see cref = "SharpDX.Direct3D11.TileShape"/></strong> structure that <strong>GetResourceTiling</strong> fills with info about the tile shape. This is info about how pixels fit in the tiles, independent of tiled resource's dimensions, not including packed mipmaps.  If the entire tiled resource is packed, this parameter is meaningless because the tiled resource has no defined layout for packed mipmaps. In this situation, <strong>GetResourceTiling</strong> sets the members of <strong><see cref = "SharpDX.Direct3D11.TileShape"/></strong> to zeros. </p> </dd></param>
        /// <param name = "numSubresourceTilingsRef"><dd>  <p> A reference to a variable that contains the number of tiles in the subresource. On input, this is the number of subresources to query tilings for; on output, this is the number that was actually retrieved at <em>pSubresourceTilingsForNonPackedMips</em> (clamped to what's available). </p> </dd></param>
        /// <param name = "firstSubresourceTilingToGet"><dd>  <p> The number of the first subresource tile to get. <strong>GetResourceTiling</strong> ignores this parameter if the number that <em>pNumSubresourceTilings</em> points to is 0. </p> </dd></param>
        /// <param name = "subresourceTilingsForNonPackedMipsRef"><dd>  <p> A reference to a <strong><see cref = "SharpDX.Direct3D11.SubResourceTiling"/></strong> structure that <strong>GetResourceTiling</strong> fills with info about subresource tiles. </p> <p> If subresource tiles are part of packed mipmaps, <strong>GetResourceTiling</strong> sets the members of <strong><see cref = "SharpDX.Direct3D11.SubResourceTiling"/></strong> to zeros, except the <strong>StartTileIndexInOverallResource</strong> member, which <strong>GetResourceTiling</strong> sets to <strong>D3D11_PACKED_TILE</strong> (0xffffffff). The <strong>D3D11_PACKED_TILE</strong> constant indicates that the whole <strong><see cref = "SharpDX.Direct3D11.SubResourceTiling"/></strong> structure is meaningless for this situation, and the info that the <em>pPackedMipDesc</em> parameter points to applies. </p> </dd></param>
        /// <remarks>
        /// <p> For more info about tiled resources, see Tiled resources. </p>
        /// </remarks>
        /// <doc-id>dn280497</doc-id>
        /// <unmanaged>void ID3D11Device2::GetResourceTiling([In] ID3D11Resource* pTiledResource,[Out, Optional] unsigned int* pNumTilesForEntireResource,[Out, Optional] D3D11_PACKED_MIP_DESC* pPackedMipDesc,[Out, Optional] D3D11_TILE_SHAPE* pStandardTileShapeForNonPackedMips,[InOut] unsigned int* pNumSubresourceTilings,[In] unsigned int FirstSubresourceTilingToGet,[Out, Buffer] D3D11_SUBRESOURCE_TILING* pSubresourceTilingsForNonPackedMips)</unmanaged>
        /// <unmanaged-short>ID3D11Device2::GetResourceTiling</unmanaged-short>
        public unsafe void GetResourceTiling(SharpDX.Direct3D11.Resource tiledResourceRef, out System.Int32 numTilesForEntireResourceRef, out SharpDX.Direct3D11.PackedMipDescription packedMipDescRef, out SharpDX.Direct3D11.TileShape standardTileShapeForNonPackedMipsRef, ref System.Int32 numSubresourceTilingsRef, System.Int32 firstSubresourceTilingToGet, SharpDX.Direct3D11.SubResourceTiling[] subresourceTilingsForNonPackedMipsRef)
        {
            System.IntPtr tiledResourceRef_ = System.IntPtr.Zero;
            packedMipDescRef = default (SharpDX.Direct3D11.PackedMipDescription);
            standardTileShapeForNonPackedMipsRef = default (SharpDX.Direct3D11.TileShape);
            tiledResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(tiledResourceRef);
            fixed (void *subresourceTilingsForNonPackedMipsRef_ = subresourceTilingsForNonPackedMipsRef)
                fixed (void *numSubresourceTilingsRef_ = &numSubresourceTilingsRef)
                    fixed (void *standardTileShapeForNonPackedMipsRef_ = &standardTileShapeForNonPackedMipsRef)
                        fixed (void *packedMipDescRef_ = &packedMipDescRef)
                            fixed (void *numTilesForEntireResourceRef_ = &numTilesForEntireResourceRef)
                                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)tiledResourceRef_, numTilesForEntireResourceRef_, packedMipDescRef_, standardTileShapeForNonPackedMipsRef_, numSubresourceTilingsRef_, firstSubresourceTilingToGet, subresourceTilingsForNonPackedMipsRef_, (*(void ***)this._nativePointer)[52]);
        }

        /// <summary>
        /// <p>Get the number of quality levels available during multisampling.</p>
        /// </summary>
        /// <param name = "format"><dd>  <p>The texture format during multisampling. </p> </dd></param>
        /// <param name = "sampleCount"><dd>  <p>The number of samples during multisampling.</p> </dd></param>
        /// <param name = "flags"><dd>  <p>A combination of <strong>D3D11_CHECK_MULTISAMPLE_QUALITY_LEVELS_FLAGS</strong> values that are combined by using a bitwise OR operation. Currently, only <strong>D3D11_CHECK_MULTISAMPLE_QUALITY_LEVELS_TILED_RESOURCE</strong> is supported. </p> </dd></param>
        /// <returns><dd>  <p>A reference to a variable the receives the number of quality levels supported by the adapter. See Remarks.</p> </dd></returns>
        /// <remarks>
        /// <p>When you multisample a texture, the number of quality levels available for an adapter is dependent on the texture format that you use and the number of  samples that you request. The maximum number of quality levels is defined by <strong><see cref = "MultisampleCountMaximum"/></strong> in D3D11.h. If this method returns 0, the format  and sample count combination is not supported for the installed adapter.</p><p>Furthermore, the definition of a quality level is up to each hardware vendor to define, however no facility is provided by Direct3D to help discover  this information.</p><p>Note that FEATURE_LEVEL_10_1 devices are required to support 4x MSAA for all render targets except R32G32B32A32 and R32G32B32. FEATURE_LEVEL_11_0 devices are required to support 4x MSAA for all render target formats, and 8x MSAA for all render target formats  except R32G32B32A32 formats.</p>
        /// </remarks>
        /// <doc-id>dn280494</doc-id>
        /// <unmanaged>HRESULT ID3D11Device2::CheckMultisampleQualityLevels1([In] DXGI_FORMAT Format,[In] unsigned int SampleCount,[In] unsigned int Flags,[Out] unsigned int* pNumQualityLevels)</unmanaged>
        /// <unmanaged-short>ID3D11Device2::CheckMultisampleQualityLevels1</unmanaged-short>
        public unsafe System.Int32 CheckMultisampleQualityLevels1(SharpDX.DXGI.Format format, System.Int32 sampleCount, SharpDX.Direct3D11.CheckMultisampleQualityLevelsFlags flags)
        {
            System.Int32 numQualityLevelsRef;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)format), sampleCount, unchecked ((System.Int32)flags), &numQualityLevelsRef, (*(void ***)this._nativePointer)[53]);
            __result__.CheckError();
            return numQualityLevelsRef;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("A05C8C37-D2C6-4732-B3A0-9CE0B0DC9AE6")]
    public partial class Device3 : SharpDX.Direct3D11.Device2
    {
        public Device3(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device3(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device3(nativePtr);
        /// <summary>
        /// <p> Gets an immediate context, which can play back command lists. </p>
        /// </summary>
        /// <remarks>
        /// <p> The <strong>GetImmediateContext3</strong> method outputs an <strong><see cref = "SharpDX.Direct3D11.DeviceContext3"/></strong> object that represents an immediate context, which is used to perform rendering that you want immediately submitted to a device. For most apps, an immediate context is the primary object that is used to draw your scene. </p><p> The <strong>GetImmediateContext3</strong> method increments the reference count of the immediate context by one. Therefore, you must call <strong>Release</strong> on the returned interface reference when you are done with it to avoid a memory leak. </p>
        /// </remarks>
        /// <doc-id>dn912872</doc-id>
        /// <unmanaged>GetImmediateContext3</unmanaged>
        /// <unmanaged-short>GetImmediateContext3</unmanaged-short>
        public SharpDX.Direct3D11.DeviceContext3 ImmediateContext3
        {
            get
            {
                if (this.ImmediateContext3__ == null)
                    GetImmediateContext3(out ImmediateContext3__);
                return this.ImmediateContext3__;
            }
        }

        protected internal SharpDX.Direct3D11.DeviceContext3 ImmediateContext3__;
        /// <summary>
        /// <p>Creates a 2D texture.</p>
        /// </summary>
        /// <param name = "desc1Ref">No documentation.</param>
        /// <param name = "initialDataRef">No documentation.</param>
        /// <param name = "texture2DOut">No documentation.</param>
        /// <returns><p>If the method succeeds, the return code is <strong><see cref = "SharpDX.Result.Ok"/></strong>. See Direct3D 11 Return Codes for failing error codes.</p></returns>
        /// <remarks>
        /// <p><strong>CreateTexture2D1</strong> creates a 2D texture resource, which can contain a number of 2D subresources. The number of subresources is specified in the texture description. All textures in a resource must have the same format, size, and number of mipmap levels.</p><p>All resources are made up of one or more subresources. To load data into the texture, applications can supply the data initially as an array of <strong><see cref = "SharpDX.DataBox"/></strong> structures pointed to by <em>pInitialData</em>, or they can use one of the D3DX texture functions such as <strong>D3DX11CreateTextureFromFile</strong>.</p><p>For a 32 x 32 texture with a full mipmap chain, the <em>pInitialData</em> array has the following 6 elements:
        /// </p><ul> <li>pInitialData[0] = 32x32</li> <li>pInitialData[1] = 16x16</li> <li>pInitialData[2] = 8x8</li> <li>pInitialData[3] = 4x4
        /// </li> <li>pInitialData[4] = 2x2
        /// </li> <li>pInitialData[5] = 1x1
        /// </li> </ul>
        /// </remarks>
        /// <doc-id>dn899229</doc-id>
        /// <unmanaged>HRESULT ID3D11Device3::CreateTexture2D1([In] const D3D11_TEXTURE2D_DESC1* pDesc1,[In, Buffer, Optional] const D3D11_SUBRESOURCE_DATA* pInitialData,[Out, Fast] ID3D11Texture2D1** ppTexture2D)</unmanaged>
        /// <unmanaged-short>ID3D11Device3::CreateTexture2D1</unmanaged-short>
        internal unsafe void CreateTexture2D1(ref SharpDX.Direct3D11.Texture2DDescription1 desc1Ref, SharpDX.DataBox[] initialDataRef, SharpDX.Direct3D11.Texture2D1 texture2DOut)
        {
            System.IntPtr texture2DOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *initialDataRef_ = initialDataRef)
                fixed (void *desc1Ref_ = &desc1Ref)
                    __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, desc1Ref_, initialDataRef_, &texture2DOut_, (*(void ***)this._nativePointer)[54]);
            (texture2DOut).NativePointer = texture2DOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 3D texture.</p>
        /// </summary>
        /// <param name = "desc1Ref">No documentation.</param>
        /// <param name = "initialDataRef">No documentation.</param>
        /// <param name = "texture3DOut">No documentation.</param>
        /// <returns><p>If the method succeeds, the return code is <strong><see cref = "SharpDX.Result.Ok"/></strong>. See Direct3D 11 Return Codes for failing error codes.</p></returns>
        /// <remarks>
        /// <p><strong>CreateTexture3D1</strong> creates a 3D texture resource, which can contain a number of 3D subresources. The number of textures is specified in the texture description. All textures in a resource must have the same format, size, and number of mipmap levels.</p><p>All resources are made up of one or more subresources. To load data into the texture, applications can supply the data initially as an array of <strong><see cref = "SharpDX.DataBox"/></strong> structures pointed to by <em>pInitialData</em>, or they can use one of the D3DX texture functions such as <strong>D3DX11CreateTextureFromFile</strong>.</p><p>Each element of <em>pInitialData</em> provides all of the slices that are defined for a given miplevel. For example, for a 32 x 32 x 4 volume texture with a full mipmap chain, the array has the following 6 elements:</p><ul> <li>pInitialData[0] = 32x32 with 4 slices</li> <li>pInitialData[1] = 16x16 with 2 slices</li> <li>pInitialData[2] = 8x8 with 1 slice</li> <li>pInitialData[3] = 4x4
        /// with 1 slice</li> <li>pInitialData[4] = 2x2
        /// with 1 slice</li> <li>pInitialData[5] = 1x1
        /// with 1 slice</li> </ul>
        /// </remarks>
        /// <doc-id>dn899231</doc-id>
        /// <unmanaged>HRESULT ID3D11Device3::CreateTexture3D1([In] const D3D11_TEXTURE3D_DESC1* pDesc1,[In, Buffer, Optional] const D3D11_SUBRESOURCE_DATA* pInitialData,[Out, Fast] ID3D11Texture3D1** ppTexture3D)</unmanaged>
        /// <unmanaged-short>ID3D11Device3::CreateTexture3D1</unmanaged-short>
        internal unsafe void CreateTexture3D1(ref SharpDX.Direct3D11.Texture3DDescription1 desc1Ref, SharpDX.DataBox[] initialDataRef, SharpDX.Direct3D11.Texture3D1 texture3DOut)
        {
            System.IntPtr texture3DOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *initialDataRef_ = initialDataRef)
                fixed (void *desc1Ref_ = &desc1Ref)
                    __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, desc1Ref_, initialDataRef_, &texture3DOut_, (*(void ***)this._nativePointer)[55]);
            (texture3DOut).NativePointer = texture3DOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a rasterizer state object that informs the rasterizer stage how to behave and forces the sample count while UAV rendering or rasterizing.</p>
        /// </summary>
        /// <param name = "rasterizerDescRef">No documentation.</param>
        /// <param name = "rasterizerStateOut">No documentation.</param>
        /// <returns><p>This method returns E_OUTOFMEMORY if there is insufficient memory to create the rasterizer state object.  See Direct3D 11 Return Codes for other possible return values.</p></returns>
        /// <doc-id>dn899221</doc-id>
        /// <unmanaged>HRESULT ID3D11Device3::CreateRasterizerState2([In] const D3D11_RASTERIZER_DESC2* pRasterizerDesc,[Out, Fast] ID3D11RasterizerState2** ppRasterizerState)</unmanaged>
        /// <unmanaged-short>ID3D11Device3::CreateRasterizerState2</unmanaged-short>
        internal unsafe void CreateRasterizerState2(ref SharpDX.Direct3D11.RasterizerStateDescription2 rasterizerDescRef, SharpDX.Direct3D11.RasterizerState2 rasterizerStateOut)
        {
            System.IntPtr rasterizerStateOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *rasterizerDescRef_ = &rasterizerDescRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, rasterizerDescRef_, &rasterizerStateOut_, (*(void ***)this._nativePointer)[56]);
            (rasterizerStateOut).NativePointer = rasterizerStateOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a shader-resource view for accessing data in a resource.</p>
        /// </summary>
        /// <param name = "resourceRef"><dd>  <p>Pointer to the resource that will serve as input to a shader. This resource must have been created with the <strong> D3D11_BIND_SHADER_RESOURCE</strong> flag.</p> </dd></param>
        /// <param name = "desc1Ref"><dd>  <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.ShaderResourceViewDescription1"/></strong> structure that describes a shader-resource view. Set this parameter to <strong><c>null</c></strong> to create a  view that accesses the entire resource (using the format the resource was created with).</p> </dd></param>
        /// <param name = "sRView1Out"><dd>  <p>A reference to a memory block that receives a reference to a <strong><see cref = "SharpDX.Direct3D11.ShaderResourceView1"/></strong> interface for the created shader-resource view. Set this parameter to <strong><c>null</c></strong> to validate the other input parameters (the method will return <strong>S_FALSE</strong> if the other input parameters pass validation).</p> </dd></param>
        /// <returns><p>This method returns E_OUTOFMEMORY if there is insufficient memory to create the shader-resource view.  See Direct3D 11 Return Codes for other possible return values.</p></returns>
        /// <doc-id>dn899227</doc-id>
        /// <unmanaged>HRESULT ID3D11Device3::CreateShaderResourceView1([In] ID3D11Resource* pResource,[In, Optional] const D3D11_SHADER_RESOURCE_VIEW_DESC1* pDesc1,[Out, Fast] ID3D11ShaderResourceView1** ppSRView1)</unmanaged>
        /// <unmanaged-short>ID3D11Device3::CreateShaderResourceView1</unmanaged-short>
        internal unsafe void CreateShaderResourceView1(SharpDX.Direct3D11.Resource resourceRef, SharpDX.Direct3D11.ShaderResourceViewDescription1? desc1Ref, SharpDX.Direct3D11.ShaderResourceView1 sRView1Out)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.ShaderResourceViewDescription1 desc1Ref_;
            System.IntPtr sRView1Out_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(resourceRef);
            if (desc1Ref != null)
                desc1Ref_ = desc1Ref.Value;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)resourceRef_, desc1Ref == null ? (void *)0 : &desc1Ref_, &sRView1Out_, (*(void ***)this._nativePointer)[57]);
            (sRView1Out).NativePointer = sRView1Out_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a view for accessing an unordered access resource. </p>
        /// </summary>
        /// <param name = "resourceRef">No documentation.</param>
        /// <param name = "desc1Ref">No documentation.</param>
        /// <param name = "uAView1Out">No documentation.</param>
        /// <returns><p> This method returns E_OUTOFMEMORY if there is insufficient memory to create the unordered-access view.  See Direct3D 11 Return Codes for other possible return values. </p></returns>
        /// <doc-id>dn899232</doc-id>
        /// <unmanaged>HRESULT ID3D11Device3::CreateUnorderedAccessView1([In] ID3D11Resource* pResource,[In, Optional] const D3D11_UNORDERED_ACCESS_VIEW_DESC1* pDesc1,[Out, Fast] ID3D11UnorderedAccessView1** ppUAView1)</unmanaged>
        /// <unmanaged-short>ID3D11Device3::CreateUnorderedAccessView1</unmanaged-short>
        internal unsafe void CreateUnorderedAccessView1(SharpDX.Direct3D11.Resource resourceRef, SharpDX.Direct3D11.UnorderedAccessViewDescription1? desc1Ref, SharpDX.Direct3D11.UnorderedAccessView1 uAView1Out)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.UnorderedAccessViewDescription1 desc1Ref_;
            System.IntPtr uAView1Out_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(resourceRef);
            if (desc1Ref != null)
                desc1Ref_ = desc1Ref.Value;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)resourceRef_, desc1Ref == null ? (void *)0 : &desc1Ref_, &uAView1Out_, (*(void ***)this._nativePointer)[58]);
            (uAView1Out).NativePointer = uAView1Out_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a render-target view for accessing resource data.</p>
        /// </summary>
        /// <param name = "resourceRef"><dd>  <p>Pointer to a <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong> that represents a render target. This resource must have been created with the <strong>D3D11_BIND_RENDER_TARGET</strong> flag.</p> </dd></param>
        /// <param name = "desc1Ref"><dd>  <p>Pointer to a <strong><see cref = "SharpDX.Direct3D11.RenderTargetViewDescription1"/></strong> that represents a render-target view description. Set this parameter to <strong><c>null</c></strong> to create a view that accesses all of the subresources in mipmap level 0.</p> </dd></param>
        /// <param name = "rTView1Out"><dd>  <p>A reference to a memory block that receives a reference to a <strong><see cref = "SharpDX.Direct3D11.RenderTargetView1"/></strong> interface for the created render-target view. Set this parameter to <strong><c>null</c></strong> to validate the other input parameters (the method will return <strong>S_FALSE</strong> if the other input parameters pass validation).</p> </dd></param>
        /// <returns><p>This method returns one of the Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>A render-target view can be bound to the output-merger stage by calling <strong>ID3D11DeviceContext::OMSetRenderTargets</strong>.</p>
        /// </remarks>
        /// <doc-id>dn899224</doc-id>
        /// <unmanaged>HRESULT ID3D11Device3::CreateRenderTargetView1([In] ID3D11Resource* pResource,[In, Optional] const D3D11_RENDER_TARGET_VIEW_DESC1* pDesc1,[Out, Fast] ID3D11RenderTargetView1** ppRTView1)</unmanaged>
        /// <unmanaged-short>ID3D11Device3::CreateRenderTargetView1</unmanaged-short>
        internal unsafe void CreateRenderTargetView1(SharpDX.Direct3D11.Resource resourceRef, SharpDX.Direct3D11.RenderTargetViewDescription1? desc1Ref, SharpDX.Direct3D11.RenderTargetView1 rTView1Out)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.RenderTargetViewDescription1 desc1Ref_;
            System.IntPtr rTView1Out_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(resourceRef);
            if (desc1Ref != null)
                desc1Ref_ = desc1Ref.Value;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)resourceRef_, desc1Ref == null ? (void *)0 : &desc1Ref_, &rTView1Out_, (*(void ***)this._nativePointer)[59]);
            (rTView1Out).NativePointer = rTView1Out_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a query object for querying information from the graphics processing unit (GPU). </p>
        /// </summary>
        /// <param name = "queryDesc1Ref"><dd>  <p>Pointer to a <strong><see cref = "SharpDX.Direct3D11.QueryDescription1"/></strong> structure that represents a query description.</p> </dd></param>
        /// <param name = "query1Out"><dd>  <p>A reference to a memory block that receives a reference to a <strong><see cref = "SharpDX.Direct3D11.Query1"/></strong> interface for the created query object. Set this parameter to <strong><c>null</c></strong> to validate the other input parameters (the method will return <strong>S_FALSE</strong> if the other input parameters pass validation).</p> </dd></param>
        /// <returns><p>This method returns E_OUTOFMEMORY if there is insufficient memory to create the query object.   See Direct3D 11 Return Codes for other possible return values.</p></returns>
        /// <doc-id>dn899220</doc-id>
        /// <unmanaged>HRESULT ID3D11Device3::CreateQuery1([In] const D3D11_QUERY_DESC1* pQueryDesc1,[Out, Fast] ID3D11Query1** ppQuery1)</unmanaged>
        /// <unmanaged-short>ID3D11Device3::CreateQuery1</unmanaged-short>
        internal unsafe void CreateQuery1(SharpDX.Direct3D11.QueryDescription1 queryDesc1Ref, SharpDX.Direct3D11.Query1 query1Out)
        {
            System.IntPtr query1Out_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &queryDesc1Ref, &query1Out_, (*(void ***)this._nativePointer)[60]);
            (query1Out).NativePointer = query1Out_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets an immediate context, which can play back command lists. </p>
        /// </summary>
        /// <param name = "immediateContextOut">No documentation.</param>
        /// <remarks>
        /// <p> The <strong>GetImmediateContext3</strong> method outputs an <strong><see cref = "SharpDX.Direct3D11.DeviceContext3"/></strong> object that represents an immediate context, which is used to perform rendering that you want immediately submitted to a device. For most apps, an immediate context is the primary object that is used to draw your scene. </p><p> The <strong>GetImmediateContext3</strong> method increments the reference count of the immediate context by one. Therefore, you must call <strong>Release</strong> on the returned interface reference when you are done with it to avoid a memory leak. </p>
        /// </remarks>
        /// <doc-id>dn912872</doc-id>
        /// <unmanaged>void ID3D11Device3::GetImmediateContext3([Out] ID3D11DeviceContext3** ppImmediateContext)</unmanaged>
        /// <unmanaged-short>ID3D11Device3::GetImmediateContext3</unmanaged-short>
        internal unsafe void GetImmediateContext3(out SharpDX.Direct3D11.DeviceContext3 immediateContextOut)
        {
            System.IntPtr immediateContextOut_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, &immediateContextOut_, (*(void ***)this._nativePointer)[61]);
            if (immediateContextOut_ != System.IntPtr.Zero)
                immediateContextOut = new SharpDX.Direct3D11.DeviceContext3(immediateContextOut_);
            else
                immediateContextOut = null;
        }

        /// <summary>
        /// <p> Creates a deferred context, which can record command lists. </p>
        /// </summary>
        /// <param name = "contextFlags">No documentation.</param>
        /// <param name = "deferredContextOut">No documentation.</param>
        /// <returns><p> Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns one of the following: </p><ul> <li> Returns <strong><see cref = "DeviceRemoved"/></strong> if the video card has been physically removed from the system, or a driver upgrade for the video card has occurred. If this error occurs, you should destroy and recreate the device. </li> <li> Returns <strong><see cref = "InvalidCall"/></strong> if the <strong>CreateDeferredContext3</strong> method can't be called from the current context. For example, if the device was created with the <strong>D3D11_CREATE_DEVICE_SINGLETHREADED</strong> value,  <strong>CreateDeferredContext3</strong> returns <strong><see cref = "InvalidCall"/></strong>. </li> <li> Returns <strong>E_INVALIDARG</strong> if the <em>ContextFlags</em> parameter is invalid. </li> <li> Returns <strong>E_OUTOFMEMORY</strong> if the app has exhausted available memory. </li> </ul></returns>
        /// <doc-id>dn912871</doc-id>
        /// <unmanaged>HRESULT ID3D11Device3::CreateDeferredContext3([In] unsigned int ContextFlags,[Out, Fast] ID3D11DeviceContext3** ppDeferredContext)</unmanaged>
        /// <unmanaged-short>ID3D11Device3::CreateDeferredContext3</unmanaged-short>
        internal unsafe void CreateDeferredContext3(System.Int32 contextFlags, SharpDX.Direct3D11.DeviceContext3 deferredContextOut)
        {
            System.IntPtr deferredContextOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, contextFlags, &deferredContextOut_, (*(void ***)this._nativePointer)[62]);
            (deferredContextOut).NativePointer = deferredContextOut_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Copies data into a <strong>D3D11_USAGE_DEFAULT</strong> texture which was mapped using ID3D11DeviceContext3::<strong>Map</strong> while providing a <c>null</c> <strong><see cref = "SharpDX.DataBox"/></strong> parameter. </p>
        /// </summary>
        /// <param name = "dstResourceRef">No documentation.</param>
        /// <param name = "dstSubresource">No documentation.</param>
        /// <param name = "dstBoxRef">No documentation.</param>
        /// <param name = "srcDataRef">No documentation.</param>
        /// <param name = "srcRowPitch">No documentation.</param>
        /// <param name = "srcDepthPitch">No documentation.</param>
        /// <remarks>
        /// <p> The provided resource must be a <strong>D3D11_USAGE_DEFAULT</strong> texture which was mapped for writing by a previous call to ID3D11DeviceContext3::<strong>Map</strong> while providing a <c>null</c> <strong><see cref = "SharpDX.DataBox"/></strong> parameter. </p><p> This API is intended for calling at high frequency. Callers can reduce memory by making iterative calls that update progressive regions of the texture, while provide a small buffer during each call. It is most efficient to specify large enough regions, though, because this enables D3D to fill whole cache lines in the texture before returning. </p><p> For efficiency, ensure the bounds and alignment of the extents within the box are ( 64 / [bytes per pixel] ) pixels horizontally. Vertical bounds and alignment should be 2 rows, except when 1-byte-per-pixel formats are used, in which case 4 rows are recommended. Single depth slices per call are handled efficiently. It is recommended but not necessary to provide references and strides which are 128-byte aligned. </p><p> When writing to sub mipmap levels, it is recommended to use larger width and heights than described above. This is because small mipmap levels may actually be stored within a larger block of memory, with an opaque amount of offsetting which can interfere with alignment to cache lines. </p>
        /// </remarks>
        /// <doc-id>dn912874</doc-id>
        /// <unmanaged>void ID3D11Device3::WriteToSubresource([In] ID3D11Resource* pDstResource,[In] unsigned int DstSubresource,[In, Optional] const D3D11_BOX* pDstBox,[In] const void* pSrcData,[In] unsigned int SrcRowPitch,[In] unsigned int SrcDepthPitch)</unmanaged>
        /// <unmanaged-short>ID3D11Device3::WriteToSubresource</unmanaged-short>
        public unsafe void WriteToSubresource(SharpDX.Direct3D11.Resource dstResourceRef, System.Int32 dstSubresource, SharpDX.Direct3D11.ResourceRegion? dstBoxRef, System.IntPtr srcDataRef, System.Int32 srcRowPitch, System.Int32 srcDepthPitch)
        {
            System.IntPtr dstResourceRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.ResourceRegion dstBoxRef_;
            dstResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(dstResourceRef);
            if (dstBoxRef != null)
                dstBoxRef_ = dstBoxRef.Value;
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)dstResourceRef_, dstSubresource, dstBoxRef == null ? (void *)0 : &dstBoxRef_, (void *)srcDataRef, srcRowPitch, srcDepthPitch, (*(void ***)this._nativePointer)[63]);
        }

        /// <summary>
        /// <p> Copies data from a <strong>D3D11_USAGE_DEFAULT</strong> texture which was mapped using ID3D11DeviceContext3::<strong>Map</strong> while providing a <c>null</c> <strong><see cref = "SharpDX.DataBox"/></strong> parameter. </p>
        /// </summary>
        /// <param name = "dstDataRef">No documentation.</param>
        /// <param name = "dstRowPitch">No documentation.</param>
        /// <param name = "dstDepthPitch">No documentation.</param>
        /// <param name = "srcResourceRef">No documentation.</param>
        /// <param name = "srcSubresource">No documentation.</param>
        /// <param name = "srcBoxRef">No documentation.</param>
        /// <remarks>
        /// <p> The provided resource must be a <strong>D3D11_USAGE_DEFAULT</strong> texture which was mapped for writing by a previous call to ID3D11DeviceContext3::<strong>Map</strong> while providing a <c>null</c> <strong><see cref = "SharpDX.DataBox"/></strong> parameter. </p><p> This API is intended for calling at high frequency. Callers can reduce memory by making iterative calls that update progressive regions of the texture, while provide a small buffer during each call. It is most efficient to specify large enough regions, though, because this enables D3D to fill whole cache lines in the texture before returning. </p><p> For efficiency, ensure the bounds and alignment of the extents within the box are ( 64 / [Bytes per pixel] ) pixels horizontally. Vertical bounds and alignment should be 2 rows, except when 1-byte-per-pixel formats are used, in which case 4 rows are recommended. Single depth slices per call are handled efficiently. It is recommended but not necessary to provide references and strides which are 128-byte aligned. </p><p> When reading from sub mipmap levels, it is recommended to use larger width and heights than described above. This is because small mipmap levels may actually be stored within a larger block of memory, with an opaque amount of offseting which can interfere with alignment to cache lines. </p>
        /// </remarks>
        /// <doc-id>dn912873</doc-id>
        /// <unmanaged>void ID3D11Device3::ReadFromSubresource([In, Value] void* pDstData,[In] unsigned int DstRowPitch,[In] unsigned int DstDepthPitch,[In] ID3D11Resource* pSrcResource,[In] unsigned int SrcSubresource,[In, Optional] const D3D11_BOX* pSrcBox)</unmanaged>
        /// <unmanaged-short>ID3D11Device3::ReadFromSubresource</unmanaged-short>
        public unsafe void ReadFromSubresource(System.IntPtr dstDataRef, System.Int32 dstRowPitch, System.Int32 dstDepthPitch, SharpDX.Direct3D11.Resource srcResourceRef, System.Int32 srcSubresource, SharpDX.Direct3D11.ResourceRegion? srcBoxRef)
        {
            System.IntPtr srcResourceRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.ResourceRegion srcBoxRef_;
            srcResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(srcResourceRef);
            if (srcBoxRef != null)
                srcBoxRef_ = srcBoxRef.Value;
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)dstDataRef, dstRowPitch, dstDepthPitch, (void *)srcResourceRef_, srcSubresource, srcBoxRef == null ? (void *)0 : &srcBoxRef_, (*(void ***)this._nativePointer)[64]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("8992ab71-02e6-4b8d-ba48-b056dcda42c4")]
    public partial class Device4 : SharpDX.Direct3D11.Device3
    {
        public Device4(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device4(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device4(nativePtr);
        /// <summary>
        /// <p> Registers the "device removed" event and indicates when a Direct3D device has become removed for any reason, using an asynchronous notification mechanism. </p>
        /// </summary>
        /// <param name = "hEvent"><dd>  <p> The handle to the "device removed" event. </p> </dd></param>
        /// <returns><dd>  <p> A reference to information about the "device removed" event, which can be used in <strong>UnregisterDeviceRemoved</strong> to unregister the event. </p> </dd></returns>
        /// <remarks>
        /// <p>Indicates when a Direct3D device has become removed for any reason, using an asynchronous notification mechanism, rather than as an <see cref = "SharpDX.Result"/> from <strong>Present</strong>. The reason for device removal can be retrieved using <strong>ID3D11Device::GetDeviceRemovedReason</strong> after being notified of the occurrence.</p><p> Applications register and un-register a Win32 event handle with a particular device. That event handle will be signaled when the device becomes removed. A poll into the device's <strong>ID3D11Device::GetDeviceRemovedReason</strong> method indicates that the device is removed. </p><p> <strong>ISignalableNotifier</strong> or <strong>SetThreadpoolWait</strong> can be used by UWP apps. </p><p> When the graphics device is lost, the app or title will receive the graphics event, so that the app or title knows that its graphics device is no longer valid and it is safe for the app or title to re-create its DirectX devices. In response to this event, the app or title needs to re-create its rendering device  and pass it into a SetRenderingDevice  call on the composition graphics device objects. </p><p> After setting this new rendering device, the app or title needs to redraw content of all the pre-existing surfaces  after the composition graphics device's <strong>OnRenderingDeviceReplaced</strong> event is fired. </p><p> This method supports Composition for device loss. </p><p> The event is not signaled when it is most ideal to re-create. So, instead, we recommend iterating through the adapter ordinals and creating the first ordinal that will succeed. </p><p> The application can register an event with the device. The application will be signaled when the device becomes removed. </p><p> If the device is already removed, calls to <strong>RegisterDeviceRemovedEvent</strong> will signal the event immediately. No device-removed error code will be returned from <strong>RegisterDeviceRemovedEvent</strong>. </p><p> Each "device removed" event is never signaled, or is signaled only once. These events are not signaled during device destruction. These events are unregistered during destruction. </p><p> The semantics of <strong>RegisterDeviceRemovedEvent</strong> are similar to <strong>IDXGIFactory2::RegisterOcclusionStatusEvent</strong>. </p>
        /// </remarks>
        /// <doc-id>mt589890</doc-id>
        /// <unmanaged>HRESULT ID3D11Device4::RegisterDeviceRemovedEvent([In] void* hEvent,[Out] DWORD* pdwCookie)</unmanaged>
        /// <unmanaged-short>ID3D11Device4::RegisterDeviceRemovedEvent</unmanaged-short>
        public unsafe System.Int32 RegisterDeviceRemovedEvent(System.IntPtr hEvent)
        {
            System.Int32 dwCookieRef;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)hEvent, &dwCookieRef, (*(void ***)this._nativePointer)[65]);
            __result__.CheckError();
            return dwCookieRef;
        }

        /// <summary>
        /// <p> Unregisters the "device removed" event. </p>
        /// </summary>
        /// <param name = "dwCookie"><dd>  <p> Information about the "device removed" event, retrieved during a successful <strong>RegisterDeviceRemovedEvent</strong> call. </p> </dd></param>
        /// <remarks>
        /// <p> See <strong>RegisterDeviceRemovedEvent</strong>. </p>
        /// </remarks>
        /// <doc-id>mt589892</doc-id>
        /// <unmanaged>void ID3D11Device4::UnregisterDeviceRemoved([In] DWORD dwCookie)</unmanaged>
        /// <unmanaged-short>ID3D11Device4::UnregisterDeviceRemoved</unmanaged-short>
        public unsafe void UnregisterDeviceRemoved(System.Int32 dwCookie)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, dwCookie, (*(void ***)this._nativePointer)[66]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("8ffde202-a0e7-45df-9e01-e837801b5ea0")]
    public partial class Device5 : SharpDX.Direct3D11.Device4
    {
        public Device5(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device5(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device5(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "hFence">No documentation.</param>
        /// <param name = "returnedInterface">No documentation.</param>
        /// <param name = "fenceOut">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D11Device5::OpenSharedFence([In] void* hFence,[In] const GUID&amp; ReturnedInterface,[Out, Optional] void** ppFence)</unmanaged>
        /// <unmanaged-short>ID3D11Device5::OpenSharedFence</unmanaged-short>
        internal unsafe void OpenSharedFence(System.IntPtr hFence, System.Guid returnedInterface, out System.IntPtr fenceOut)
        {
            SharpDX.Result __result__;
            fixed (void *fenceOut_ = &fenceOut)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)hFence, &returnedInterface, fenceOut_, (*(void ***)this._nativePointer)[67]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>The device interface represents a virtual adapter; it is used to create resources. <strong><see cref = "SharpDX.Direct3D11.Device5"/></strong> adds new methods to those in <strong><see cref = "SharpDX.Direct3D11.Device4"/></strong>.</p><strong>Note</strong>??This interface, introduced in the Windows 10 Creators Update, is the latest version of the <strong><see cref = "SharpDX.Direct3D11.Device"/></strong> interface. Applications targetting Windows 10 Creators Update should use this interface instead of earlier versions.?
        /// </summary>
        /// <param name = "initialValue">No documentation.</param>
        /// <param name = "flags">No documentation.</param>
        /// <param name = "returnedInterface">No documentation.</param>
        /// <param name = "fenceOut">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>mt492478</doc-id>
        /// <unmanaged>HRESULT ID3D11Device5::CreateFence([In] unsigned longlong InitialValue,[In] D3D11_FENCE_FLAG Flags,[In] const GUID&amp; ReturnedInterface,[Out, Fast] void** ppFence)</unmanaged>
        /// <unmanaged-short>ID3D11Device5::CreateFence</unmanaged-short>
        internal unsafe void CreateFence(System.Int64 initialValue, SharpDX.Direct3D11.FenceFlags flags, System.Guid returnedInterface, SharpDX.Direct3D11.Fence fenceOut)
        {
            System.IntPtr fenceOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, initialValue, unchecked ((System.Int32)flags), &returnedInterface, &fenceOut_, (*(void ***)this._nativePointer)[68]);
            (fenceOut).NativePointer = fenceOut_;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("1841e5c8-16b0-489b-bcc8-44cfb0d5deae")]
    public partial class DeviceChild : SharpDX.ComObject
    {
        public DeviceChild(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DeviceChild(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DeviceChild(nativePtr);
        /// <summary>
        /// <p>Get a reference to the device that created this interface.</p>
        /// </summary>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one, so be sure to call ::release() on the returned reference(s) before they are freed or else you will have a memory leak.</p>
        /// </remarks>
        /// <doc-id>ff476381</doc-id>
        /// <unmanaged>GetDevice</unmanaged>
        /// <unmanaged-short>GetDevice</unmanaged-short>
        public SharpDX.Direct3D11.Device Device
        {
            get
            {
                if (this.Device__ == null)
                    GetDevice(out Device__);
                return this.Device__;
            }
        }

        protected internal SharpDX.Direct3D11.Device Device__;
        /// <summary>
        /// <p>Get a reference to the device that created this interface.</p>
        /// </summary>
        /// <param name = "deviceOut"><dd>  <p>Address of a reference to a device (see <strong><see cref = "SharpDX.Direct3D11.Device"/></strong>).</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one, so be sure to call ::release() on the returned reference(s) before they are freed or else you will have a memory leak.</p>
        /// </remarks>
        /// <doc-id>ff476381</doc-id>
        /// <unmanaged>void ID3D11DeviceChild::GetDevice([Out] ID3D11Device** ppDevice)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceChild::GetDevice</unmanaged-short>
        internal unsafe void GetDevice(out SharpDX.Direct3D11.Device deviceOut)
        {
            System.IntPtr deviceOut_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, &deviceOut_, (*(void ***)this._nativePointer)[3]);
            if (deviceOut_ != System.IntPtr.Zero)
                deviceOut = new SharpDX.Direct3D11.Device(deviceOut_);
            else
                deviceOut = null;
        }

        /// <summary>
        /// <p>Get application-defined data from a device child.</p>
        /// </summary>
        /// <param name = "guid"><dd>  <p>Guid associated with the data.</p> </dd></param>
        /// <param name = "dataSizeRef"><dd>  <p> A reference to a variable that on input contains the size, in bytes, of the buffer that <em>pData</em> points to, and on output contains the size, in bytes, of the amount of data that <strong>GetPrivateData</strong> retrieved. </p> </dd></param>
        /// <param name = "dataRef"><dd>  <p> A reference to a buffer that <strong>GetPrivateData</strong> fills with data from the device child if <em>pDataSize</em> points to a value that specifies a buffer large enough to hold the data. </p> </dd></param>
        /// <returns><p> This method returns one of the  Direct3D 11 Return Codes. </p></returns>
        /// <remarks>
        /// <p> The data stored in the device child is set by calling <strong>ID3D11DeviceChild::SetPrivateData</strong>. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476382</doc-id>
        /// <unmanaged>HRESULT ID3D11DeviceChild::GetPrivateData([In] const GUID&amp; guid,[InOut] unsigned int* pDataSize,[Out, Buffer, Optional] void* pData)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceChild::GetPrivateData</unmanaged-short>
        public unsafe SharpDX.Result GetPrivateData(System.Guid guid, ref System.Int32 dataSizeRef, System.IntPtr dataRef)
        {
            SharpDX.Result __result__;
            fixed (void *dataSizeRef_ = &dataSizeRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &guid, dataSizeRef_, (void *)dataRef, (*(void ***)this._nativePointer)[4]);
            return __result__;
        }

        /// <summary>
        /// <p>Set application-defined data to a device child and associate that data with an application-defined guid.</p>
        /// </summary>
        /// <param name = "guid"><dd>  <p>Guid associated with the data.</p> </dd></param>
        /// <param name = "dataSize"><dd>  <p>Size of the data.</p> </dd></param>
        /// <param name = "dataRef"><dd>  <p>Pointer to the data to be stored with this device child. If pData is <strong><c>null</c></strong>, DataSize must also be 0, and any data previously associated with the specified guid will be destroyed.</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>The data stored in the device child with this method can be retrieved with <strong>ID3D11DeviceChild::GetPrivateData</strong>.</p><p>The debug layer reports memory leaks by outputting a list of object interface references along with their friendly names. The default friendly name is "&lt;unnamed&gt;". You can set the friendly name so that you can determine if the corresponding object interface reference caused the leak. To set the friendly name, use the <strong>SetPrivateData</strong> method and the <strong><see cref = "DebugObjectName"/></strong> <see cref = "System.Guid"/> that is in D3Dcommon.h. For example, to give pContext a friendly name of <em>My name</em>, use the following code:</p><pre> static const char c_szName[] = "My name";
        /// hr = pContext-&gt;SetPrivateData( <see cref = "DebugObjectName"/>, sizeof( c_szName ) - 1, c_szName );
        /// </pre>
        /// </remarks>
        /// <doc-id>ff476383</doc-id>
        /// <unmanaged>HRESULT ID3D11DeviceChild::SetPrivateData([In] const GUID&amp; guid,[In] unsigned int DataSize,[In, Buffer, Optional] const void* pData)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceChild::SetPrivateData</unmanaged-short>
        public unsafe void SetPrivateData(System.Guid guid, System.Int32 dataSize, System.IntPtr dataRef)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &guid, dataSize, (void *)dataRef, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Associate an <see cref = "SharpDX.IUnknown"/>-derived interface with this device child and associate that interface with an application-defined guid.</p>
        /// </summary>
        /// <param name = "guid"><dd>  <p>Guid associated with the interface.</p> </dd></param>
        /// <param name = "dataRef"><dd>  <p>Pointer to an <see cref = "SharpDX.IUnknown"/>-derived interface to be associated with the device child.</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>When this method is called ::addref() will be called on the <see cref = "SharpDX.IUnknown"/>-derived interface, and when the device child is detroyed ::release() will be called on the <see cref = "SharpDX.IUnknown"/>-derived interface.</p>
        /// </remarks>
        /// <doc-id>ff476384</doc-id>
        /// <unmanaged>HRESULT ID3D11DeviceChild::SetPrivateDataInterface([In] const GUID&amp; guid,[In, Optional] const IUnknown* pData)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceChild::SetPrivateDataInterface</unmanaged-short>
        public unsafe void SetPrivateDataInterface(System.Guid guid, SharpDX.IUnknown dataRef)
        {
            System.IntPtr dataRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            dataRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(dataRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &guid, (void *)dataRef_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("c0bfa96c-e089-44fb-8eaf-26f8796190da")]
    public partial class DeviceContext : SharpDX.Direct3D11.DeviceChild
    {
        public DeviceContext(System.IntPtr nativePtr): base (nativePtr)
        {
            VertexShader = new SharpDX.Direct3D11.VertexShaderStage(nativePtr);
            PixelShader = new SharpDX.Direct3D11.PixelShaderStage(nativePtr);
            InputAssembler = new SharpDX.Direct3D11.InputAssemblerStage(nativePtr);
            GeometryShader = new SharpDX.Direct3D11.GeometryShaderStage(nativePtr);
            OutputMerger = new SharpDX.Direct3D11.OutputMergerStage(nativePtr);
            StreamOutput = new SharpDX.Direct3D11.StreamOutputStage(nativePtr);
            Rasterizer = new SharpDX.Direct3D11.RasterizerStage(nativePtr);
            HullShader = new SharpDX.Direct3D11.HullShaderStage(nativePtr);
            DomainShader = new SharpDX.Direct3D11.DomainShaderStage(nativePtr);
            ComputeShader = new SharpDX.Direct3D11.ComputeShaderStage(nativePtr);
        }

        public static explicit operator DeviceContext(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DeviceContext(nativePtr);
                ///<summary>Update nested inner interfaces pointer</summary>
        protected override void NativePointerUpdated(System.IntPtr oldPointer)
        {
            base.NativePointerUpdated(oldPointer);
            if (this.VertexShader == null)
                this.VertexShader = new SharpDX.Direct3D11.VertexShaderStage(System.IntPtr.Zero);
            this.VertexShader.NativePointer = this.NativePointer;
            if (this.PixelShader == null)
                this.PixelShader = new SharpDX.Direct3D11.PixelShaderStage(System.IntPtr.Zero);
            this.PixelShader.NativePointer = this.NativePointer;
            if (this.InputAssembler == null)
                this.InputAssembler = new SharpDX.Direct3D11.InputAssemblerStage(System.IntPtr.Zero);
            this.InputAssembler.NativePointer = this.NativePointer;
            if (this.GeometryShader == null)
                this.GeometryShader = new SharpDX.Direct3D11.GeometryShaderStage(System.IntPtr.Zero);
            this.GeometryShader.NativePointer = this.NativePointer;
            if (this.OutputMerger == null)
                this.OutputMerger = new SharpDX.Direct3D11.OutputMergerStage(System.IntPtr.Zero);
            this.OutputMerger.NativePointer = this.NativePointer;
            if (this.StreamOutput == null)
                this.StreamOutput = new SharpDX.Direct3D11.StreamOutputStage(System.IntPtr.Zero);
            this.StreamOutput.NativePointer = this.NativePointer;
            if (this.Rasterizer == null)
                this.Rasterizer = new SharpDX.Direct3D11.RasterizerStage(System.IntPtr.Zero);
            this.Rasterizer.NativePointer = this.NativePointer;
            if (this.HullShader == null)
                this.HullShader = new SharpDX.Direct3D11.HullShaderStage(System.IntPtr.Zero);
            this.HullShader.NativePointer = this.NativePointer;
            if (this.DomainShader == null)
                this.DomainShader = new SharpDX.Direct3D11.DomainShaderStage(System.IntPtr.Zero);
            this.DomainShader.NativePointer = this.NativePointer;
            if (this.ComputeShader == null)
                this.ComputeShader = new SharpDX.Direct3D11.ComputeShaderStage(System.IntPtr.Zero);
            this.ComputeShader.NativePointer = this.NativePointer;
        }

                ///<summary>Inner interface giving access to VertexShaderStage methods.</summary>
        public SharpDX.Direct3D11.VertexShaderStage VertexShader
        {
            get;
            private set;
        }

                ///<summary>Inner interface giving access to PixelShaderStage methods.</summary>
        public SharpDX.Direct3D11.PixelShaderStage PixelShader
        {
            get;
            private set;
        }

                ///<summary>Inner interface giving access to InputAssemblerStage methods.</summary>
        public SharpDX.Direct3D11.InputAssemblerStage InputAssembler
        {
            get;
            private set;
        }

                ///<summary>Inner interface giving access to GeometryShaderStage methods.</summary>
        public SharpDX.Direct3D11.GeometryShaderStage GeometryShader
        {
            get;
            private set;
        }

                ///<summary>Inner interface giving access to OutputMergerStage methods.</summary>
        public SharpDX.Direct3D11.OutputMergerStage OutputMerger
        {
            get;
            private set;
        }

                ///<summary>Inner interface giving access to StreamOutputStage methods.</summary>
        public SharpDX.Direct3D11.StreamOutputStage StreamOutput
        {
            get;
            private set;
        }

                ///<summary>Inner interface giving access to RasterizerStage methods.</summary>
        public SharpDX.Direct3D11.RasterizerStage Rasterizer
        {
            get;
            private set;
        }

                ///<summary>Inner interface giving access to HullShaderStage methods.</summary>
        public SharpDX.Direct3D11.HullShaderStage HullShader
        {
            get;
            private set;
        }

                ///<summary>Inner interface giving access to DomainShaderStage methods.</summary>
        public SharpDX.Direct3D11.DomainShaderStage DomainShader
        {
            get;
            private set;
        }

                ///<summary>Inner interface giving access to ComputeShaderStage methods.</summary>
        public SharpDX.Direct3D11.ComputeShaderStage ComputeShader
        {
            get;
            private set;
        }

        /// <summary>
        /// <p>Gets the type of device context.</p>
        /// </summary>
        /// <doc-id>ff476431</doc-id>
        /// <unmanaged>GetType</unmanaged>
        /// <unmanaged-short>GetType</unmanaged-short>
        public SharpDX.Direct3D11.DeviceContextType TypeInfo
        {
            get => GetTypeInfo();
        }

        /// <summary>
        /// <p>Gets the initialization flags associated with the current deferred context.</p>
        /// </summary>
        /// <remarks>
        /// <p>The GetContextFlags method gets the flags that were supplied to the <em>ContextFlags</em> parameter of <strong>ID3D11Device::CreateDeferredContext</strong>; however, the context flag is reserved for future use.</p>
        /// </remarks>
        /// <doc-id>ff476427</doc-id>
        /// <unmanaged>GetContextFlags</unmanaged>
        /// <unmanaged-short>GetContextFlags</unmanaged-short>
        public System.Int32 ContextFlags
        {
            get => GetContextFlags();
        }

        /// <summary>
        /// <p>Draw indexed, non-instanced primitives.</p>
        /// </summary>
        /// <param name = "indexCount"><dd>  <p>Number of indices to draw.</p> </dd></param>
        /// <param name = "startIndexLocation"><dd>  <p>The location of the first index read by the GPU from the index buffer.</p> </dd></param>
        /// <param name = "baseVertexLocation"><dd>  <p>A value added to each index before reading a vertex from the vertex buffer.</p> </dd></param>
        /// <remarks>
        /// <p>A draw API submits work to the rendering pipeline.</p><p>If the sum of both indices is negative, the result of the function call is undefined.</p>
        /// </remarks>
        /// <doc-id>ff476409</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::DrawIndexed([In] unsigned int IndexCount,[In] unsigned int StartIndexLocation,[In] int BaseVertexLocation)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::DrawIndexed</unmanaged-short>
        public unsafe void DrawIndexed(System.Int32 indexCount, System.Int32 startIndexLocation, System.Int32 baseVertexLocation)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, indexCount, startIndexLocation, baseVertexLocation, (*(void ***)this._nativePointer)[12]);
        }

        /// <summary>
        /// <p>Draw non-indexed, non-instanced primitives.</p>
        /// </summary>
        /// <param name = "vertexCount"><dd>  <p>Number of vertices to draw.</p> </dd></param>
        /// <param name = "startVertexLocation"><dd>  <p>Index of the first vertex, which is usually an offset in a vertex buffer.</p> </dd></param>
        /// <remarks>
        /// <p><strong>Draw</strong> submits work to the rendering pipeline.</p><p>The vertex data for a draw call normally comes from a vertex buffer that is bound to the pipeline.</p><p>Even without any vertex buffer bound to the pipeline, you can generate your own vertex data in your vertex shader by using the <strong>SV_VertexID</strong> system-value semantic to determine the current vertex that the runtime is processing.</p>
        /// </remarks>
        /// <doc-id>ff476407</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::Draw([In] unsigned int VertexCount,[In] unsigned int StartVertexLocation)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::Draw</unmanaged-short>
        public unsafe void Draw(System.Int32 vertexCount, System.Int32 startVertexLocation)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, vertexCount, startVertexLocation, (*(void ***)this._nativePointer)[13]);
        }

        /// <summary>
        /// <p> Gets a reference to the data contained in a subresource, and denies the GPU access to that subresource. </p>
        /// </summary>
        /// <param name = "resourceRef">No documentation.</param>
        /// <param name = "subresource">No documentation.</param>
        /// <param name = "mapType">No documentation.</param>
        /// <param name = "mapFlags">No documentation.</param>
        /// <param name = "mappedResourceRef">No documentation.</param>
        /// <returns><p> This method returns one of the Direct3D 11 Return Codes. </p><p> This method also returns <strong><see cref = "WasStillDrawing"/></strong> if <em>MapFlags</em> specifies <strong>D3D11_MAP_FLAG_DO_NOT_WAIT</strong> and the GPU is not yet finished with the resource. </p><p> This method also returns <strong><see cref = "DeviceRemoved"/></strong> if <em>MapType</em> allows any CPU read access and the video card has been removed. </p><p> For more information about these error codes, see DXGI_ERROR. </p></returns>
        /// <remarks>
        /// <p> If you call <strong>Map</strong> on a deferred context, you can only pass <strong>D3D11_MAP_WRITE_DISCARD</strong>, <strong>D3D11_MAP_WRITE_NO_OVERWRITE</strong>, or both to the <em>MapType</em> parameter. Other <strong><see cref = "SharpDX.Direct3D11.MapMode"/></strong>-typed values are not supported for a deferred context. </p><strong>Note</strong>?? The Direct3D 11.1 runtime, which is available starting with Windows?8, enables  mapping dynamic constant buffers and shader resource views (SRVs) of dynamic buffers with <strong>D3D11_MAP_WRITE_NO_OVERWRITE</strong>.  The Direct3D 11 and earlier runtimes limited mapping to vertex or index buffers. To determine if a Direct3D device supports these features, call <strong>ID3D11Device::CheckFeatureSupport</strong> with <strong>D3D11_FEATURE_D3D11_OPTIONS</strong>. <strong>CheckFeatureSupport</strong> fills members of a <strong><see cref = "SharpDX.Direct3D11.FeatureDataD3D11Options"/></strong> structure with the device's features. The relevant members here are <strong>MapNoOverwriteOnDynamicConstantBuffer</strong> and <strong>MapNoOverwriteOnDynamicBufferSRV</strong>.?<p> For info about how to use <strong>Map</strong>, see How to: Use dynamic resources. </p>
        /// </remarks>
        /// <doc-id>ff476457</doc-id>
        /// <unmanaged>HRESULT ID3D11DeviceContext::Map([In] ID3D11Resource* pResource,[In] unsigned int Subresource,[In] D3D11_MAP MapType,[In] unsigned int MapFlags,[Out, Optional] D3D11_MAPPED_SUBRESOURCE* pMappedResource)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::Map</unmanaged-short>
        internal unsafe SharpDX.Result MapSubresource(SharpDX.Direct3D11.Resource resourceRef, System.Int32 subresource, SharpDX.Direct3D11.MapMode mapType, SharpDX.Direct3D11.MapFlags mapFlags, out SharpDX.DataBox mappedResourceRef)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            mappedResourceRef = default (SharpDX.DataBox);
            SharpDX.Result __result__;
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(resourceRef);
            fixed (void *mappedResourceRef_ = &mappedResourceRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)resourceRef_, subresource, unchecked ((System.Int32)mapType), unchecked ((System.Int32)mapFlags), mappedResourceRef_, (*(void ***)this._nativePointer)[14]);
            return __result__;
        }

        /// <summary>
        /// <p>Invalidate the reference to a resource and reenable the GPU's access to that resource.</p>
        /// </summary>
        /// <param name = "resourceRef"><dd>  <p> A reference to a <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong> interface. </p> </dd></param>
        /// <param name = "subresource"><dd>  <p>A subresource to be unmapped.</p> </dd></param>
        /// <remarks>
        /// <p> For info about how to use <strong>Unmap</strong>, see How to: Use dynamic resources. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476485</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::Unmap([In] ID3D11Resource* pResource,[In] unsigned int Subresource)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::Unmap</unmanaged-short>
        public unsafe void UnmapSubresource(SharpDX.Direct3D11.Resource resourceRef, System.Int32 subresource)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(resourceRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)resourceRef_, subresource, (*(void ***)this._nativePointer)[15]);
        }

        /// <summary>
        /// <p>Draw indexed, instanced primitives.</p>
        /// </summary>
        /// <param name = "indexCountPerInstance"><dd>  <p>Number of indices read from the index buffer for each instance.</p> </dd></param>
        /// <param name = "instanceCount"><dd>  <p>Number of instances to draw.</p> </dd></param>
        /// <param name = "startIndexLocation"><dd>  <p>The location of the first index read by the GPU from the index buffer.</p> </dd></param>
        /// <param name = "baseVertexLocation"><dd>  <p>A value added to each index before reading a vertex from the vertex buffer.</p> </dd></param>
        /// <param name = "startInstanceLocation"><dd>  <p>A value added to each index before reading per-instance data from a vertex buffer.</p> </dd></param>
        /// <remarks>
        /// <p>A draw API submits work to the rendering pipeline.</p><p>Instancing may extend performance by reusing the same geometry to draw multiple objects in a scene. One example of instancing could be  to draw the same object with different positions and colors. Instancing requires multiple vertex buffers: at least one for per-vertex data  and a second buffer for per-instance data.</p>
        /// </remarks>
        /// <doc-id>ff476410</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::DrawIndexedInstanced([In] unsigned int IndexCountPerInstance,[In] unsigned int InstanceCount,[In] unsigned int StartIndexLocation,[In] int BaseVertexLocation,[In] unsigned int StartInstanceLocation)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::DrawIndexedInstanced</unmanaged-short>
        public unsafe void DrawIndexedInstanced(System.Int32 indexCountPerInstance, System.Int32 instanceCount, System.Int32 startIndexLocation, System.Int32 baseVertexLocation, System.Int32 startInstanceLocation)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, indexCountPerInstance, instanceCount, startIndexLocation, baseVertexLocation, startInstanceLocation, (*(void ***)this._nativePointer)[20]);
        }

        /// <summary>
        /// <p>Draw non-indexed, instanced primitives.</p>
        /// </summary>
        /// <param name = "vertexCountPerInstance"><dd>  <p>Number of vertices to draw.</p> </dd></param>
        /// <param name = "instanceCount"><dd>  <p>Number of instances to draw.</p> </dd></param>
        /// <param name = "startVertexLocation"><dd>  <p>Index of the first vertex.</p> </dd></param>
        /// <param name = "startInstanceLocation"><dd>  <p>A value added to each index before reading per-instance data from a vertex buffer.</p> </dd></param>
        /// <remarks>
        /// <p>A draw API submits work to the rendering pipeline.</p><p>Instancing may extend performance by reusing the same geometry to draw multiple objects in a scene. One example of instancing could be  to draw the same object with different positions and colors.</p><p>The vertex data for an instanced draw call normally comes from a vertex buffer that is bound to the pipeline.  However, you could also provide the vertex data from a shader that has instanced data identified with a system-value semantic (SV_InstanceID).</p>
        /// </remarks>
        /// <doc-id>ff476412</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::DrawInstanced([In] unsigned int VertexCountPerInstance,[In] unsigned int InstanceCount,[In] unsigned int StartVertexLocation,[In] unsigned int StartInstanceLocation)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::DrawInstanced</unmanaged-short>
        public unsafe void DrawInstanced(System.Int32 vertexCountPerInstance, System.Int32 instanceCount, System.Int32 startVertexLocation, System.Int32 startInstanceLocation)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, vertexCountPerInstance, instanceCount, startVertexLocation, startInstanceLocation, (*(void ***)this._nativePointer)[21]);
        }

        /// <summary>
        /// <p>Mark the beginning of a series of commands.</p>
        /// </summary>
        /// <param name = "asyncRef"><dd>  <p>A reference to an <strong><see cref = "SharpDX.Direct3D11.Asynchronous"/></strong> interface.</p> </dd></param>
        /// <remarks>
        /// <p>Use <strong>ID3D11DeviceContext::End</strong> to mark the ending of the series of commands.</p>
        /// </remarks>
        /// <doc-id>ff476386</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::Begin([In] ID3D11Asynchronous* pAsync)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::Begin</unmanaged-short>
        public unsafe void Begin(SharpDX.Direct3D11.Asynchronous asyncRef)
        {
            System.IntPtr asyncRef_ = System.IntPtr.Zero;
            asyncRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Asynchronous>(asyncRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)asyncRef_, (*(void ***)this._nativePointer)[27]);
        }

        /// <summary>
        /// <p>Mark the end of a series of commands.</p>
        /// </summary>
        /// <param name = "asyncRef"><dd>  <p>A reference to an <strong><see cref = "SharpDX.Direct3D11.Asynchronous"/></strong> interface.</p> </dd></param>
        /// <remarks>
        /// <p>Use <strong>ID3D11DeviceContext::Begin</strong> to mark the beginning of the series of commands.</p>
        /// </remarks>
        /// <doc-id>ff476422</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::End([In] ID3D11Asynchronous* pAsync)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::End</unmanaged-short>
        public unsafe void End(SharpDX.Direct3D11.Asynchronous asyncRef)
        {
            System.IntPtr asyncRef_ = System.IntPtr.Zero;
            asyncRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Asynchronous>(asyncRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)asyncRef_, (*(void ***)this._nativePointer)[28]);
        }

        /// <summary>
        /// <p>Get data from the graphics processing unit (GPU) asynchronously.</p>
        /// </summary>
        /// <param name = "asyncRef"><dd>  <p>A reference to an <strong><see cref = "SharpDX.Direct3D11.Asynchronous"/></strong> interface for the object about which <strong>GetData</strong> retrieves data.</p> </dd></param>
        /// <param name = "dataRef"><dd>  <p>Address of memory that will receive the data. If <strong><c>null</c></strong>, <strong>GetData</strong> will be used only to check status. The type of data output depends on the type of asynchronous interface.</p> </dd></param>
        /// <param name = "dataSize"><dd>  <p>Size of the data to retrieve or 0. Must be 0 when <em>pData</em> is <strong><c>null</c></strong>.</p> </dd></param>
        /// <param name = "getDataFlags"><dd>  <p>Optional flags. Can be 0 or any combination of the flags enumerated by <strong><see cref = "SharpDX.Direct3D11.AsynchronousFlags"/></strong>.</p> </dd></param>
        /// <returns><p>This method returns one of the Direct3D 11 Return Codes. A return value of <see cref = "SharpDX.Result.Ok"/> indicates that the data at <em>pData</em> is available for the calling application to access. A return value of S_FALSE indicates that the data is not yet available. If the data is not yet available, the application must call <strong>GetData</strong> until the data is available.</p></returns>
        /// <remarks>
        /// <p>Queries in a deferred context are limited to predicated drawing. That is, you cannot call <strong>ID3D11DeviceContext::GetData</strong> on a deferred context to get data about a query; you can only call <strong>GetData</strong> on the immediate context to get data about a query. For predicated drawing, the results of a predication-type query are used by the GPU and not returned to an application. For more information about predication and predicated drawing, see <strong>D3D11DeviceContext::SetPredication</strong>.</p><p><strong>GetData</strong> retrieves the data that the runtime collected between calls to <strong>ID3D11DeviceContext::Begin</strong> and <strong>ID3D11DeviceContext::End</strong>.  Certain queries only require a call to <strong>ID3D11DeviceContext::End</strong> in which case the data returned by <strong>GetData</strong> is accurate up to the last call to <strong>ID3D11DeviceContext::End</strong>. For information about the queries that only require a call to <strong>ID3D11DeviceContext::End</strong> and about the type of data that <strong>GetData</strong> retrieves for each query, see <strong><see cref = "SharpDX.Direct3D11.QueryType"/></strong>.</p><p>If <em>DataSize</em> is 0, <strong>GetData</strong> is only used to check status.</p><p>An application gathers counter data by calling <strong>ID3D11DeviceContext::Begin</strong>, issuing some graphics commands, calling <strong>ID3D11DeviceContext::End</strong>, and then calling <strong>ID3D11DeviceContext::GetData</strong> to get data about what happened in between the <strong>Begin</strong> and <strong>End</strong> calls. For information about performance counter types, see <strong><see cref = "SharpDX.Direct3D11.CounterKind"/></strong>. </p>
        /// </remarks>
        /// <doc-id>ff476428</doc-id>
        /// <unmanaged>HRESULT ID3D11DeviceContext::GetData([In] ID3D11Asynchronous* pAsync,[Out, Buffer, Optional] void* pData,[In] unsigned int DataSize,[In] unsigned int GetDataFlags)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::GetData</unmanaged-short>
        internal unsafe SharpDX.Result GetDataInternal(SharpDX.Direct3D11.Asynchronous asyncRef, System.IntPtr dataRef, System.Int32 dataSize, SharpDX.Direct3D11.AsynchronousFlags getDataFlags)
        {
            System.IntPtr asyncRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            asyncRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Asynchronous>(asyncRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)asyncRef_, (void *)dataRef, dataSize, unchecked ((System.Int32)getDataFlags), (*(void ***)this._nativePointer)[29]);
            return __result__;
        }

        /// <summary>
        /// <p>Set a rendering predicate.</p>
        /// </summary>
        /// <param name = "predicateRef"><dd>  <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.Predicate"/></strong> interface that represents the rendering predicate. A <strong><c>null</c></strong> value indicates "no" predication; in this case, the value of <em>PredicateValue</em> is irrelevant but will be preserved for <strong>ID3D11DeviceContext::GetPredication</strong>.</p> </dd></param>
        /// <param name = "predicateValue"><dd>  <p>If <strong>TRUE</strong>, rendering will be affected by when the predicate's conditions are met. If <strong><see cref = "SharpDX.Result.False"/></strong>, rendering will be affected when the conditions are not met.</p> </dd></param>
        /// <remarks>
        /// <p>The predicate must be in the "issued" or "signaled" state to be used for predication. While the predicate is set for predication, calls to <strong>ID3D11DeviceContext::Begin</strong> and <strong>ID3D11DeviceContext::End</strong> are invalid.</p><p>Use this method to denote that subsequent rendering and resource manipulation commands are not actually performed if the resulting predicate data of the predicate is equal to the <em>PredicateValue</em>. However, some predicates are only hints, so they may not actually prevent operations from being performed. </p><p>The primary usefulness of predication is to allow an application to issue rendering and resource manipulation commands without taking the performance hit of spinning, waiting for <strong>ID3D11DeviceContext::GetData</strong> to return. So, predication can occur while <strong>ID3D11DeviceContext::GetData</strong> returns <strong>S_FALSE</strong>. Another way to think of it: an application can also use predication as a fallback, if it is possible that <strong>ID3D11DeviceContext::GetData</strong> returns <strong>S_FALSE</strong>. If <strong>ID3D11DeviceContext::GetData</strong> returns <strong><see cref = "SharpDX.Result.Ok"/></strong>, the application can skip calling the rendering and resource manipulation commands manually with it's own application logic.</p><p>Rendering and resource manipulation commands for Direct3D?11 include these Draw, Dispatch, Copy, Update, Clear, Generate, and Resolve operations.</p><ul> <li> <strong>Draw</strong> </li> <li> <strong>DrawAuto</strong> </li> <li> <strong>DrawIndexed</strong> </li> <li> <strong>DrawIndexedInstanced</strong> </li> <li> <strong>DrawIndexedInstancedIndirect</strong> </li> <li> <strong>DrawInstanced</strong> </li> <li> <strong>DrawInstancedIndirect</strong> </li> <li> <strong>Dispatch</strong> </li> <li> <strong>DispatchIndirect</strong> </li> <li> <strong>CopyResource</strong> </li> <li> <strong>CopyStructureCount</strong> </li> <li> <strong>CopySubresourceRegion</strong> </li> <li> <strong>CopySubresourceRegion1</strong> </li> <li> <strong>CopyTiles</strong> </li> <li> <strong>CopyTileMappings</strong> </li> <li> <strong>UpdateSubresource</strong> </li> <li> <strong>UpdateSubresource1</strong> </li> <li> <strong>UpdateTiles</strong> </li> <li> <strong>UpdateTileMappings</strong> </li> <li> <strong>ClearRenderTargetView</strong> </li> <li> <strong>ClearUnorderedAccessViewFloat</strong> </li> <li> <strong>ClearUnorderedAccessViewUint</strong> </li> <li> <strong>ClearView</strong> </li> <li> <strong>ClearDepthStencilView</strong> </li> <li> <strong>GenerateMips</strong> </li> <li> <strong>ResolveSubresource</strong> </li> </ul><p>You can set a rendering predicate on an immediate or a deferred context. For info about immediate and deferred contexts, see Immediate and Deferred Rendering. </p>
        /// </remarks>
        /// <doc-id>ff476481</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::SetPredication([In, Optional] ID3D11Predicate* pPredicate,[In] BOOL PredicateValue)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::SetPredication</unmanaged-short>
        public unsafe void SetPredication(SharpDX.Direct3D11.Predicate predicateRef, SharpDX.Mathematics.Interop.RawBool predicateValue)
        {
            System.IntPtr predicateRef_ = System.IntPtr.Zero;
            predicateRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Predicate>(predicateRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid0(this._nativePointer, (void *)predicateRef_, predicateValue, (*(void ***)this._nativePointer)[30]);
        }

        /// <summary>
        /// <p>Draw geometry of an unknown size.</p>
        /// </summary>
        /// <remarks>
        /// <p>A draw API submits work to the rendering pipeline. This API submits work of an unknown size that was processed by the input assembler, vertex shader, and stream-output stages;  the work may or may not have gone through the geometry-shader stage.</p><p>After data has been streamed out to stream-output stage buffers, those buffers can be again bound to the Input Assembler stage at input slot 0 and DrawAuto will draw them without the application needing to know the amount of data that was written to the buffers. A measurement of the amount of data written to the SO stage buffers is maintained internally when the data is streamed out. This means that the CPU does not need to fetch the measurement before re-binding the data that was streamed as input data. Although this amount is tracked internally, it is still the responsibility of applications to use input layouts to describe the format of the data in the SO stage buffers so that the layouts are available when the buffers are again bound to the input assembler.</p><p>The following diagram shows the DrawAuto process.</p><p></p><p>Calling DrawAuto does not change the state of the streaming-output buffers that were bound again as inputs.</p><p>DrawAuto only works when drawing with one input buffer bound as an input to the IA stage at slot 0. Applications must create the SO buffer resource with both binding flags, <strong>D3D11_BIND_VERTEX_BUFFER</strong> and <strong>D3D11_BIND_STREAM_OUTPUT</strong>.</p><p>This API does not support indexing or instancing.</p><p>If an application needs to retrieve the size of the streaming-output buffer, it can query for statistics on streaming output by using <strong>D3D11_QUERY_SO_STATISTICS</strong>.</p>
        /// </remarks>
        /// <doc-id>ff476408</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::DrawAuto()</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::DrawAuto</unmanaged-short>
        public unsafe void DrawAuto()
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[38]);
        }

        /// <summary>
        /// <p>Draw indexed, instanced, GPU-generated primitives.</p>
        /// </summary>
        /// <param name = "bufferForArgsRef"><dd>  <p> A reference to an <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>, which is a buffer containing the GPU generated primitives. </p> </dd></param>
        /// <param name = "alignedByteOffsetForArgs"><dd>  <p> Offset in <em>pBufferForArgs</em> to the start of the GPU generated primitives. </p> </dd></param>
        /// <remarks>
        /// <p> When an application creates a buffer that is associated with the <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong> interface that  <em>pBufferForArgs</em> points to, the application must set the <strong>D3D11_RESOURCE_MISC_DRAWINDIRECT_ARGS</strong> flag in the <strong>MiscFlags</strong> member of the <strong><see cref = "SharpDX.Direct3D11.BufferDescription"/></strong> structure that describes the buffer. To create the buffer, the application calls the <strong>ID3D11Device::CreateBuffer</strong> method and in this call passes a reference to <strong><see cref = "SharpDX.Direct3D11.BufferDescription"/></strong> in the <em>pDesc</em> parameter. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476411</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::DrawIndexedInstancedIndirect([In] ID3D11Buffer* pBufferForArgs,[In] unsigned int AlignedByteOffsetForArgs)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::DrawIndexedInstancedIndirect</unmanaged-short>
        public unsafe void DrawIndexedInstancedIndirect(SharpDX.Direct3D11.Buffer bufferForArgsRef, System.Int32 alignedByteOffsetForArgs)
        {
            System.IntPtr bufferForArgsRef_ = System.IntPtr.Zero;
            bufferForArgsRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Buffer>(bufferForArgsRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)bufferForArgsRef_, alignedByteOffsetForArgs, (*(void ***)this._nativePointer)[39]);
        }

        /// <summary>
        /// <p>Draw instanced, GPU-generated primitives.</p>
        /// </summary>
        /// <param name = "bufferForArgsRef"><dd>  <p>A reference to an <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>, which is a buffer containing the GPU generated primitives.</p> </dd></param>
        /// <param name = "alignedByteOffsetForArgs"><dd>  <p>Offset in <em>pBufferForArgs</em> to the start of the GPU generated primitives.</p> </dd></param>
        /// <remarks>
        /// <p>When an application creates a buffer that is associated with the <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong> interface that  <em>pBufferForArgs</em> points to, the application must set the <strong>D3D11_RESOURCE_MISC_DRAWINDIRECT_ARGS</strong> flag in the <strong>MiscFlags</strong> member of the <strong><see cref = "SharpDX.Direct3D11.BufferDescription"/></strong> structure that describes the buffer. To create the buffer, the application calls the <strong>ID3D11Device::CreateBuffer</strong> method and in this call passes a reference to <strong><see cref = "SharpDX.Direct3D11.BufferDescription"/></strong> in the <em>pDesc</em> parameter.</p>
        /// </remarks>
        /// <doc-id>ff476413</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::DrawInstancedIndirect([In] ID3D11Buffer* pBufferForArgs,[In] unsigned int AlignedByteOffsetForArgs)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::DrawInstancedIndirect</unmanaged-short>
        public unsafe void DrawInstancedIndirect(SharpDX.Direct3D11.Buffer bufferForArgsRef, System.Int32 alignedByteOffsetForArgs)
        {
            System.IntPtr bufferForArgsRef_ = System.IntPtr.Zero;
            bufferForArgsRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Buffer>(bufferForArgsRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)bufferForArgsRef_, alignedByteOffsetForArgs, (*(void ***)this._nativePointer)[40]);
        }

        /// <summary>
        /// <p>Execute a command list from a thread group.</p>
        /// </summary>
        /// <param name = "threadGroupCountX"><dd>  <p>The number of groups dispatched in the x direction. <em>ThreadGroupCountX</em> must be less than or equal to <see cref = "DispatchMaximumThreadGroupsPerDimension"/> (65535).</p> </dd></param>
        /// <param name = "threadGroupCountY"><dd>  <p>The number of groups dispatched in the y direction. <em>ThreadGroupCountY</em> must be less than or equal to <see cref = "DispatchMaximumThreadGroupsPerDimension"/> (65535).</p> </dd></param>
        /// <param name = "threadGroupCountZ"><dd>  <p>The number of groups dispatched in the z direction.  <em>ThreadGroupCountZ</em> must be less than or equal to <see cref = "DispatchMaximumThreadGroupsPerDimension"/> (65535).  In feature level 10 the value for <em>ThreadGroupCountZ</em> must be 1.</p> </dd></param>
        /// <remarks>
        /// <p>You call the <strong>Dispatch</strong> method to execute commands in a compute shader. A compute shader can be run on many threads in parallel, within a thread group. Index a particular thread, within a thread group using a 3D vector  given by (x,y,z).</p><p>In the following illustration, assume a thread group with 50 threads where the size of the group is given by (5,5,2). A single thread is identified from a  thread group with 50 threads in it, using the vector (4,1,1).</p><p></p><p>The following illustration shows the relationship between the parameters passed to <strong>ID3D11DeviceContext::Dispatch</strong>, Dispatch(5,3,2), the values specified in the numthreads attribute, numthreads(10,8,3), and values that will passed to the compute shader for the thread-related system values 
        /// (SV_GroupIndex,SV_DispatchThreadID,SV_GroupThreadID,SV_GroupID).</p><p></p>
        /// </remarks>
        /// <doc-id>ff476405</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::Dispatch([In] unsigned int ThreadGroupCountX,[In] unsigned int ThreadGroupCountY,[In] unsigned int ThreadGroupCountZ)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::Dispatch</unmanaged-short>
        public unsafe void Dispatch(System.Int32 threadGroupCountX, System.Int32 threadGroupCountY, System.Int32 threadGroupCountZ)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, threadGroupCountX, threadGroupCountY, threadGroupCountZ, (*(void ***)this._nativePointer)[41]);
        }

        /// <summary>
        /// <p>Execute a command list over one or more thread groups.</p>
        /// </summary>
        /// <param name = "bufferForArgsRef"><dd>  <p>A reference to an <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>, which must be loaded with data that matches the argument list for <strong>ID3D11DeviceContext::Dispatch</strong>.</p> </dd></param>
        /// <param name = "alignedByteOffsetForArgs"><dd>  <p>A byte-aligned offset between the start of the buffer and the arguments.</p> </dd></param>
        /// <remarks>
        /// <p>You call the <strong>DispatchIndirect</strong> method to execute commands in a compute shader.</p><p>When an application creates a buffer that is associated with the <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong> interface that  <em>pBufferForArgs</em> points to, the application must set the <strong>D3D11_RESOURCE_MISC_DRAWINDIRECT_ARGS</strong> flag in the <strong>MiscFlags</strong> member of the <strong><see cref = "SharpDX.Direct3D11.BufferDescription"/></strong> structure that describes the buffer. To create the buffer, the application calls the <strong>ID3D11Device::CreateBuffer</strong> method and in this call passes a reference to <strong><see cref = "SharpDX.Direct3D11.BufferDescription"/></strong> in the <em>pDesc</em> parameter.</p>
        /// </remarks>
        /// <doc-id>ff476406</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::DispatchIndirect([In] ID3D11Buffer* pBufferForArgs,[In] unsigned int AlignedByteOffsetForArgs)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::DispatchIndirect</unmanaged-short>
        public unsafe void DispatchIndirect(SharpDX.Direct3D11.Buffer bufferForArgsRef, System.Int32 alignedByteOffsetForArgs)
        {
            System.IntPtr bufferForArgsRef_ = System.IntPtr.Zero;
            bufferForArgsRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Buffer>(bufferForArgsRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)bufferForArgsRef_, alignedByteOffsetForArgs, (*(void ***)this._nativePointer)[42]);
        }

        /// <summary>
        /// <p>Copy a region from a source resource to a destination resource.</p>
        /// </summary>
        /// <param name = "dstResourceRef"><dd>  <p>A reference to the destination resource (see <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong>).</p> </dd></param>
        /// <param name = "dstSubresource"><dd>  <p>Destination subresource index.</p> </dd></param>
        /// <param name = "dstX"><dd>  <p>The x-coordinate of the upper left corner of the destination region.</p> </dd></param>
        /// <param name = "dstY"><dd>  <p>The y-coordinate of the upper left corner of the destination region. For a 1D subresource, this must be zero.</p> </dd></param>
        /// <param name = "dstZ"><dd>  <p>The z-coordinate of the upper left corner of the destination region. For a 1D or 2D subresource, this must be zero.</p> </dd></param>
        /// <param name = "srcResourceRef"><dd>  <p>A reference to the source resource (see <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong>).</p> </dd></param>
        /// <param name = "srcSubresource"><dd>  <p>Source subresource index.</p> </dd></param>
        /// <param name = "srcBoxRef"><dd>  <p>A reference to a 3D box (see <strong><see cref = "SharpDX.Direct3D11.ResourceRegion"/></strong>) that defines the source subresource that can be copied. If <strong><c>null</c></strong>, the entire source subresource is copied. The box must fit within the source resource.</p> <p>An empty box results in a no-op. A box is empty if the top value is greater than or equal to the bottom value, or the left value is greater than or equal to the right value, or the front value is greater than or equal to the back value. When the box is empty, <strong>CopySubresourceRegion</strong> doesn't perform a copy operation.</p> </dd></param>
        /// <remarks>
        /// <p>The source box must be within the size of the source resource. The destination offsets, (x, y, and z), allow the source box to be offset when writing into the destination resource; however, the dimensions of the source box and the offsets must be within the size of the resource. If you try and copy outside the destination resource or specify a source box that is larger than the source resource, the behavior of <strong>CopySubresourceRegion</strong> is undefined. If you created a device that supports the debug layer, the debug output reports an error on this invalid <strong>CopySubresourceRegion</strong> call. Invalid parameters to <strong>CopySubresourceRegion</strong> cause undefined behavior and might result in incorrect rendering, clipping, no copy, or even the removal of the rendering device.</p><p>If the resources are buffers, all coordinates are in bytes; if the resources are textures, all coordinates are in texels. <strong>D3D11CalcSubresource</strong> is a helper function for calculating subresource indexes.</p><p><strong>CopySubresourceRegion</strong> performs the copy on the GPU (similar to a memcpy by the CPU). As a consequence, the source and destination resources:</p><ul> <li>Must be different subresources (although they can be from the same resource).</li> <li>Must be the same type.</li> <li>Must have compatible DXGI formats (identical or from the same type group). For example, a DXGI_FORMAT_R32G32B32_FLOAT texture can be copied to an DXGI_FORMAT_R32G32B32_UINT texture since both of these formats are in the DXGI_FORMAT_R32G32B32_TYPELESS group. <strong>CopySubresourceRegion</strong> can copy between a few format types. For more info, see Format Conversion using Direct3D 10.1.</li> <li>May not be currently mapped.</li> </ul><p><strong>CopySubresourceRegion</strong> only supports copy; it does not support any stretch, color key, or blend. <strong>CopySubresourceRegion</strong> can reinterpret the resource data between a few format types. For more info, see Format Conversion using Direct3D 10.1.</p><p> If your app needs to copy an entire resource, we recommend to use <strong>ID3D11DeviceContext::CopyResource</strong> instead. </p><p><strong>CopySubresourceRegion</strong> is an asynchronous call, which may be added to the command-buffer queue, this attempts to remove pipeline stalls that may occur when copying data. For more information about pipeline stalls, see performance considerations.</p><strong>Note</strong>??<strong>Applies only to feature level 9_x hardware</strong> If you use <strong>ID3D11DeviceContext::UpdateSubresource</strong> or <strong>CopySubresourceRegion</strong> to copy from a staging resource to a default resource, you can corrupt the destination contents. This occurs if you pass a <strong><c>null</c></strong> source box and if the source resource has different dimensions from those of the destination resource or if you use destination offsets, (x, y, and z). In this situation, always pass a source box that is the full size of the source resource.?<strong>Note</strong>??<strong>Applies only to feature level 9_x hardware</strong> You can't use <strong>CopySubresourceRegion</strong> to copy mipmapped volume textures.?<strong>Note</strong>??<strong>Applies only to feature levels 9_x</strong> Subresources created with the D3D11_BIND_DEPTH_STENCIL flag can only be used as a source for <strong>CopySubresourceRegion</strong>.?<strong>Note</strong>??If you use <strong>CopySubresourceRegion</strong> with a depth-stencil buffer or a multisampled resource, you must copy the whole subresource. In this situation, you must pass 0 to the <em>DstX</em>, <em>DstY</em>, and <em>DstZ</em> parameters and <strong><c>null</c></strong> to the <em>pSrcBox</em> parameter. In addition, source and destination resources, which are represented by the <em>pSrcResource</em> and <em>pDstResource</em> parameters, should have identical sample count values.?
        /// </remarks>
        /// <doc-id>ff476394</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::CopySubresourceRegion([In] ID3D11Resource* pDstResource,[In] unsigned int DstSubresource,[In] unsigned int DstX,[In] unsigned int DstY,[In] unsigned int DstZ,[In] ID3D11Resource* pSrcResource,[In] unsigned int SrcSubresource,[In, Optional] const D3D11_BOX* pSrcBox)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::CopySubresourceRegion</unmanaged-short>
        internal unsafe void CopySubresourceRegion_(SharpDX.Direct3D11.Resource dstResourceRef, System.Int32 dstSubresource, System.Int32 dstX, System.Int32 dstY, System.Int32 dstZ, SharpDX.Direct3D11.Resource srcResourceRef, System.Int32 srcSubresource, SharpDX.Direct3D11.ResourceRegion? srcBoxRef)
        {
            System.IntPtr dstResourceRef_ = System.IntPtr.Zero;
            System.IntPtr srcResourceRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.ResourceRegion srcBoxRef_;
            dstResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(dstResourceRef);
            srcResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(srcResourceRef);
            if (srcBoxRef != null)
                srcBoxRef_ = srcBoxRef.Value;
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)dstResourceRef_, dstSubresource, dstX, dstY, dstZ, (void *)srcResourceRef_, srcSubresource, srcBoxRef == null ? (void *)0 : &srcBoxRef_, (*(void ***)this._nativePointer)[46]);
        }

        /// <summary>
        /// <p>Copy the entire contents of the source resource to the destination resource using the GPU. </p>
        /// </summary>
        /// <param name = "dstResourceRef"><dd>  <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong> interface that represents the destination resource.</p> </dd></param>
        /// <param name = "srcResourceRef"><dd>  <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong> interface that represents the source resource.</p> </dd></param>
        /// <remarks>
        /// <p>This method is unusual in that it causes the GPU to perform the copy operation (similar to a memcpy by the CPU). As a result, it has a few restrictions designed for improving performance. For instance, the source and destination resources:</p><ul> <li>Must be different resources.</li> <li>Must be the same type.</li> <li>Must have identical dimensions (including width, height, depth, and size as appropriate).</li> <li>Must have compatible DXGI formats, which means the formats must be identical or at least from the same type group. For example, a DXGI_FORMAT_R32G32B32_FLOAT texture can be copied to an DXGI_FORMAT_R32G32B32_UINT texture since both of these formats are in the DXGI_FORMAT_R32G32B32_TYPELESS group. <strong>CopyResource</strong> can copy between a few format types. For more info, see Format Conversion using Direct3D 10.1.</li> <li>Can't be currently mapped.</li> </ul><p><strong>CopyResource</strong> only supports copy; it doesn't support any stretch, color key, or blend. <strong>CopyResource</strong> can reinterpret the resource data between a few format types. For more info, see Format Conversion using Direct3D 10.1.</p><p>You can't use an <strong>Immutable</strong> resource as a destination. You can use a   <strong>depth-stencil</strong> resource as either a source or a destination provided that the feature level is D3D_FEATURE_LEVEL_10_1 or greater. For feature levels 9_x, resources created with the D3D11_BIND_DEPTH_STENCIL flag can only be used as a source for <strong>CopyResource</strong>.  Resources created with multisampling capability (see <strong><see cref = "SharpDX.DXGI.SampleDescription"/></strong>) can be used as source and destination only if both source and destination have identical multisampled count and quality. If source and destination differ in multisampled count and quality or if one is multisampled and the other is not multisampled, the call to <strong>ID3D11DeviceContext::CopyResource</strong> fails. Use <strong>ID3D11DeviceContext::ResolveSubresource</strong> to resolve a multisampled resource to a resource that is not multisampled.</p><p>The method is an asynchronous call, which may be added to the command-buffer queue. This attempts to remove pipeline stalls that may occur when copying data. For more info, see performance considerations.</p><p>We recommend to use <strong>ID3D11DeviceContext::CopySubresourceRegion</strong> instead if you only need to copy a portion of the data in a resource.</p>
        /// </remarks>
        /// <doc-id>ff476392</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::CopyResource([In] ID3D11Resource* pDstResource,[In] ID3D11Resource* pSrcResource)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::CopyResource</unmanaged-short>
        internal unsafe void CopyResource_(SharpDX.Direct3D11.Resource dstResourceRef, SharpDX.Direct3D11.Resource srcResourceRef)
        {
            System.IntPtr dstResourceRef_ = System.IntPtr.Zero;
            System.IntPtr srcResourceRef_ = System.IntPtr.Zero;
            dstResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(dstResourceRef);
            srcResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(srcResourceRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)dstResourceRef_, (void *)srcResourceRef_, (*(void ***)this._nativePointer)[47]);
        }

        /// <summary>
        /// <p>The CPU copies data from memory to a subresource created in non-mappable memory.</p>
        /// </summary>
        /// <param name = "dstResourceRef"><dd>  <p>A reference to the destination resource (see <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong>).</p> </dd></param>
        /// <param name = "dstSubresource"><dd>  <p>A zero-based index, that identifies the destination subresource. See <strong>D3D11CalcSubresource</strong> for more details.</p> </dd></param>
        /// <param name = "dstBoxRef"><dd>  <p>A reference to a box that defines the portion of the destination subresource to copy the resource data into. Coordinates are in bytes for buffers and in texels for textures. If <strong><c>null</c></strong>, the data is written to the destination subresource with no offset. The dimensions of the source must fit the destination (see <strong><see cref = "SharpDX.Direct3D11.ResourceRegion"/></strong>).</p> <p>An empty box results in a no-op. A box is empty if the top value is greater than or equal to the bottom value, or the left value is greater than or equal to the right value, or the front value is greater than or equal to the back value. When the box is empty, <strong>UpdateSubresource</strong> doesn't perform an update operation.</p> </dd></param>
        /// <param name = "srcDataRef"><dd>  <p>A reference to the source data in memory.</p> </dd></param>
        /// <param name = "srcRowPitch"><dd>  <p>The size of one row of the source data.</p> </dd></param>
        /// <param name = "srcDepthPitch"><dd>  <p>The size of one depth slice of source data.</p> </dd></param>
        /// <remarks>
        /// <p>For a shader-constant buffer; set <em>pDstBox</em> to <strong><c>null</c></strong>. It is not possible to use this method to partially update a shader-constant buffer.</p><p>A resource cannot be used as a destination if:</p><ul> <li>the resource is created with <strong>immutable</strong> or <strong>dynamic</strong> usage.</li> <li>the resource is created as a depth-stencil resource.</li> <li>the resource is created with multisampling capability (see <strong><see cref = "SharpDX.DXGI.SampleDescription"/></strong>).</li> </ul><p>When <strong>UpdateSubresource</strong> returns, the application is free to change or even free the data pointed to by <em>pSrcData</em> because the method has already copied/snapped away the original contents.</p><p>The performance of <strong>UpdateSubresource</strong> depends on whether or not there is contention for the destination resource. For example, contention for a vertex buffer resource occurs when the application executes a <strong>Draw</strong> call and later calls <strong>UpdateSubresource</strong> on the same vertex buffer before the <strong>Draw</strong> call is actually executed by the GPU.</p><ul> <li>When there is contention for the resource, <strong>UpdateSubresource</strong> will perform 2 copies of the source data. First, the data is copied by the CPU to a temporary storage space accessible by the command buffer. This copy happens before the method returns.  A second copy is then performed by the GPU to copy the source data into non-mappable memory. This second copy happens asynchronously because it is executed by GPU when the command buffer is flushed.</li> <li>When there is no resource contention, the behavior of <strong>UpdateSubresource</strong> is dependent on which is faster (from the CPU's perspective): copying the data to the command buffer and then having a second copy execute when the command buffer is flushed, or having the CPU copy the data to the final resource location. This is dependent on the architecture of the underlying system.</li> </ul><strong>Note</strong>??<strong>Applies only to feature level 9_x hardware</strong> If you use <strong>UpdateSubresource</strong> or <strong>ID3D11DeviceContext::CopySubresourceRegion</strong> to copy from a staging resource to a default resource, you can corrupt the destination contents. This occurs if you pass a <strong><c>null</c></strong> source box and if the source resource has different dimensions from those of the destination resource or if you use destination offsets, (x, y, and z). In this situation, always pass a source box that is the full size of the source resource.?<p>To better understand the source row pitch and source depth pitch parameters, the following illustration shows a 3D volume texture.</p><p></p><p>Each block in this visual represents an element of data, and the size of each element is dependent on the resource's format. For example, if the resource format is DXGI_FORMAT_R32G32B32A32_FLOAT, the size of each element would be 128 bits, or 16 bytes. This 3D volume texture has a width of two, a height of three, and a depth of four.</p><p>To calculate the source row pitch and source depth pitch for a given resource, use the following formulas:</p><ul> <li>Source Row Pitch = [size of one element in bytes] * [number of elements in one row]</li> <li>Source Depth Pitch = [Source Row Pitch] * [number of rows (height)]</li> </ul><p>In the case of this example 3D volume texture where the size of each element is 16 bytes, the formulas are as follows:</p><ul> <li>Source Row Pitch = 16 * 2 = 32</li> <li>Source Depth Pitch = 16 * 2 * 3 = 96</li> </ul><p>The following illustration shows the resource as it is laid out in memory.</p><p></p><p>For example, the following code snippet shows how to specify a destination region in a 2D texture. Assume the destination texture is 512x512 and the operation will copy the data pointed to by <em>pData</em> to  [(120,100)..(200,220)] in the destination texture. Also assume that <em>rowPitch</em> has been initialized with the proper value (as explained above). <strong>front</strong> and <strong>back</strong> are set to 0 and 1 respectively, because by having <strong>front</strong> equal to <strong>back</strong>, the box is technically empty.</p><pre> <see cref = "SharpDX.Direct3D11.ResourceRegion"/> destRegion;
        /// destRegion.left = 120;
        /// destRegion.right = 200;
        /// destRegion.top = 100;
        /// destRegion.bottom = 220;
        /// destRegion.front = 0;
        /// destRegion.back = 1; pd3dDeviceContext-&gt;UpdateSubresource( pDestTexture, 0, &amp;destRegion, pData, rowPitch, 0 );
        /// </pre><p>The 1D case is similar. The following snippet shows how to specify a destination region in a 1D texture. Use the same assumptions as above, except that the texture is 512 in length.</p><pre> <see cref = "SharpDX.Direct3D11.ResourceRegion"/> destRegion;
        /// destRegion.left = 120;
        /// destRegion.right = 200;
        /// destRegion.top = 0;
        /// destRegion.bottom = 1;
        /// destRegion.front = 0;
        /// destRegion.back = 1; pd3dDeviceContext-&gt;UpdateSubresource( pDestTexture, 0, &amp;destRegion, pData, rowPitch, 0 );
        /// </pre><p>For info about various resource types and how <strong>UpdateSubresource</strong> might work with each resource type, see Introduction to a Resource in Direct3D 11. </p>
        /// </remarks>
        /// <doc-id>ff476486</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::UpdateSubresource([In] ID3D11Resource* pDstResource,[In] unsigned int DstSubresource,[In, Optional] const D3D11_BOX* pDstBox,[In] const void* pSrcData,[In] unsigned int SrcRowPitch,[In] unsigned int SrcDepthPitch)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::UpdateSubresource</unmanaged-short>
        public unsafe void UpdateSubresource(SharpDX.Direct3D11.Resource dstResourceRef, System.Int32 dstSubresource, SharpDX.Direct3D11.ResourceRegion? dstBoxRef, System.IntPtr srcDataRef, System.Int32 srcRowPitch, System.Int32 srcDepthPitch)
        {
            System.IntPtr dstResourceRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.ResourceRegion dstBoxRef_;
            dstResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(dstResourceRef);
            if (dstBoxRef != null)
                dstBoxRef_ = dstBoxRef.Value;
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)dstResourceRef_, dstSubresource, dstBoxRef == null ? (void *)0 : &dstBoxRef_, (void *)srcDataRef, srcRowPitch, srcDepthPitch, (*(void ***)this._nativePointer)[48]);
        }

        /// <summary>
        /// <p>Copies data from a buffer holding variable length data.</p>
        /// </summary>
        /// <param name = "dstBufferRef"><dd>  <p>Pointer to <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>.  This can be any buffer resource that other copy commands,  such as <strong>ID3D11DeviceContext::CopyResource</strong> or <strong>ID3D11DeviceContext::CopySubresourceRegion</strong>, are able to write to.</p> </dd></param>
        /// <param name = "dstAlignedByteOffset"><dd>  <p>Offset from the start of <em>pDstBuffer</em> to write 32-bit UINT structure (vertex) count from <em>pSrcView</em>.</p> </dd></param>
        /// <param name = "srcViewRef"><dd>  <p>Pointer to an <strong><see cref = "SharpDX.Direct3D11.UnorderedAccessView"/></strong> of a Structured Buffer resource created with either  <strong>D3D11_BUFFER_UAV_FLAG_APPEND</strong> or <strong>D3D11_BUFFER_UAV_FLAG_COUNTER</strong> specified  when the UAV was created.   These types of resources have hidden counters tracking "how many" records have  been written.</p> </dd></param>
        /// <doc-id>ff476393</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::CopyStructureCount([In] ID3D11Buffer* pDstBuffer,[In] unsigned int DstAlignedByteOffset,[In] ID3D11UnorderedAccessView* pSrcView)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::CopyStructureCount</unmanaged-short>
        public unsafe void CopyStructureCount(SharpDX.Direct3D11.Buffer dstBufferRef, System.Int32 dstAlignedByteOffset, SharpDX.Direct3D11.UnorderedAccessView srcViewRef)
        {
            System.IntPtr dstBufferRef_ = System.IntPtr.Zero;
            System.IntPtr srcViewRef_ = System.IntPtr.Zero;
            dstBufferRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Buffer>(dstBufferRef);
            srcViewRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.UnorderedAccessView>(srcViewRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)dstBufferRef_, dstAlignedByteOffset, (void *)srcViewRef_, (*(void ***)this._nativePointer)[49]);
        }

        /// <summary>
        /// <p>Set all the elements in a render target to one value.</p>
        /// </summary>
        /// <param name = "renderTargetViewRef"><dd>  <p>Pointer to the render target.</p> </dd></param>
        /// <param name = "colorRGBA"><dd>  <p>A 4-component array that represents the color to fill the render target with.</p> </dd></param>
        /// <remarks>
        /// <p>Applications that wish to clear a render target to a specific integer value bit pattern should render a screen-aligned quad instead of using this method.  The reason for this is because this method accepts as input a floating point value, which may not have the same bit pattern as the original integer.</p><table> <tr><td> <p>Differences between Direct3D 9 and Direct3D 11/10:</p> <p>Unlike Direct3D 9, the full extent of the resource view is always cleared. Viewport and scissor settings are not applied.</p> </td></tr> </table><p>?</p><p>When using <strong>D3D_FEATURE_LEVEL_9_x</strong>, <strong>ClearRenderTargetView</strong> only clears the first array slice in the render target view. This can impact (for example) cube map rendering scenarios. Applications should create a render target view for each face or array slice, then clear each view individually.</p>
        /// </remarks>
        /// <doc-id>ff476388</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::ClearRenderTargetView([In] ID3D11RenderTargetView* pRenderTargetView,[In] const SHARPDX_COLOR4* ColorRGBA)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::ClearRenderTargetView</unmanaged-short>
        public unsafe void ClearRenderTargetView(SharpDX.Direct3D11.RenderTargetView renderTargetViewRef, SharpDX.Mathematics.Interop.RawColor4 colorRGBA)
        {
            System.IntPtr renderTargetViewRef_ = System.IntPtr.Zero;
            renderTargetViewRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.RenderTargetView>(renderTargetViewRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)renderTargetViewRef_, &colorRGBA, (*(void ***)this._nativePointer)[50]);
        }

        /// <summary>
        /// <p>Clears an unordered access resource with bit-precise values.</p>
        /// </summary>
        /// <param name = "unorderedAccessViewRef">No documentation.</param>
        /// <param name = "values">No documentation.</param>
        /// <remarks>
        /// <p>This API copies the lower ni bits from each array element i to the corresponding channel, where ni is the number of bits in  the ith channel of the resource format (for example, R8G8B8_FLOAT has 8 bits for the first 3 channels). This works on any UAV with no format conversion.  For a raw or structured buffer view, only the first array element value is used.</p>
        /// </remarks>
        /// <doc-id>ff476391</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::ClearUnorderedAccessViewUint([In] ID3D11UnorderedAccessView* pUnorderedAccessView,[In] const SHARPDX_INT4* Values)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::ClearUnorderedAccessViewUint</unmanaged-short>
        public unsafe void ClearUnorderedAccessView(SharpDX.Direct3D11.UnorderedAccessView unorderedAccessViewRef, SharpDX.Mathematics.Interop.RawInt4 values)
        {
            System.IntPtr unorderedAccessViewRef_ = System.IntPtr.Zero;
            unorderedAccessViewRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.UnorderedAccessView>(unorderedAccessViewRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)unorderedAccessViewRef_, &values, (*(void ***)this._nativePointer)[51]);
        }

        /// <summary>
        /// <p>Clears an unordered access resource with a float value.</p>
        /// </summary>
        /// <param name = "unorderedAccessViewRef">No documentation.</param>
        /// <param name = "values">No documentation.</param>
        /// <remarks>
        /// <p>This API works on FLOAT, UNORM, and SNORM unordered access views (UAVs), with format conversion from FLOAT to *NORM where appropriate. On other UAVs, the operation is invalid and the call will not reach the driver.</p>
        /// </remarks>
        /// <doc-id>ff476390</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::ClearUnorderedAccessViewFloat([In] ID3D11UnorderedAccessView* pUnorderedAccessView,[In] const SHARPDX_VECTOR4* Values)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::ClearUnorderedAccessViewFloat</unmanaged-short>
        public unsafe void ClearUnorderedAccessView(SharpDX.Direct3D11.UnorderedAccessView unorderedAccessViewRef, SharpDX.Mathematics.Interop.RawVector4 values)
        {
            System.IntPtr unorderedAccessViewRef_ = System.IntPtr.Zero;
            unorderedAccessViewRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.UnorderedAccessView>(unorderedAccessViewRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)unorderedAccessViewRef_, &values, (*(void ***)this._nativePointer)[52]);
        }

        /// <summary>
        /// <p>Clears the depth-stencil resource.</p>
        /// </summary>
        /// <param name = "depthStencilViewRef"><dd>  <p>Pointer to the depth stencil to be cleared.</p> </dd></param>
        /// <param name = "clearFlags"><dd>  <p>Identify the type of data to clear (see <strong><see cref = "SharpDX.Direct3D11.DepthStencilClearFlags"/></strong>).</p> </dd></param>
        /// <param name = "depth"><dd>  <p>Clear the depth buffer with this value. This value will be clamped between 0 and 1.</p> </dd></param>
        /// <param name = "stencil"><dd>  <p>Clear the stencil buffer with this value.</p> </dd></param>
        /// <remarks>
        /// <table> <tr><td> <p>Differences between Direct3D 9 and Direct3D 11/10:</p> <p>Unlike Direct3D 9, the full extent of the resource view is always cleared. Viewport and scissor settings are not applied.</p> </td></tr> </table><p>?</p>
        /// </remarks>
        /// <doc-id>ff476387</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::ClearDepthStencilView([In] ID3D11DepthStencilView* pDepthStencilView,[In] unsigned int ClearFlags,[In] float Depth,[In] unsigned char Stencil)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::ClearDepthStencilView</unmanaged-short>
        public unsafe void ClearDepthStencilView(SharpDX.Direct3D11.DepthStencilView depthStencilViewRef, SharpDX.Direct3D11.DepthStencilClearFlags clearFlags, System.Single depth, System.Byte stencil)
        {
            System.IntPtr depthStencilViewRef_ = System.IntPtr.Zero;
            depthStencilViewRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.DepthStencilView>(depthStencilViewRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)depthStencilViewRef_, unchecked ((System.Int32)clearFlags), depth, stencil, (*(void ***)this._nativePointer)[53]);
        }

        /// <summary>
        /// <p>Generates mipmaps for the given shader resource.</p>
        /// </summary>
        /// <param name = "shaderResourceViewRef"><dd>  <p>A reference to an <strong><see cref = "SharpDX.Direct3D11.ShaderResourceView"/></strong> interface that represents the shader resource.</p> </dd></param>
        /// <remarks>
        /// <p>You can call <strong>GenerateMips</strong> on any shader-resource view to generate the lower mipmap levels for the shader resource. <strong>GenerateMips</strong> uses the largest mipmap level of the view to recursively generate the lower levels of the mip and stops with the smallest level that is specified by the view. If the base resource wasn't created with <strong>D3D11_BIND_RENDER_TARGET</strong>, <strong>D3D11_BIND_SHADER_RESOURCE</strong>, and <strong>D3D11_RESOURCE_MISC_GENERATE_MIPS</strong>, the call to <strong>GenerateMips</strong> has no effect.</p><p>Feature levels 9.1, 9.2, and 9.3 can't support automatic generation of mipmaps for 3D (volume) textures.</p><p>Video adapters that support feature level 9.1 and higher support generating mipmaps if you use any of these formats:</p><pre> DXGI_FORMAT_R8G8B8A8_UNORM
        /// DXGI_FORMAT_R8G8B8A8_UNORM_SRGB
        /// DXGI_FORMAT_B5G6R5_UNORM
        /// DXGI_FORMAT_B8G8R8A8_UNORM
        /// DXGI_FORMAT_B8G8R8A8_UNORM_SRGB
        /// DXGI_FORMAT_B8G8R8X8_UNORM
        /// DXGI_FORMAT_B8G8R8X8_UNORM_SRGB
        /// </pre><p>Video adapters that support feature level 9.2 and higher support generating mipmaps if you use any of these formats in addition to any of the formats for feature level 9.1:</p><pre> DXGI_FORMAT_R16G16B16A16_FLOAT
        /// DXGI_FORMAT_R16G16B16A16_UNORM
        /// DXGI_FORMAT_R16G16_FLOAT
        /// DXGI_FORMAT_R16G16_UNORM
        /// DXGI_FORMAT_R32_FLOAT
        /// </pre><p>Video adapters that support feature level 9.3 and higher support generating mipmaps if you use any of these formats in addition to any of the formats for feature levels 9.1 and 9.2:</p><pre> DXGI_FORMAT_R32G32B32A32_FLOAT
        /// DXGI_FORMAT_B4G4R4A4 (optional)
        /// </pre><p>Video adapters that support feature level 10 and higher support generating mipmaps if you use any of these formats in addition to any of the formats for feature levels 9.1, 9.2, and 9.3:</p><pre> DXGI_FORMAT_R32G32B32_FLOAT (optional)
        /// DXGI_FORMAT_R16G16B16A16_SNORM
        /// DXGI_FORMAT_R32G32_FLOAT
        /// DXGI_FORMAT_R10G10B10A2_UNORM
        /// DXGI_FORMAT_R11G11B10_FLOAT
        /// DXGI_FORMAT_R8G8B8A8_SNORM
        /// DXGI_FORMAT_R16G16_SNORM
        /// DXGI_FORMAT_R8G8_UNORM
        /// DXGI_FORMAT_R8G8_SNORM
        /// DXGI_FORMAT_R16_FLOAT
        /// DXGI_FORMAT_R16_UNORM
        /// DXGI_FORMAT_R16_SNORM
        /// DXGI_FORMAT_R8_UNORM
        /// DXGI_FORMAT_R8_SNORM
        /// DXGI_FORMAT_A8_UNORM
        /// DXGI_FORMAT_B5G5R5A1_UNORM (optional)
        /// </pre><p>For all other unsupported formats, <strong>GenerateMips</strong> will silently fail.</p>
        /// </remarks>
        /// <doc-id>ff476426</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::GenerateMips([In] ID3D11ShaderResourceView* pShaderResourceView)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::GenerateMips</unmanaged-short>
        public unsafe void GenerateMips(SharpDX.Direct3D11.ShaderResourceView shaderResourceViewRef)
        {
            System.IntPtr shaderResourceViewRef_ = System.IntPtr.Zero;
            shaderResourceViewRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.ShaderResourceView>(shaderResourceViewRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)shaderResourceViewRef_, (*(void ***)this._nativePointer)[54]);
        }

        /// <summary>
        /// <p>Sets the minimum level-of-detail (LOD) for a resource.</p>
        /// </summary>
        /// <param name = "resourceRef"><dd>  <p>A reference to an <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong> that represents the resource.</p> </dd></param>
        /// <param name = "minLOD"><dd>  <p>The level-of-detail, which ranges between 0 and the maximum number of mipmap levels of the resource. For example, the maximum number of mipmap levels of a 1D texture is specified in the  <strong>MipLevels</strong> member of the  <strong><see cref = "SharpDX.Direct3D11.Texture1DDescription"/></strong> structure.</p> </dd></param>
        /// <remarks>
        /// <p>To use a resource with <strong>SetResourceMinLOD</strong>, you must set the <strong>D3D11_RESOURCE_MISC_RESOURCE_CLAMP</strong> flag when you create that resource.</p><p>For Direct3D 10 and Direct3D 10.1, when sampling from a texture resource in a shader, the sampler can define a minimum LOD clamp to force sampling from less detailed mip levels.  For Direct3D 11, this functionality is extended from the sampler to the entire resource. Therefore, the application can specify the highest-resolution mip level of a resource that is available for access. This restricts the set of mip levels that are required to be resident in GPU memory, thereby saving memory.</p><p>The set of mip levels resident per-resource in GPU memory can be specified by the user.</p><p>Minimum LOD affects all of the resident mip levels. Therefore, only the resident mip levels can be updated and read from.</p><p>All methods that access texture resources must adhere to minimum LOD clamps.</p><p>Empty-set accesses are handled as out-of-bounds cases.</p>
        /// </remarks>
        /// <doc-id>ff476482</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::SetResourceMinLOD([In] ID3D11Resource* pResource,[In] float MinLOD)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::SetResourceMinLOD</unmanaged-short>
        public unsafe void SetMinimumLod(SharpDX.Direct3D11.Resource resourceRef, System.Single minLOD)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(resourceRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)resourceRef_, minLOD, (*(void ***)this._nativePointer)[55]);
        }

        /// <summary>
        /// <p>Gets the minimum level-of-detail (LOD).</p>
        /// </summary>
        /// <param name = "resourceRef"><dd>  <p>A reference to an <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong> which represents the resource.</p> </dd></param>
        /// <returns><p>Returns the minimum LOD.</p></returns>
        /// <doc-id>ff476430</doc-id>
        /// <unmanaged>float ID3D11DeviceContext::GetResourceMinLOD([In] ID3D11Resource* pResource)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::GetResourceMinLOD</unmanaged-short>
        public unsafe System.Single GetMinimumLod(SharpDX.Direct3D11.Resource resourceRef)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            System.Single __result__;
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(resourceRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallfloat(this._nativePointer, (void *)resourceRef_, (*(void ***)this._nativePointer)[56]);
            return __result__;
        }

        /// <summary>
        /// <p>Copy a multisampled resource into a non-multisampled resource.</p>
        /// </summary>
        /// <param name = "dstResourceRef"><dd>  <p>Destination resource. Must be a created with the <strong>D3D11_USAGE_DEFAULT</strong> flag and be single-sampled. See <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong>.</p> </dd></param>
        /// <param name = "dstSubresource"><dd>  <p>A zero-based index, that identifies the destination subresource. Use <strong>D3D11CalcSubresource</strong> to calculate the index.</p> </dd></param>
        /// <param name = "srcResourceRef"><dd>  <p>Source resource. Must be multisampled.</p> </dd></param>
        /// <param name = "srcSubresource"><dd>  <p>The source subresource of the source resource.</p> </dd></param>
        /// <param name = "format"><dd>  <p>A <strong><see cref = "SharpDX.DXGI.Format"/></strong> that indicates how the multisampled resource will be resolved to a single-sampled resource.  See remarks.</p> </dd></param>
        /// <remarks>
        /// <p>This API is most useful when re-using the resulting rendertarget of one render pass as an input to a second render pass.</p><p>The source and destination resources must be the same resource type and have the same dimensions. In addition, they must have compatible formats. There are three scenarios for this:</p><table> <tr><th>Scenario</th><th>Requirements</th></tr> <tr><td>Source and destination are prestructured and typed</td><td>Both the source and destination must have identical formats and that format must be specified in the Format parameter.</td></tr> <tr><td>One resource is prestructured and typed and the other is prestructured and typeless</td><td>The typed resource must have a format that is compatible with the typeless resource (i.e. the typed resource is DXGI_FORMAT_R32_FLOAT and the typeless resource is DXGI_FORMAT_R32_TYPELESS). The format of the typed resource must be specified in the Format parameter.</td></tr> <tr><td>Source and destination are prestructured and typeless</td><td>Both the source and desintation must have the same typeless format (i.e. both must have DXGI_FORMAT_R32_TYPELESS), and the Format parameter must specify a format that is compatible with the source and destination (i.e. if both are DXGI_FORMAT_R32_TYPELESS then DXGI_FORMAT_R32_FLOAT could be specified in the Format parameter). <p>For example, given the DXGI_FORMAT_R16G16B16A16_TYPELESS format:</p> <ul> <li>The source (or dest) format could be DXGI_FORMAT_R16G16B16A16_UNORM</li> <li>The dest (or source) format could be DXGI_FORMAT_R16G16B16A16_FLOAT</li> </ul> </td></tr> </table><p>?</p>
        /// </remarks>
        /// <doc-id>ff476474</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::ResolveSubresource([In] ID3D11Resource* pDstResource,[In] unsigned int DstSubresource,[In] ID3D11Resource* pSrcResource,[In] unsigned int SrcSubresource,[In] DXGI_FORMAT Format)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::ResolveSubresource</unmanaged-short>
        internal unsafe void ResolveSubresource_(SharpDX.Direct3D11.Resource dstResourceRef, System.Int32 dstSubresource, SharpDX.Direct3D11.Resource srcResourceRef, System.Int32 srcSubresource, SharpDX.DXGI.Format format)
        {
            System.IntPtr dstResourceRef_ = System.IntPtr.Zero;
            System.IntPtr srcResourceRef_ = System.IntPtr.Zero;
            dstResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(dstResourceRef);
            srcResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(srcResourceRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)dstResourceRef_, dstSubresource, (void *)srcResourceRef_, srcSubresource, unchecked ((System.Int32)format), (*(void ***)this._nativePointer)[57]);
        }

        /// <summary>
        /// <p>Queues commands from a command list onto a device.</p>
        /// </summary>
        /// <param name = "commandListRef"><dd>  <p> A reference to an <strong><see cref = "SharpDX.Direct3D11.CommandList"/></strong> interface that encapsulates a command list. </p> </dd></param>
        /// <param name = "restoreContextState"><dd>  <p> A Boolean flag that determines whether the target context state is saved prior to and restored after the execution of a command list. Use <strong>TRUE</strong> to indicate that the runtime needs to save and restore the state. Use <strong><see cref = "SharpDX.Result.False"/></strong> to indicate that no state shall be saved or restored, which causes the target context to  return to its default state after the command list executes. Applications should typically use <strong><see cref = "SharpDX.Result.False"/></strong> unless they will restore the state to be nearly equivalent to the state that the runtime would restore if <strong>TRUE</strong> were passed. When applications use <strong><see cref = "SharpDX.Result.False"/></strong>, they can avoid unnecessary and inefficient state transitions. </p> </dd></param>
        /// <remarks>
        /// <p>Use this method to play back a command list that was recorded by a deferred context on any thread.</p><p> A call to <strong>ExecuteCommandList</strong> of a command list from a deferred context onto the immediate context is required for the recorded commands to be executed on the graphics processing unit (GPU). A call to <strong>ExecuteCommandList</strong> of a command list from a deferred context onto another deferred context can be used to merge recorded lists. But to run the commands from the merged deferred command list on the GPU, you need to execute them on the immediate context. </p><p> This method performs some runtime validation related to queries. Queries that are begun in a device context cannot be manipulated indirectly by executing a command list (that is, Begin or End was invoked against the same query by the deferred context which generated the command list). If such a condition occurs, the ExecuteCommandList method does not execute the command list. However, the state of the device context is still maintained, as would be expected (<strong>ID3D11DeviceContext::ClearState</strong> is performed, unless the application indicates to preserve the device context state). </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476423</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::ExecuteCommandList([In] ID3D11CommandList* pCommandList,[In] BOOL RestoreContextState)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::ExecuteCommandList</unmanaged-short>
        public unsafe void ExecuteCommandList(SharpDX.Direct3D11.CommandList commandListRef, SharpDX.Mathematics.Interop.RawBool restoreContextState)
        {
            System.IntPtr commandListRef_ = System.IntPtr.Zero;
            commandListRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.CommandList>(commandListRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid0(this._nativePointer, (void *)commandListRef_, restoreContextState, (*(void ***)this._nativePointer)[58]);
        }

        /// <summary>
        /// <p>Get the rendering predicate state.</p>
        /// </summary>
        /// <param name = "predicateValueRef"><dd>  <p>Address of a boolean to fill with the predicate comparison value. <strong><see cref = "SharpDX.Result.False"/></strong> upon device creation.</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476429</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::GetPredication([Out, Optional] ID3D11Predicate** ppPredicate,[Out, Optional] BOOL* pPredicateValue)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::GetPredication</unmanaged-short>
        public unsafe SharpDX.Direct3D11.Predicate GetPredication(out SharpDX.Mathematics.Interop.RawBool predicateValueRef)
        {
            SharpDX.Direct3D11.Predicate predicateOut;
            System.IntPtr predicateOut_ = System.IntPtr.Zero;
            predicateValueRef = default (SharpDX.Mathematics.Interop.RawBool);
            fixed (void *predicateValueRef_ = &predicateValueRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, &predicateOut_, predicateValueRef_, (*(void ***)this._nativePointer)[86]);
            if (predicateOut_ != System.IntPtr.Zero)
                predicateOut = new SharpDX.Direct3D11.Predicate(predicateOut_);
            else
                predicateOut = null;
            return predicateOut;
        }

        /// <summary>
        /// <p>Restore all default settings.</p>
        /// </summary>
        /// <remarks>
        /// <p>This method resets any device context to the default settings. This sets all input/output resource slots, shaders, input layouts, predications, scissor rectangles, depth-stencil state, rasterizer state, blend state, sampler state, and viewports to <strong><c>null</c></strong>. The primitive topology is set to UNDEFINED.</p><p>For a scenario where you would like to clear a list of commands recorded so far, call <strong>ID3D11DeviceContext::FinishCommandList</strong> and throw away the resulting <strong><see cref = "SharpDX.Direct3D11.CommandList"/></strong>.</p>
        /// </remarks>
        /// <doc-id>ff476389</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::ClearState()</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::ClearState</unmanaged-short>
        public unsafe void ClearState()
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[110]);
        }

        /// <summary>
        /// <p>Sends queued-up commands in the command buffer to the graphics processing unit (GPU).</p>
        /// </summary>
        /// <remarks>
        /// <p>Most applications don't need to call this method. If an application calls this method when not necessary, it incurs a performance penalty.  Each call to <strong>Flush</strong> incurs a significant amount of overhead.</p><p>When Microsoft Direct3D state-setting, present, or draw commands are called by an application, those commands are queued into an internal command buffer.  <strong>Flush</strong> sends those commands to the GPU for processing. Typically, the Direct3D runtime sends these commands to the GPU automatically whenever the runtime determines that  they need to be sent, such as when the command buffer is full or when an application maps a resource. <strong>Flush</strong> sends the commands manually.</p><p>We recommend that you use <strong>Flush</strong> when the CPU waits for an arbitrary amount of time (such as when  you call the <strong>Sleep</strong> function).</p><p>Because <strong>Flush</strong> operates asynchronously,  it can return either before or after the GPU finishes executing the queued graphics commands. However, the graphics commands eventually always complete. You can call the <strong>ID3D11Device::CreateQuery</strong> method with the <strong>D3D11_QUERY_EVENT</strong> value to create an event query; you can then use that event query in a call to the <strong>ID3D11DeviceContext::GetData</strong> method to determine when the GPU is finished processing the graphics commands.
        /// </p><p>Microsoft Direct3D?11 defers the destruction of objects. Therefore, an application can't rely upon objects immediately being destroyed. By calling <strong>Flush</strong>, you destroy any  objects whose destruction was deferred.  If an application requires synchronous destruction of an object, we recommend that the application release all its references, call <strong>ID3D11DeviceContext::ClearState</strong>, and then call <strong>Flush</strong>.</p>
        /// </remarks>
        /// <doc-id>ff476425</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::Flush()</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::Flush</unmanaged-short>
        public unsafe void Flush()
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[111]);
        }

        /// <summary>
        /// <p>Gets the type of device context.</p>
        /// </summary>
        /// <returns><p>A member of <strong><see cref = "SharpDX.Direct3D11.DeviceContextType"/></strong> that indicates the type of device context.</p></returns>
        /// <doc-id>ff476431</doc-id>
        /// <unmanaged>D3D11_DEVICE_CONTEXT_TYPE ID3D11DeviceContext::GetType()</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::GetType</unmanaged-short>
        internal unsafe SharpDX.Direct3D11.DeviceContextType GetTypeInfo()
        {
            SharpDX.Direct3D11.DeviceContextType __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallSharpDXDirect3D11DeviceContextType(this._nativePointer, (*(void ***)this._nativePointer)[112]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the initialization flags associated with the current deferred context.</p>
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <remarks>
        /// <p>The GetContextFlags method gets the flags that were supplied to the <em>ContextFlags</em> parameter of <strong>ID3D11Device::CreateDeferredContext</strong>; however, the context flag is reserved for future use.</p>
        /// </remarks>
        /// <doc-id>ff476427</doc-id>
        /// <unmanaged>unsigned int ID3D11DeviceContext::GetContextFlags()</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::GetContextFlags</unmanaged-short>
        internal unsafe System.Int32 GetContextFlags()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[113]);
            return __result__;
        }

        /// <summary>
        /// <p>Create a command list and record graphics commands into it.</p>
        /// </summary>
        /// <param name = "restoreDeferredContextState"><dd>  <p> A Boolean flag that determines whether the runtime saves deferred context state before it executes  <strong>FinishCommandList</strong> and restores it afterwards. Use <strong>TRUE</strong> to indicate that the runtime needs to save and restore the state. Use <strong><see cref = "SharpDX.Result.False"/></strong> to indicate that the runtime will not save or restore any state. In this case, the deferred context will  return to its default state after the call to  <strong>FinishCommandList</strong> completes. For information about default state, see <strong>ID3D11DeviceContext::ClearState</strong>. Typically, use <strong><see cref = "SharpDX.Result.False"/></strong> unless you restore the state to be nearly equivalent to the state that the runtime would restore if you passed <strong>TRUE</strong>. When you use <strong><see cref = "SharpDX.Result.False"/></strong>, you can avoid unnecessary and inefficient state transitions. </p> <strong>Note</strong>?? This parameter does not affect the command list that the current call to <strong>FinishCommandList</strong> returns. However, this parameter affects the command list of the next call to <strong>FinishCommandList</strong> on the same deferred context.  ? </dd></param>
        /// <param name = "commandListOut"><dd>  <p> Upon completion of the method, the passed reference to an <strong><see cref = "SharpDX.Direct3D11.CommandList"/></strong> interface reference is initialized with the recorded command list information. The resulting <strong><see cref = "SharpDX.Direct3D11.CommandList"/></strong> object is immutable and can only be used with <strong>ID3D11DeviceContext::ExecuteCommandList</strong>. </p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns one of the following:</p><ul> <li>Returns <see cref = "DeviceRemoved"/> if the video card has been physically removed from the system, or a driver upgrade for the video card has occurred. If this error occurs, you should destroy and recreate the device.</li> <li> Returns <see cref = "InvalidCall"/> if <strong>FinishCommandList</strong> cannot be called from the current context. See remarks. </li> <li>Returns E_OUTOFMEMORY if the application has exhausted available memory.</li> </ul></returns>
        /// <remarks>
        /// <p> Create a command list from a deferred context and record commands into it by calling <strong>FinishCommandList</strong>. Play back a command list with an immediate context by calling <strong>ID3D11DeviceContext::ExecuteCommandList</strong>. </p><p> Immediate context state is cleared before and after a command list is executed. A command list has no concept of inheritance. Each call to <strong>FinishCommandList</strong> will record only the state set since any previous call to  <strong>FinishCommandList</strong>. </p><p> For example, the state of a device context is its render state or pipeline state. To retrieve device context state, an application can call  <strong>ID3D11DeviceContext::GetData</strong> or  <strong>ID3D11DeviceContext::GetPredication</strong>. </p><p> For more information about how to use <strong>FinishCommandList</strong>, see How to: Record a Command List. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476424</doc-id>
        /// <unmanaged>HRESULT ID3D11DeviceContext::FinishCommandList([In] BOOL RestoreDeferredContextState,[Out, Optional] ID3D11CommandList** ppCommandList)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::FinishCommandList</unmanaged-short>
        internal unsafe void FinishCommandListInternal(SharpDX.Mathematics.Interop.RawBool restoreDeferredContextState, out SharpDX.Direct3D11.CommandList commandListOut)
        {
            System.IntPtr commandListOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint0(this._nativePointer, restoreDeferredContextState, &commandListOut_, (*(void ***)this._nativePointer)[114]);
            if (commandListOut_ != System.IntPtr.Zero)
                commandListOut = new SharpDX.Direct3D11.CommandList(commandListOut_);
            else
                commandListOut = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("bb2c6faa-b5fb-4082-8e6b-388b8cfa90e1")]
    public partial class DeviceContext1 : SharpDX.Direct3D11.DeviceContext
    {
        public DeviceContext1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DeviceContext1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DeviceContext1(nativePtr);
        /// <summary>
        /// <p>Copies a region from a source resource to a destination resource.</p>
        /// </summary>
        /// <param name = "dstResourceRef"><dd>  <p>A reference to the destination resource.</p> </dd></param>
        /// <param name = "dstSubresource"><dd>  <p>Destination subresource index.</p> </dd></param>
        /// <param name = "dstX"><dd>  <p>The x-coordinate of the upper-left corner of the destination region.</p> </dd></param>
        /// <param name = "dstY"><dd>  <p>The y-coordinate of the upper-left corner of the destination region. For a 1D subresource, this must be zero.</p> </dd></param>
        /// <param name = "dstZ"><dd>  <p>The z-coordinate of the upper-left corner of the destination region. For a 1D or 2D subresource, this must be zero.</p> </dd></param>
        /// <param name = "srcResourceRef"><dd>  <p>A reference to the source resource.</p> </dd></param>
        /// <param name = "srcSubresource"><dd>  <p>Source subresource index.</p> </dd></param>
        /// <param name = "srcBoxRef"><dd>  <p>A reference to a 3D box that defines the region of the source subresource that <strong>CopySubresourceRegion1</strong> can copy. If <strong><c>null</c></strong>, <strong>CopySubresourceRegion1</strong> copies the entire source subresource. The box must fit within the source resource.</p> <p>An empty box results in a no-op. A box is empty if the top value is greater than or equal to the bottom value, or the left value is greater than or equal to the right value, or the front value is greater than or equal to the back value. When the box is empty, <strong>CopySubresourceRegion1</strong> doesn't perform a copy operation.</p> </dd></param>
        /// <param name = "copyFlags"><dd>  <p>A <strong><see cref = "SharpDX.Direct3D11.CopyFlags"/></strong>-typed value that specifies how to perform the copy operation. If you specify zero for no copy option, <strong>CopySubresourceRegion1</strong> behaves like <strong>ID3D11DeviceContext::CopySubresourceRegion</strong>. For existing display drivers that can't process these flags, the runtime doesn't use them. </p> </dd></param>
        /// <remarks>
        /// <p>If the display driver supports overlapping, the source and destination subresources can be identical, and the source and destination regions can overlap each other.  For existing display drivers that don?t support overlapping, the runtime drops calls with identical source and destination subresources, regardless of whether the regions overlap.  To determine whether the display driver supports overlapping, check the <strong>CopyWithOverlap</strong> member of <strong><see cref = "SharpDX.Direct3D11.FeatureDataD3D11Options"/></strong>. This overlapping support enables additional scroll functionality in a call to <strong>IDXGISwapChain::Present</strong>.</p><strong>Note</strong>??<strong>Applies only to feature level 9_x hardware</strong> If you use <strong>ID3D11DeviceContext1::UpdateSubresource1</strong> or <strong>CopySubresourceRegion1</strong> to copy from a staging resource to a default resource, you can corrupt the destination contents. This occurs if you pass a <strong><c>null</c></strong> source box and if the source resource has different dimensions from those of the destination resource or if you use destination offsets, (x, y, and z). In this situation, always pass a source box that is the full size of the source resource.?
        /// </remarks>
        /// <doc-id>hh404604</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::CopySubresourceRegion1([In] ID3D11Resource* pDstResource,[In] unsigned int DstSubresource,[In] unsigned int DstX,[In] unsigned int DstY,[In] unsigned int DstZ,[In] ID3D11Resource* pSrcResource,[In] unsigned int SrcSubresource,[In, Optional] const D3D11_BOX* pSrcBox,[In] unsigned int CopyFlags)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::CopySubresourceRegion1</unmanaged-short>
        public unsafe void CopySubresourceRegion1(SharpDX.Direct3D11.Resource dstResourceRef, System.Int32 dstSubresource, System.Int32 dstX, System.Int32 dstY, System.Int32 dstZ, SharpDX.Direct3D11.Resource srcResourceRef, System.Int32 srcSubresource, SharpDX.Direct3D11.ResourceRegion? srcBoxRef, System.Int32 copyFlags)
        {
            System.IntPtr dstResourceRef_ = System.IntPtr.Zero;
            System.IntPtr srcResourceRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.ResourceRegion srcBoxRef_;
            dstResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(dstResourceRef);
            srcResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(srcResourceRef);
            if (srcBoxRef != null)
                srcBoxRef_ = srcBoxRef.Value;
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)dstResourceRef_, dstSubresource, dstX, dstY, dstZ, (void *)srcResourceRef_, srcSubresource, srcBoxRef == null ? (void *)0 : &srcBoxRef_, copyFlags, (*(void ***)this._nativePointer)[115]);
        }

        /// <summary>
        /// <p>The CPU copies data from memory to a subresource created in non-mappable memory.</p>
        /// </summary>
        /// <param name = "dstResourceRef"><dd>  <p>A reference to the destination resource.</p> </dd></param>
        /// <param name = "dstSubresource"><dd>  <p>A zero-based index that identifies the destination subresource. See <strong>D3D11CalcSubresource</strong> for more details.</p> </dd></param>
        /// <param name = "dstBoxRef"><dd>  <p>A reference to a box that defines the portion of the destination subresource to copy the resource data into. Coordinates are in bytes for buffers and in texels for textures. If <strong><c>null</c></strong>, <strong>UpdateSubresource1</strong> writes the data to the destination subresource with no offset. The dimensions of the source must fit the destination.</p> <p>An empty box results in a no-op. A box is empty if the top value is greater than or equal to the bottom value, or the left value is greater than or equal to the right value, or the front value is greater than or equal to the back value. When the box is empty, <strong>UpdateSubresource1</strong> doesn't perform an update operation.</p> </dd></param>
        /// <param name = "srcDataRef"><dd>  <p>A reference to the source data in memory.</p> </dd></param>
        /// <param name = "srcRowPitch"><dd>  <p>The size of one row of the source data.</p> </dd></param>
        /// <param name = "srcDepthPitch"><dd>  <p>The size of one depth slice of source data.</p> </dd></param>
        /// <param name = "copyFlags"><dd>  <p>A <strong><see cref = "SharpDX.Direct3D11.CopyFlags"/></strong>-typed value that specifies how to perform the update operation. If you specify zero for no update option, <strong>UpdateSubresource1</strong> behaves like <strong>ID3D11DeviceContext::UpdateSubresource</strong>. For existing display drivers that can't process these flags, the runtime doesn't use them.</p> </dd></param>
        /// <remarks>
        /// <p>If you call <strong>UpdateSubresource1</strong> to update a constant buffer, pass any region, and the driver has not been implemented to Windows?8, the runtime drops the call (except feature level 9.1, 9.2, and 9.3 where the runtime emulates support).  The runtime also drops the call if you update a constant buffer with a partial region whose extent is not aligned to 16-byte granularity (16 bytes being a full constant). When the runtime drops the call, the runtime doesn't call the corresponding device driver interface (DDI).</p><p>When you record a call to <strong>UpdateSubresource</strong> with an offset <em>pDstBox</em> in a software command list, the offset in <em>pDstBox</em> is incorrectly applied to <em>pSrcData</em> when you play back the command list.  The new-for-Windows?8<strong>UpdateSubresource1</strong> fixes this issue. In a call to <strong>UpdateSubresource1</strong>, <em>pDstBox</em> does not affect <em>pSrcData</em>.</p><p>For info about various resource types and how <strong>UpdateSubresource1</strong> might work with each resource type, see Introduction to a Resource in Direct3D 11. </p><strong>Note</strong>??<strong>Applies only to feature level 9_x hardware</strong> If you use <strong>UpdateSubresource1</strong> or <strong>ID3D11DeviceContext1::CopySubresourceRegion1</strong> to copy from a staging resource to a default resource, you can corrupt the destination contents. This occurs if you pass a <strong><c>null</c></strong> source box and if the source resource has different dimensions from those of the destination resource or if you use destination offsets, (x, y, and z). In this situation, always pass a source box that is the full size of the source resource.?
        /// </remarks>
        /// <doc-id>hh446790</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::UpdateSubresource1([In] ID3D11Resource* pDstResource,[In] unsigned int DstSubresource,[In, Optional] const D3D11_BOX* pDstBox,[In] const void* pSrcData,[In] unsigned int SrcRowPitch,[In] unsigned int SrcDepthPitch,[In] unsigned int CopyFlags)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::UpdateSubresource1</unmanaged-short>
        public unsafe void UpdateSubresource1(SharpDX.Direct3D11.Resource dstResourceRef, System.Int32 dstSubresource, SharpDX.Direct3D11.ResourceRegion? dstBoxRef, System.IntPtr srcDataRef, System.Int32 srcRowPitch, System.Int32 srcDepthPitch, System.Int32 copyFlags)
        {
            System.IntPtr dstResourceRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.ResourceRegion dstBoxRef_;
            dstResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(dstResourceRef);
            if (dstBoxRef != null)
                dstBoxRef_ = dstBoxRef.Value;
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)dstResourceRef_, dstSubresource, dstBoxRef == null ? (void *)0 : &dstBoxRef_, (void *)srcDataRef, srcRowPitch, srcDepthPitch, copyFlags, (*(void ***)this._nativePointer)[116]);
        }

        /// <summary>
        /// <p>Discards a resource from the device context.</p>
        /// </summary>
        /// <param name = "resourceRef"><dd>  <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong> interface for the resource to discard. The resource must have been created with usage <strong>D3D11_USAGE_DEFAULT</strong> or <strong>D3D11_USAGE_DYNAMIC</strong>, otherwise the runtime drops the call to <strong>DiscardResource</strong>; if the debug layer is enabled, the runtime returns an error message.</p> </dd></param>
        /// <remarks>
        /// <p><strong>DiscardResource</strong> informs the graphics processing unit (GPU) that the existing content in the resource that <em>pResource</em> points to is no longer needed.</p>
        /// </remarks>
        /// <doc-id>hh404613</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::DiscardResource([In] ID3D11Resource* pResource)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::DiscardResource</unmanaged-short>
        public unsafe void DiscardResource(SharpDX.Direct3D11.Resource resourceRef)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(resourceRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)resourceRef_, (*(void ***)this._nativePointer)[117]);
        }

        /// <summary>
        /// <p>Discards a resource view from the device context.</p>
        /// </summary>
        /// <param name = "resourceViewRef"><dd>  <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.ResourceView"/></strong> interface for the resource view to discard. The resource that underlies the view must have been created with usage <strong>D3D11_USAGE_DEFAULT</strong> or <strong>D3D11_USAGE_DYNAMIC</strong>, otherwise the runtime drops the call to <strong>DiscardView</strong>; if the debug layer is enabled, the runtime returns an error message.</p> </dd></param>
        /// <remarks>
        /// <p><strong>DiscardView</strong> informs the graphics processing unit (GPU) that the existing content in the resource view that <em>pResourceView</em> points to is no longer needed.  The view can be an SRV, RTV, UAV, or DSV.  <strong>DiscardView</strong> is a variation on the <strong>DiscardResource</strong> method.  <strong>DiscardView</strong> allows you to discard a subset of a resource that is in a view (such as a single miplevel).  More importantly, <strong>DiscardView</strong> provides a convenience because often views are what are being bound and unbound at the pipeline.  Some pipeline bindings do not have views, such as stream output.  In that situation, <strong>DiscardResource</strong> can do the job for any resource.</p>
        /// </remarks>
        /// <doc-id>hh404616</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::DiscardView([In] ID3D11View* pResourceView)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::DiscardView</unmanaged-short>
        public unsafe void DiscardView(SharpDX.Direct3D11.ResourceView resourceViewRef)
        {
            System.IntPtr resourceViewRef_ = System.IntPtr.Zero;
            resourceViewRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.ResourceView>(resourceViewRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)resourceViewRef_, (*(void ***)this._nativePointer)[118]);
        }

        /// <summary>
        /// <p>Sets the constant buffers that the vertex shader pipeline stage uses.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd>  <p>Number of buffers to set (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - <em>StartSlot</em>).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd>  <p>Array of constant buffers being given to the device.</p> </dd></param>
        /// <param name = "firstConstantRef"><dd>  <p>An array that holds the offsets into the buffers that  <em>ppConstantBuffers</em> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants.</p> </dd></param>
        /// <param name = "numConstantsRef"><dd>  <p>An array that holds the numbers of constants in the buffers that  <em>ppConstantBuffers</em> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <em>pFirstConstant</em> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096]. </p> </dd></param>
        /// <remarks>
        /// <p>The runtime drops the call to <strong>VSSetConstantBuffers1</strong> if the number of constants to which <em>pNumConstants</em> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <em>pFirstConstant</em> and <em>pFirstConstant</em> + <em>pNumConstants</em> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <em>pFirstConstant</em>, value in an element of <em>pFirstConstant</em> + value in an element of <em>pNumConstants</em>]. The runtime also drops the call to <strong>VSSetConstantBuffers1</strong> on existing drivers that don't support this offsetting.</p><p>The runtime will emulate this feature for feature level 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</p><p>From the shader?s point of view, element [0] in the constant buffers array is the constant at <em>pFirstConstant</em>.</p><p>Out of bounds access to the constant buffers from the shader to the range that is defined by <em>pFirstConstant</em> and <em>pNumConstants</em> returns 0. </p><p>If <em>pFirstConstant</em> and <em>pNumConstants</em> arrays are <strong><c>null</c></strong>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <strong>VSSetConstantBuffers</strong> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</p><p>If either <em>pFirstConstant</em> or <em>pNumConstants</em> is <strong><c>null</c></strong>, the other parameter must also be <strong><c>null</c></strong>.</p>
        /// </remarks>
        /// <doc-id>hh446795</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::VSSetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers,[In, Buffer, Optional] const unsigned int* pFirstConstant,[In, Buffer, Optional] const unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::VSSetConstantBuffers1</unmanaged-short>
        public unsafe void VSSetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.Direct3D11.Buffer[] constantBuffersOut, System.Int32[] firstConstantRef, System.Int32[] numConstantsRef)
        {
            System.IntPtr*constantBuffersOut_;
            constantBuffersOut_ = (System.IntPtr*)0;
            if (constantBuffersOut != null)
            {
                System.IntPtr*_constantBuffersOut = stackalloc System.IntPtr[constantBuffersOut.Length];
                constantBuffersOut_ = _constantBuffersOut;
            }

            if (constantBuffersOut != null)
                for (int i = 0; i < constantBuffersOut.Length; ++i)
                    (constantBuffersOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Buffer>(constantBuffersOut[i]);
            fixed (void *numConstantsRef_ = numConstantsRef)
                fixed (void *firstConstantRef_ = firstConstantRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut_, firstConstantRef_, numConstantsRef_, (*(void ***)this._nativePointer)[119]);
        }

        /// <summary>
        /// <p>Sets the constant buffers that the hull-shader stage of the pipeline uses.</p>
        /// </summary>
        /// <param name = "startSlot">No documentation.</param>
        /// <param name = "numBuffers">No documentation.</param>
        /// <param name = "constantBuffersOut">No documentation.</param>
        /// <param name = "firstConstantRef">No documentation.</param>
        /// <param name = "numConstantsRef">No documentation.</param>
        /// <remarks>
        /// <p>The runtime drops the call to <strong>HSSetConstantBuffers1</strong> if the number of constants to which <em>pNumConstants</em> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <em>pFirstConstant</em> and <em>pFirstConstant</em> + <em>pNumConstants</em> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <em>pFirstConstant</em>, value in an element of <em>pFirstConstant</em> + value in an element of <em>pNumConstants</em>]. The runtime also drops the call to <strong>HSSetConstantBuffers1</strong> on existing drivers that don't support this offsetting.</p><p>The runtime will emulate this feature for feature level 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</p><p>From the shader?s point of view, element [0] in the constant buffers array is the constant at <em>pFirstConstant</em>.</p><p>Out of bounds access to the constant buffers from the shader to the range that is defined by <em>pFirstConstant</em> and <em>pNumConstants</em> returns 0. </p><p>If the <em>pFirstConstant</em> and <em>pNumConstants</em> arrays are <strong><c>null</c></strong>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <strong>HSSetConstantBuffers</strong> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</p><p>If either <em>pFirstConstant</em> or <em>pNumConstants</em> is <strong><c>null</c></strong>, the other parameter must also be <strong><c>null</c></strong>.</p>
        /// </remarks>
        /// <doc-id>hh404642</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::HSSetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers,[In, Buffer, Optional] const unsigned int* pFirstConstant,[In, Buffer, Optional] const unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::HSSetConstantBuffers1</unmanaged-short>
        public unsafe void HSSetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.Direct3D11.Buffer[] constantBuffersOut, System.Int32[] firstConstantRef, System.Int32[] numConstantsRef)
        {
            System.IntPtr*constantBuffersOut_;
            constantBuffersOut_ = (System.IntPtr*)0;
            if (constantBuffersOut != null)
            {
                System.IntPtr*_constantBuffersOut = stackalloc System.IntPtr[constantBuffersOut.Length];
                constantBuffersOut_ = _constantBuffersOut;
            }

            if (constantBuffersOut != null)
                for (int i = 0; i < constantBuffersOut.Length; ++i)
                    (constantBuffersOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Buffer>(constantBuffersOut[i]);
            fixed (void *numConstantsRef_ = numConstantsRef)
                fixed (void *firstConstantRef_ = firstConstantRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut_, firstConstantRef_, numConstantsRef_, (*(void ***)this._nativePointer)[120]);
        }

        /// <summary>
        /// <p>Sets the constant buffers that the domain-shader stage uses.</p>
        /// </summary>
        /// <param name = "startSlot"><dd> <p>Index into the zero-based array to begin setting constant buffers to (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd> <p>Number of buffers to set (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - <em>StartSlot</em>).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd> <p>Array of constant buffers being given to the device.</p> </dd></param>
        /// <param name = "firstConstantRef"><dd> <p>An array that holds the offsets into the buffers that  <em>ppConstantBuffers</em> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants.</p> </dd></param>
        /// <param name = "numConstantsRef"><dd> <p>An array that holds the numbers of constants in the buffers that  <em>ppConstantBuffers</em> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <em>pFirstConstant</em> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096]. </p> </dd></param>
        /// <remarks>
        /// <p>The runtime drops the call to <strong>DSSetConstantBuffers1</strong> if the number of constants to which <em>pNumConstants</em> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <em>pFirstConstant</em> and <em>pFirstConstant</em> + <em>pNumConstants</em> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <em>pFirstConstant</em>, value in an element of <em>pFirstConstant</em> + value in an element of <em>pNumConstants</em>]. The runtime also drops the call to <strong>DSSetConstantBuffers1</strong> on existing drivers that don't support this offsetting.</p><p>The runtime will emulate this feature for feature level 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</p><p>From the shader?s point of view, element [0] in the constant buffers array is the constant at <em>pFirstConstant</em>.</p><p>Out of bounds access to the constant buffers from the shader to the range that is defined by <em>pFirstConstant</em> and <em>pNumConstants</em> returns 0. </p><p>If <em>pFirstConstant</em> and <em>pNumConstants</em> arrays are <strong><c>null</c></strong>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <strong>DSSetConstantBuffers</strong> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</p><p>If either <em>pFirstConstant</em> or <em>pNumConstants</em> is <strong><c>null</c></strong>, the other parameter must also be <strong><c>null</c></strong>.</p>
        /// </remarks>
        /// <doc-id>hh404632</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::DSSetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers,[In, Buffer, Optional] const unsigned int* pFirstConstant,[In, Buffer, Optional] const unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::DSSetConstantBuffers1</unmanaged-short>
        public unsafe void DSSetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.Direct3D11.Buffer[] constantBuffersOut, System.Int32[] firstConstantRef, System.Int32[] numConstantsRef)
        {
            System.IntPtr*constantBuffersOut_;
            constantBuffersOut_ = (System.IntPtr*)0;
            if (constantBuffersOut != null)
            {
                System.IntPtr*_constantBuffersOut = stackalloc System.IntPtr[constantBuffersOut.Length];
                constantBuffersOut_ = _constantBuffersOut;
            }

            if (constantBuffersOut != null)
                for (int i = 0; i < constantBuffersOut.Length; ++i)
                    (constantBuffersOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Buffer>(constantBuffersOut[i]);
            fixed (void *numConstantsRef_ = numConstantsRef)
                fixed (void *firstConstantRef_ = firstConstantRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut_, firstConstantRef_, numConstantsRef_, (*(void ***)this._nativePointer)[121]);
        }

        /// <summary>
        /// <p>Sets the constant buffers that the geometry shader pipeline stage uses.</p>
        /// </summary>
        /// <param name = "startSlot"><dd> <p>Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd> <p>Number of buffers to set (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - <em>StartSlot</em>).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd> <p>Array of constant buffers (see <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>) being given to the device.</p> </dd></param>
        /// <param name = "firstConstantRef"><dd> <p>An array that holds the offsets into the buffers that  <em>ppConstantBuffers</em> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants.</p> </dd></param>
        /// <param name = "numConstantsRef"><dd> <p>An array that holds the numbers of constants in the buffers that  <em>ppConstantBuffers</em> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <em>pFirstConstant</em> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096]. </p> </dd></param>
        /// <remarks>
        /// <p>The runtime drops the call to <strong>GSSetConstantBuffers1</strong> if the number of constants to which <em>pNumConstants</em> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <em>pFirstConstant</em> and <em>pFirstConstant</em> + <em>pNumConstants</em> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <em>pFirstConstant</em>, value in an element of <em>pFirstConstant</em> + value in an element of <em>pNumConstants</em>]. The runtime also drops the call to <strong>GSSetConstantBuffers1</strong> on existing drivers that don't support this offsetting.</p><p>The runtime will emulate this feature for feature level 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</p><p>From the shader?s point of view, element [0] in the constant buffers array is the constant at <em>pFirstConstant</em>.</p><p>Out of bounds access to the constant buffers from the shader to the range that is defined by <em>pFirstConstant</em> and <em>pNumConstants</em> returns 0. </p><p>If <em>pFirstConstant</em> and <em>pNumConstants</em> arrays are <strong><c>null</c></strong>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <strong>GSSetConstantBuffers</strong> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</p><p>If either <em>pFirstConstant</em> or <em>pNumConstants</em> is <strong><c>null</c></strong>, the other parameter must also be <strong><c>null</c></strong>.</p>
        /// </remarks>
        /// <doc-id>hh404638</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::GSSetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers,[In, Buffer, Optional] const unsigned int* pFirstConstant,[In, Buffer, Optional] const unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::GSSetConstantBuffers1</unmanaged-short>
        public unsafe void GSSetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.Direct3D11.Buffer[] constantBuffersOut, System.Int32[] firstConstantRef, System.Int32[] numConstantsRef)
        {
            System.IntPtr*constantBuffersOut_;
            constantBuffersOut_ = (System.IntPtr*)0;
            if (constantBuffersOut != null)
            {
                System.IntPtr*_constantBuffersOut = stackalloc System.IntPtr[constantBuffersOut.Length];
                constantBuffersOut_ = _constantBuffersOut;
            }

            if (constantBuffersOut != null)
                for (int i = 0; i < constantBuffersOut.Length; ++i)
                    (constantBuffersOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Buffer>(constantBuffersOut[i]);
            fixed (void *numConstantsRef_ = numConstantsRef)
                fixed (void *firstConstantRef_ = firstConstantRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut_, firstConstantRef_, numConstantsRef_, (*(void ***)this._nativePointer)[122]);
        }

        /// <summary>
        /// <p> Sets the constant buffers that the pixel shader pipeline stage uses, and enables the shader to access other parts of the buffer. </p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p> Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1). </p> </dd></param>
        /// <param name = "numBuffers"><dd>  <p> Number of buffers to set (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - <em>StartSlot</em>). </p> </dd></param>
        /// <param name = "constantBuffersOut"><dd>  <p> Array of constant buffers being given to the device. </p> </dd></param>
        /// <param name = "firstConstantRef"><dd>  <p> An array that holds the offsets into the buffers that  <em>ppConstantBuffers</em> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts. Each offset is measured in shader constants, which are 16 bytes (4*32-bit components). Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants. </p> </dd></param>
        /// <param name = "numConstantsRef"><dd>  <p> An array that holds the numbers of constants in the buffers that  <em>ppConstantBuffers</em> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <em>pFirstConstant</em> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096]. </p> </dd></param>
        /// <remarks>
        /// <p> To enable the shader to access other parts of the buffer, call <strong>PSSetConstantBuffers1</strong> instead of <strong>PSSetConstantBuffers</strong>. <strong>PSSetConstantBuffers1</strong> has additional parameters <em>pFirstConstant</em> and <em>pNumConstants</em>. </p><p> The runtime drops the call to <strong>PSSetConstantBuffers1</strong> if the numbers of constants to which <em>pNumConstants</em> points is larger than the maximum constant buffer size that is supported by shaders. The maximum constant buffer size that is supported by shaders holds 4096 constants, where each constant has four 32-bit components. </p><p> The values in the elements of the <em>pFirstConstant</em> and <em>pFirstConstant</em> + <em>pNumConstants</em> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the following window (range): </p><p> [value in an element of <em>pFirstConstant</em>, value in an element of <em>pFirstConstant</em> + value in an element of <em>pNumConstants</em>] </p><p> That is, the window is the range is from (value in an element of <em>pFirstConstant</em>) to (value in an element of <em>pFirstConstant</em> + value in an element of <em>pNumConstants</em>). </p><p> The runtime also drops the call to <strong>PSSetConstantBuffers1</strong> on existing drivers that do not support this offsetting. </p><p> The runtime will emulate this feature for feature level 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3. This feature is always available on new drivers for feature level 10 and higher. </p><p> From the shader?s point of view, element [0] in the constant buffers array is the constant at <em>pFirstConstant</em>. </p><p> Out of bounds access to the constant buffers from the shader to the range that is defined by <em>pFirstConstant</em> and <em>pNumConstants</em> returns 0. </p><p> If <em>pFirstConstant</em> and <em>pNumConstants</em> arrays are <strong><c>null</c></strong>, you get the same result as if you were binding the entire buffer into view. You get this same result if you call the <strong>PSSetConstantBuffers</strong> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants. </p><p> If either <em>pFirstConstant</em> or <em>pNumConstants</em> is <strong><c>null</c></strong>, the other parameter must also be <strong><c>null</c></strong>. </p>
        /// </remarks>
        /// <doc-id>hh404649</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::PSSetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers,[In, Buffer, Optional] const unsigned int* pFirstConstant,[In, Buffer, Optional] const unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::PSSetConstantBuffers1</unmanaged-short>
        public unsafe void PSSetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.Direct3D11.Buffer[] constantBuffersOut, System.Int32[] firstConstantRef, System.Int32[] numConstantsRef)
        {
            System.IntPtr*constantBuffersOut_;
            constantBuffersOut_ = (System.IntPtr*)0;
            if (constantBuffersOut != null)
            {
                System.IntPtr*_constantBuffersOut = stackalloc System.IntPtr[constantBuffersOut.Length];
                constantBuffersOut_ = _constantBuffersOut;
            }

            if (constantBuffersOut != null)
                for (int i = 0; i < constantBuffersOut.Length; ++i)
                    (constantBuffersOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Buffer>(constantBuffersOut[i]);
            fixed (void *numConstantsRef_ = numConstantsRef)
                fixed (void *firstConstantRef_ = firstConstantRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut_, firstConstantRef_, numConstantsRef_, (*(void ***)this._nativePointer)[123]);
        }

        /// <summary>
        /// <p>Sets the constant buffers that the compute-shader stage uses.</p>
        /// </summary>
        /// <param name = "startSlot"><dd> <p>Index into the zero-based array to begin setting constant buffers to (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd> <p>Number of buffers to set (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - <em>StartSlot</em>).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd> <p>Array of constant buffers (see <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>) being given to the device.</p> </dd></param>
        /// <param name = "firstConstantRef"><dd> <p>An array that holds the offsets into the buffers that  <em>ppConstantBuffers</em> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants.</p> </dd></param>
        /// <param name = "numConstantsRef"><dd> <p>An array that holds the numbers of constants in the buffers that  <em>ppConstantBuffers</em> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <em>pFirstConstant</em> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096]. </p> </dd></param>
        /// <remarks>
        /// <p>The runtime drops the call to <strong>CSSetConstantBuffers1</strong> if the number of constants to which <em>pNumConstants</em> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <em>pFirstConstant</em> and <em>pFirstConstant</em> + <em>pNumConstants</em> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <em>pFirstConstant</em>, value in an element of <em>pFirstConstant</em> + value in an element of <em>pNumConstants</em>]. The runtime also drops the call to <strong>CSSetConstantBuffers1</strong> on existing drivers that don't support this offsetting.</p><p>The runtime will emulate this feature for feature level 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</p><p>From the shader?s point of view, element [0] in the constant buffers array is the constant at <em>pFirstConstant</em>.</p><p>Out of bounds access to the constant buffers from the shader to the range that is defined by <em>pFirstConstant</em> and <em>pNumConstants</em> returns 0. </p><p>If <em>pFirstConstant</em> and <em>pNumConstants</em> arrays are <strong><c>null</c></strong>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <strong>CSSetConstantBuffers</strong> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</p><p>If either <em>pFirstConstant</em> or <em>pNumConstants</em> is <strong><c>null</c></strong>, the other parameter must also be <strong><c>null</c></strong>.</p>
        /// </remarks>
        /// <doc-id>hh404610</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::CSSetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers,[In, Buffer, Optional] const unsigned int* pFirstConstant,[In, Buffer, Optional] const unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::CSSetConstantBuffers1</unmanaged-short>
        public unsafe void CSSetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.Direct3D11.Buffer[] constantBuffersOut, System.Int32[] firstConstantRef, System.Int32[] numConstantsRef)
        {
            System.IntPtr*constantBuffersOut_;
            constantBuffersOut_ = (System.IntPtr*)0;
            if (constantBuffersOut != null)
            {
                System.IntPtr*_constantBuffersOut = stackalloc System.IntPtr[constantBuffersOut.Length];
                constantBuffersOut_ = _constantBuffersOut;
            }

            if (constantBuffersOut != null)
                for (int i = 0; i < constantBuffersOut.Length; ++i)
                    (constantBuffersOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Buffer>(constantBuffersOut[i]);
            fixed (void *numConstantsRef_ = numConstantsRef)
                fixed (void *firstConstantRef_ = firstConstantRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut_, firstConstantRef_, numConstantsRef_, (*(void ***)this._nativePointer)[124]);
        }

        /// <summary>
        /// <p>Gets the constant buffers that the vertex shader pipeline stage uses.</p>
        /// </summary>
        /// <param name = "startSlot"><dd> <p>Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd> <p>Number of buffers to retrieve (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - <em>StartSlot</em>).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd> <p>Array of constant buffer interface references to be returned by the method.</p> </dd></param>
        /// <param name = "firstConstantRef"><dd> <p>A reference to an array that receives the offsets into the buffers that  <em>ppConstantBuffers</em> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 2 indicates that the start of the associated constant buffer is 32 bytes into the constant buffer. The runtime sets <em>pFirstConstant</em> to <strong><c>null</c></strong> if the buffers do not have offsets.</p> </dd></param>
        /// <param name = "numConstantsRef"><dd> <p>A reference to an array that receives the numbers of constants in the buffers that  <em>ppConstantBuffers</em> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <em>pFirstConstant</em> array. The runtime sets <em>pNumConstants</em> to <strong><c>null</c></strong> if it doesn't specify the numbers of constants in each buffer.</p> </dd></param>
        /// <remarks>
        /// <p>If no buffer is bound at a slot, <em>pFirstConstant</em> and <em>pNumConstants</em> are <strong><c>null</c></strong> for that slot.</p>
        /// </remarks>
        /// <doc-id>hh446793</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::VSGetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[Out, Buffer, Optional] ID3D11Buffer** ppConstantBuffers,[Out, Buffer, Optional] unsigned int* pFirstConstant,[Out, Buffer, Optional] unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::VSGetConstantBuffers1</unmanaged-short>
        public unsafe void VSGetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.Direct3D11.Buffer[] constantBuffersOut, System.Int32[] firstConstantRef, System.Int32[] numConstantsRef)
        {
            System.IntPtr*constantBuffersOut_;
            constantBuffersOut_ = (System.IntPtr*)0;
            if (constantBuffersOut != null)
            {
                System.IntPtr*_constantBuffersOut = stackalloc System.IntPtr[constantBuffersOut.Length];
                constantBuffersOut_ = _constantBuffersOut;
            }

            fixed (void *numConstantsRef_ = numConstantsRef)
                fixed (void *firstConstantRef_ = firstConstantRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut_, firstConstantRef_, numConstantsRef_, (*(void ***)this._nativePointer)[125]);
            if (constantBuffersOut != null)
                for (int i = 0; i < constantBuffersOut.Length; ++i)
                    if ((constantBuffersOut_)[i] != System.IntPtr.Zero)
                        constantBuffersOut[i] = new SharpDX.Direct3D11.Buffer((constantBuffersOut_)[i]);
                    else
                        constantBuffersOut[i] = null;
        }

        /// <summary>
        /// <p>Gets the constant buffers that the hull-shader stage uses.</p>
        /// </summary>
        /// <param name = "startSlot">No documentation.</param>
        /// <param name = "numBuffers">No documentation.</param>
        /// <param name = "constantBuffersOut">No documentation.</param>
        /// <param name = "firstConstantRef">No documentation.</param>
        /// <param name = "numConstantsRef">No documentation.</param>
        /// <remarks>
        /// <p>If no buffer is bound at a slot, <em>pFirstConstant</em> and <em>pNumConstants</em> are <strong><c>null</c></strong> for that slot.</p>
        /// </remarks>
        /// <doc-id>hh404641</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::HSGetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[Out, Buffer, Optional] ID3D11Buffer** ppConstantBuffers,[Out, Buffer, Optional] unsigned int* pFirstConstant,[Out, Buffer, Optional] unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::HSGetConstantBuffers1</unmanaged-short>
        public unsafe void HSGetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.Direct3D11.Buffer[] constantBuffersOut, System.Int32[] firstConstantRef, System.Int32[] numConstantsRef)
        {
            System.IntPtr*constantBuffersOut_;
            constantBuffersOut_ = (System.IntPtr*)0;
            if (constantBuffersOut != null)
            {
                System.IntPtr*_constantBuffersOut = stackalloc System.IntPtr[constantBuffersOut.Length];
                constantBuffersOut_ = _constantBuffersOut;
            }

            fixed (void *numConstantsRef_ = numConstantsRef)
                fixed (void *firstConstantRef_ = firstConstantRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut_, firstConstantRef_, numConstantsRef_, (*(void ***)this._nativePointer)[126]);
            if (constantBuffersOut != null)
                for (int i = 0; i < constantBuffersOut.Length; ++i)
                    if ((constantBuffersOut_)[i] != System.IntPtr.Zero)
                        constantBuffersOut[i] = new SharpDX.Direct3D11.Buffer((constantBuffersOut_)[i]);
                    else
                        constantBuffersOut[i] = null;
        }

        /// <summary>
        /// <p>Gets the constant buffers that the domain-shader stage uses.</p>
        /// </summary>
        /// <param name = "startSlot"><dd> <p>Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd> <p>Number of buffers to retrieve (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - <em>StartSlot</em>).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd> <p>Array of constant buffer interface references to be returned by the method.</p> </dd></param>
        /// <param name = "firstConstantRef"><dd> <p>A reference to an array that receives the offsets into the buffers that  <em>ppConstantBuffers</em> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 2 indicates that the start of the associated constant buffer is 32 bytes into the constant buffer. The runtime sets <em>pFirstConstant</em> to <strong><c>null</c></strong> if the buffers do not have offsets.</p> </dd></param>
        /// <param name = "numConstantsRef"><dd> <p>A reference to an array that receives the numbers of constants in the buffers that  <em>ppConstantBuffers</em> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <em>pFirstConstant</em> array. The runtime sets <em>pNumConstants</em> to <strong><c>null</c></strong> if it doesn't specify the numbers of constants in each buffer.</p> </dd></param>
        /// <remarks>
        /// <p>If no buffer is bound at a slot, <em>pFirstConstant</em> and <em>pNumConstants</em> are <strong><c>null</c></strong> for that slot.</p>
        /// </remarks>
        /// <doc-id>hh404630</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::DSGetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[Out, Buffer, Optional] ID3D11Buffer** ppConstantBuffers,[Out, Buffer, Optional] unsigned int* pFirstConstant,[Out, Buffer, Optional] unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::DSGetConstantBuffers1</unmanaged-short>
        public unsafe void DSGetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.Direct3D11.Buffer[] constantBuffersOut, System.Int32[] firstConstantRef, System.Int32[] numConstantsRef)
        {
            System.IntPtr*constantBuffersOut_;
            constantBuffersOut_ = (System.IntPtr*)0;
            if (constantBuffersOut != null)
            {
                System.IntPtr*_constantBuffersOut = stackalloc System.IntPtr[constantBuffersOut.Length];
                constantBuffersOut_ = _constantBuffersOut;
            }

            fixed (void *numConstantsRef_ = numConstantsRef)
                fixed (void *firstConstantRef_ = firstConstantRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut_, firstConstantRef_, numConstantsRef_, (*(void ***)this._nativePointer)[127]);
            if (constantBuffersOut != null)
                for (int i = 0; i < constantBuffersOut.Length; ++i)
                    if ((constantBuffersOut_)[i] != System.IntPtr.Zero)
                        constantBuffersOut[i] = new SharpDX.Direct3D11.Buffer((constantBuffersOut_)[i]);
                    else
                        constantBuffersOut[i] = null;
        }

        /// <summary>
        /// <p>Gets the constant buffers that the geometry shader pipeline stage uses.</p>
        /// </summary>
        /// <param name = "startSlot"><dd> <p>Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd> <p>Number of buffers to retrieve (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - <em>StartSlot</em>).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd> <p>Array of constant buffer interface references to be returned by the method.</p> </dd></param>
        /// <param name = "firstConstantRef"><dd> <p>A reference to an array that receives the offsets into the buffers that  <em>ppConstantBuffers</em> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 2 indicates that the start of the associated constant buffer is 32 bytes into the constant buffer. The runtime sets <em>pFirstConstant</em> to <strong><c>null</c></strong> if the buffers do not have offsets.</p> </dd></param>
        /// <param name = "numConstantsRef"><dd> <p>A reference to an array that receives the numbers of constants in the buffers that  <em>ppConstantBuffers</em> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <em>pFirstConstant</em> array. The runtime sets <em>pNumConstants</em> to <strong><c>null</c></strong> if it doesn't specify the numbers of constants in each buffer.</p> </dd></param>
        /// <remarks>
        /// <p>If no buffer is bound at a slot, <em>pFirstConstant</em> and <em>pNumConstants</em> are <strong><c>null</c></strong> for that slot.</p>
        /// </remarks>
        /// <doc-id>hh404635</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::GSGetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[Out, Buffer, Optional] ID3D11Buffer** ppConstantBuffers,[Out, Buffer, Optional] unsigned int* pFirstConstant,[Out, Buffer, Optional] unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::GSGetConstantBuffers1</unmanaged-short>
        public unsafe void GSGetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.Direct3D11.Buffer[] constantBuffersOut, System.Int32[] firstConstantRef, System.Int32[] numConstantsRef)
        {
            System.IntPtr*constantBuffersOut_;
            constantBuffersOut_ = (System.IntPtr*)0;
            if (constantBuffersOut != null)
            {
                System.IntPtr*_constantBuffersOut = stackalloc System.IntPtr[constantBuffersOut.Length];
                constantBuffersOut_ = _constantBuffersOut;
            }

            fixed (void *numConstantsRef_ = numConstantsRef)
                fixed (void *firstConstantRef_ = firstConstantRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut_, firstConstantRef_, numConstantsRef_, (*(void ***)this._nativePointer)[128]);
            if (constantBuffersOut != null)
                for (int i = 0; i < constantBuffersOut.Length; ++i)
                    if ((constantBuffersOut_)[i] != System.IntPtr.Zero)
                        constantBuffersOut[i] = new SharpDX.Direct3D11.Buffer((constantBuffersOut_)[i]);
                    else
                        constantBuffersOut[i] = null;
        }

        /// <summary>
        /// <p>Gets the constant buffers that the pixel shader pipeline stage uses.</p>
        /// </summary>
        /// <param name = "startSlot"><dd> <p>Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd> <p>Number of buffers to retrieve (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - <em>StartSlot</em>).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd> <p>Array of constant buffer interface references to be returned by the method.</p> </dd></param>
        /// <param name = "firstConstantRef"><dd> <p>A reference to an array that receives the offsets into the buffers that  <em>ppConstantBuffers</em> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 2 indicates that the start of the associated constant buffer is 32 bytes into the constant buffer. The runtime sets <em>pFirstConstant</em> to <strong><c>null</c></strong> if the buffers do not have offsets.</p> </dd></param>
        /// <param name = "numConstantsRef"><dd> <p>A reference to an array that receives the numbers of constants in the buffers that  <em>ppConstantBuffers</em> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <em>pFirstConstant</em> array. The runtime sets <em>pNumConstants</em> to <strong><c>null</c></strong> if it doesn't specify the numbers of constants in each buffer.</p> </dd></param>
        /// <remarks>
        /// <p>If no buffer is bound at a slot, <em>pFirstConstant</em> and <em>pNumConstants</em> are <strong><c>null</c></strong> for that slot.</p>
        /// </remarks>
        /// <doc-id>hh404645</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::PSGetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[Out, Buffer, Optional] ID3D11Buffer** ppConstantBuffers,[Out, Buffer, Optional] unsigned int* pFirstConstant,[Out, Buffer, Optional] unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::PSGetConstantBuffers1</unmanaged-short>
        public unsafe void PSGetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.Direct3D11.Buffer[] constantBuffersOut, System.Int32[] firstConstantRef, System.Int32[] numConstantsRef)
        {
            System.IntPtr*constantBuffersOut_;
            constantBuffersOut_ = (System.IntPtr*)0;
            if (constantBuffersOut != null)
            {
                System.IntPtr*_constantBuffersOut = stackalloc System.IntPtr[constantBuffersOut.Length];
                constantBuffersOut_ = _constantBuffersOut;
            }

            fixed (void *numConstantsRef_ = numConstantsRef)
                fixed (void *firstConstantRef_ = firstConstantRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut_, firstConstantRef_, numConstantsRef_, (*(void ***)this._nativePointer)[129]);
            if (constantBuffersOut != null)
                for (int i = 0; i < constantBuffersOut.Length; ++i)
                    if ((constantBuffersOut_)[i] != System.IntPtr.Zero)
                        constantBuffersOut[i] = new SharpDX.Direct3D11.Buffer((constantBuffersOut_)[i]);
                    else
                        constantBuffersOut[i] = null;
        }

        /// <summary>
        /// <p>Gets the constant buffers that the compute-shader stage uses.</p>
        /// </summary>
        /// <param name = "startSlot"><dd> <p>Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd> <p>Number of buffers to retrieve (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - <em>StartSlot</em>).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd> <p>Array of constant buffer interface references to be returned by the method.</p> </dd></param>
        /// <param name = "firstConstantRef"><dd> <p>A reference to an array that receives the offsets into the buffers that  <em>ppConstantBuffers</em> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 2 indicates that the start of the associated constant buffer is 32 bytes into the constant buffer. The runtime sets <em>pFirstConstant</em> to <strong><c>null</c></strong> if the buffers do not have offsets.</p> </dd></param>
        /// <param name = "numConstantsRef"><dd> <p>A reference to an array that receives the numbers of constants in the buffers that  <em>ppConstantBuffers</em> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <em>pFirstConstant</em> array. The runtime sets <em>pNumConstants</em> to <strong><c>null</c></strong> if it doesn't specify the numbers of constants in each buffer.</p> </dd></param>
        /// <remarks>
        /// <p>If no buffer is bound at a slot, <em>pFirstConstant</em> and <em>pNumConstants</em> are <strong><c>null</c></strong> for that slot.</p>
        /// </remarks>
        /// <doc-id>hh404607</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::CSGetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[Out, Buffer, Optional] ID3D11Buffer** ppConstantBuffers,[Out, Buffer, Optional] unsigned int* pFirstConstant,[Out, Buffer, Optional] unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::CSGetConstantBuffers1</unmanaged-short>
        public unsafe void CSGetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.Direct3D11.Buffer[] constantBuffersOut, System.Int32[] firstConstantRef, System.Int32[] numConstantsRef)
        {
            System.IntPtr*constantBuffersOut_;
            constantBuffersOut_ = (System.IntPtr*)0;
            if (constantBuffersOut != null)
            {
                System.IntPtr*_constantBuffersOut = stackalloc System.IntPtr[constantBuffersOut.Length];
                constantBuffersOut_ = _constantBuffersOut;
            }

            fixed (void *numConstantsRef_ = numConstantsRef)
                fixed (void *firstConstantRef_ = firstConstantRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut_, firstConstantRef_, numConstantsRef_, (*(void ***)this._nativePointer)[130]);
            if (constantBuffersOut != null)
                for (int i = 0; i < constantBuffersOut.Length; ++i)
                    if ((constantBuffersOut_)[i] != System.IntPtr.Zero)
                        constantBuffersOut[i] = new SharpDX.Direct3D11.Buffer((constantBuffersOut_)[i]);
                    else
                        constantBuffersOut[i] = null;
        }

        /// <summary>
        /// <p>Activates the given context state object and changes the current device behavior to Direct3D?11, Direct3D?10.1, or Direct3D?10.</p>
        /// </summary>
        /// <param name = "stateRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.DeviceContextState"/></strong> interface for the context state object that was previously created through the <strong>ID3D11Device1::CreateDeviceContextState</strong> method. If <strong>SwapDeviceContextState</strong> is called with <em>pState</em> set to <strong><c>null</c></strong>, the call has no effect.</p> </dd></param>
        /// <param name = "previousStateOut"><dd> <p>A reference to a variable that receives a reference to the <strong><see cref = "SharpDX.Direct3D11.DeviceContextState"/></strong> interface for the previously-activated context state object.</p> </dd></param>
        /// <remarks>
        /// <p><strong>SwapDeviceContextState</strong> changes device behavior. This device behavior depends on the emulated interface that you passed to the <em>EmulatedInterface</em> parameter of the  <strong>ID3D11Device1::CreateDeviceContextState</strong> method when you created the context state object. </p><p><strong>SwapDeviceContextState</strong> is not supported on a deferred context.</p><p><strong>SwapDeviceContextState</strong> disables the incompatible device interfaces <strong>ID3D10Device</strong>, <strong>ID3D10Device1</strong>, <strong><see cref = "SharpDX.Direct3D11.Device"/></strong>, and <strong><see cref = "SharpDX.Direct3D11.Device1"/></strong>. When a context state object is active, the runtime disables certain methods on the device and context interfaces. A context state object that is created with <code>__uuidof(<see cref = "SharpDX.Direct3D11.Device1"/>)</code> or <code>__uuidof(<see cref = "SharpDX.Direct3D11.Device"/>)</code> turns off most of the Direct3D?10 device interfaces. A context state object that is created with <code>__uuidof(ID3D10Device1)</code> or <code>__uuidof(ID3D10Device)</code> turns off most of the <strong><see cref = "SharpDX.Direct3D11.DeviceContext"/></strong> methods.
        /// For more information about this behavior, see <strong>ID3D11Device1::CreateDeviceContextState</strong>.</p><p><strong>SwapDeviceContextState</strong> activates the context state object specified by <em>pState</em>. This means that the device behaviors that are associated with the context state object's feature level and compatible interface are activated on the Direct3D device until the next call to <strong>SwapDeviceContextState</strong>. In addition, any state that was saved when this context state object was last active is now reactivated, so that the previous state is replaced.</p><p><strong>SwapDeviceContextState</strong> sets <em>ppPreviousState</em> to the most recently activated context state object. The object allows the caller to save and then later restore the previous device state. This behavior is useful in a plug-in architecture such as Direct2D that shares a Direct3D device with its plug-ins. A Direct2D interface can use context state objects to save and restore the application's state.</p><p>If the caller did not previously call the <strong>ID3D11Device1::CreateDeviceContextState</strong> method to create a previous context state object, <strong>SwapDeviceContextState</strong> sets <em>ppPreviousState</em> to the default context state object. In either case, usage of <strong>SwapDeviceContextState</strong> is the same.</p><p>The feature level that is specified by the application, and that is chosen by the context state object from the acceptable list that the application supplies to <strong>ID3D11Device1::CreateDeviceContextState</strong>, controls the feature level of the immediate context whenever the context state object is active. Because the Direct3D?11 device is free-threaded, the device methods cannot query the current immediate context feature level. Instead, the device runs at a feature level that is the maximum of all previously created context state objects' feature levels. This means that the device's feature level can increase dynamically.</p><p>The feature level of the context state object controls the functionality available from the immediate context. However, to maintain the free-threaded contract of the Direct3D?11 device methods?the resource-creation methods in particular?the upper-bound feature level of all created context state objects controls the set of resources that the device creates.</p><p>Because the context state object interface is published by the immediate context, the interface requires the same threading model as the immediate context. Specifically, <strong>SwapDeviceContextState</strong> is single-threaded with respect to the other immediate context methods and with respect to the equivalent methods of <strong>ID3D10Device</strong>.</p><p>Crucially, because only one of the Direct3D?10 or Direct3D?11 ref-count behaviors can be available at a time, one of the Direct3D?10 and Direct3D?11 interfaces must break its ref-count contract. To avoid this situation, the activation of a context state object turns off the incompatible version interface. Also, if you call a method of an incompatible version interface, the call silently fails if the method has  return type <strong>void</strong>, returns an <strong><see cref = "SharpDX.Result"/></strong> value of <strong>E_INVALIDARG</strong>, or sets any out parameter to <strong><c>null</c></strong>.</p><p>When you switch from Direct3D?11 mode to either Direct3D?10 mode or Direct3D?10.1 mode, the binding behavior of the device changes. Specifically, the final release of a resource induces unbind in Direct3D?10 mode or Direct3D?10.1 mode. During final release an application releases all of the resource's references, including indirect references such as the linkage from view to resource, and the linkage from context state object to any of the context state object's bound resources. Any bound resource to which the application has no reference is unbound and destroyed, in order to maintain the Direct3D?10 behavior.</p><p><strong>SwapDeviceContextState</strong> does not affect any state that <strong><see cref = "SharpDX.Direct3D11.VideoContext"/></strong> sets. </p><p>Command lists that are generated by deferred contexts do not hold a reference to context state objects and are not affected by future updates to context state objects.</p><p>No asynchronous objects are affected by <strong>SwapDeviceContextState</strong>. For example, if a query is active before a call to <strong>SwapDeviceContextState</strong>, it is still active after the call.</p>
        /// </remarks>
        /// <doc-id>hh446787</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::SwapDeviceContextState([In] ID3DDeviceContextState* pState,[Out, Optional] ID3DDeviceContextState** ppPreviousState)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::SwapDeviceContextState</unmanaged-short>
        public unsafe void SwapDeviceContextState(SharpDX.Direct3D11.DeviceContextState stateRef, out SharpDX.Direct3D11.DeviceContextState previousStateOut)
        {
            System.IntPtr stateRef_ = System.IntPtr.Zero;
            System.IntPtr previousStateOut_ = System.IntPtr.Zero;
            stateRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.DeviceContextState>(stateRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)stateRef_, &previousStateOut_, (*(void ***)this._nativePointer)[131]);
            if (previousStateOut_ != System.IntPtr.Zero)
                previousStateOut = new SharpDX.Direct3D11.DeviceContextState(previousStateOut_);
            else
                previousStateOut = null;
        }

        /// <summary>
        /// <p>Sets all the elements in a resource view to one value.</p>
        /// </summary>
        /// <param name = "viewRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.ResourceView"/></strong> interface that represents the resource view to clear.</p> </dd></param>
        /// <param name = "color"><dd> <p>A 4-component array that represents the color to use to clear the resource view.</p> </dd></param>
        /// <param name = "rectRef"><dd> <p>An array of <strong>D3D11_RECT</strong> structures for the rectangles in the resource view to clear. If <strong><c>null</c></strong>, <strong>ClearView</strong> clears the entire surface.</p> </dd></param>
        /// <param name = "numRects"><dd> <p>Number of rectangles in the array that the  <em>pRect</em> parameter specifies.</p> </dd></param>
        /// <remarks>
        /// <p><strong>ClearView</strong> works only on render-target views (RTVs), depth/stencil views (DSVs) on depth-only resources (resources with no stencil component), unordered-access views (UAVs), or any video view of a <strong>Texture2D</strong> surface. The runtime drops invalid calls. Empty rectangles in the <em>pRect</em> array are a no-op. A rectangle is empty if the top value equals the bottom value or the left value equals the right value.</p><p><strong>ClearView</strong> doesn?t support 3D textures.</p><p><strong>ClearView</strong> applies the same color value to all array slices in a view; all rectangles in the <em>pRect</em> array correspond to each array slice.  The <em>pRect</em> array of rectangles is a set of areas to clear on a single surface.  If the view is an array, <strong>ClearView</strong> clears all the rectangles on each array slice individually.</p><p>When you apply rectangles to buffers, set the top value to 0 and the bottom value to 1 and set the left value and right value to describe the extent within the buffer. When the top value equals the bottom value or the left value equals the right value, the rectangle is empty and a no-op is achieved.</p><p>The driver converts and clamps color values to the destination format as appropriate per Direct3D conversion rules.  For example, if the format of the view is <strong>DXGI_FORMAT_R8G8B8A8_UNORM</strong>, the driver clamps inputs to 0.0f to 1.0f (+INF -&gt; 1.0f (0XFF)/NaN -&gt; 0.0f).</p><p>If the format is integer, such as <strong>DXGI_FORMAT_R8G8B8A8_UINT</strong>, the runtime interprets inputs as integral floats. Therefore, 235.0f maps to 235 (rounds to zero, out of range/INF values clamp to target range, and NaN to 0).</p><p>Here are the color mappings:</p><ul> <li>Color[0]: R (or Y for video)</li> <li>Color[1]: G (or U/Cb for video)</li> <li>Color[2]: B (or V/Cr for video)</li> <li>Color[3]: A</li> </ul><p>For video views with YUV or YCbBr formats, <strong>ClearView</strong> doesn't convert color values. In situations where the format name doesn?t indicate _UNORM,  _UINT, and so on, <strong>ClearView</strong> assumes _UINT. Therefore, 235.0f maps to 235 (rounds to zero, out of range/INF values clamp to target range, and NaN to 0).</p>
        /// </remarks>
        /// <doc-id>hh404601</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::ClearView([In] ID3D11View* pView,[In] const SHARPDX_COLOR4* Color,[In, Buffer, Optional] const RECT* pRect,[In] unsigned int NumRects)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::ClearView</unmanaged-short>
        public unsafe void ClearView(SharpDX.Direct3D11.ResourceView viewRef, SharpDX.Mathematics.Interop.RawColor4 color, SharpDX.Mathematics.Interop.RawRectangle[] rectRef, System.Int32 numRects)
        {
            System.IntPtr viewRef_ = System.IntPtr.Zero;
            viewRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.ResourceView>(viewRef);
            fixed (void *rectRef_ = rectRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)viewRef_, &color, rectRef_, numRects, (*(void ***)this._nativePointer)[132]);
        }

        /// <summary>
        /// <p>Discards the specified elements in a resource view from the device context.</p>
        /// </summary>
        /// <param name = "resourceViewRef"><dd>  <p> A reference to the <strong><see cref = "SharpDX.Direct3D11.ResourceView"/></strong> interface for the resource view to discard. The resource that underlies the view must have been created with usage <strong>D3D11_USAGE_DEFAULT</strong> or <strong>D3D11_USAGE_DYNAMIC</strong>, otherwise the runtime drops the call to <strong>DiscardView1</strong>; if the debug layer is enabled, the runtime returns an error message. </p> </dd></param>
        /// <param name = "rectsRef"><dd>  <p> An array of <strong>D3D11_RECT</strong> structures for the rectangles in the resource view to discard. If <strong><c>null</c></strong>, <strong>DiscardView1</strong> discards the entire view and behaves the same as <strong>DiscardView</strong>. </p> </dd></param>
        /// <param name = "numRects"><dd>  <p> Number of rectangles in the array that the  <em>pRects</em> parameter specifies. </p> </dd></param>
        /// <remarks>
        /// <p><strong>DiscardView1</strong> informs the graphics processing unit (GPU) that the existing content in the specified elements in the resource view that <em>pResourceView</em> points to is no longer needed.  The view can be an SRV, RTV, UAV, or DSV.  <strong>DiscardView1</strong> is a variation on the <strong>DiscardResource</strong> method.  <strong>DiscardView1</strong> allows you to discard elements of a subset of a resource that is in a view (such as elements of a single miplevel).  More importantly, <strong>DiscardView1</strong> provides a convenience because often views are what are being bound and unbound at the pipeline.  Some pipeline bindings do not have views, such as stream output.  In that situation, <strong>DiscardResource</strong> can do the job for any resource. </p>
        /// </remarks>
        /// <doc-id>jj247573</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::DiscardView1([In] ID3D11View* pResourceView,[In, Buffer, Optional] const RECT* pRects,[In] unsigned int NumRects)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::DiscardView1</unmanaged-short>
        public unsafe void DiscardView1(SharpDX.Direct3D11.ResourceView resourceViewRef, SharpDX.Mathematics.Interop.RawRectangle[] rectsRef, System.Int32 numRects)
        {
            System.IntPtr resourceViewRef_ = System.IntPtr.Zero;
            resourceViewRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.ResourceView>(resourceViewRef);
            fixed (void *rectsRef_ = rectsRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)resourceViewRef_, rectsRef_, numRects, (*(void ***)this._nativePointer)[133]);
        }

        /// <summary>
        /// <p>Sets the constant buffers that the vertex shader pipeline stage uses.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd>  <p>Number of buffers to set (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - <em>StartSlot</em>).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd>  <p>Array of constant buffers being given to the device.</p> </dd></param>
        /// <param name = "firstConstantRef"><dd>  <p>An array that holds the offsets into the buffers that  <em>ppConstantBuffers</em> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants.</p> </dd></param>
        /// <param name = "numConstantsRef"><dd>  <p>An array that holds the numbers of constants in the buffers that  <em>ppConstantBuffers</em> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <em>pFirstConstant</em> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096]. </p> </dd></param>
        /// <remarks>
        /// <p>The runtime drops the call to <strong>VSSetConstantBuffers1</strong> if the number of constants to which <em>pNumConstants</em> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <em>pFirstConstant</em> and <em>pFirstConstant</em> + <em>pNumConstants</em> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <em>pFirstConstant</em>, value in an element of <em>pFirstConstant</em> + value in an element of <em>pNumConstants</em>]. The runtime also drops the call to <strong>VSSetConstantBuffers1</strong> on existing drivers that don't support this offsetting.</p><p>The runtime will emulate this feature for feature level 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</p><p>From the shader?s point of view, element [0] in the constant buffers array is the constant at <em>pFirstConstant</em>.</p><p>Out of bounds access to the constant buffers from the shader to the range that is defined by <em>pFirstConstant</em> and <em>pNumConstants</em> returns 0. </p><p>If <em>pFirstConstant</em> and <em>pNumConstants</em> arrays are <strong><c>null</c></strong>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <strong>VSSetConstantBuffers</strong> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</p><p>If either <em>pFirstConstant</em> or <em>pNumConstants</em> is <strong><c>null</c></strong>, the other parameter must also be <strong><c>null</c></strong>.</p>
        /// </remarks>
        /// <doc-id>hh446795</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::VSSetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers,[In, Buffer, Optional] const unsigned int* pFirstConstant,[In, Buffer, Optional] const unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::VSSetConstantBuffers1</unmanaged-short>
        public unsafe void VSSetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.ComArray<SharpDX.Direct3D11.Buffer> constantBuffersOut, System.Int32[] firstConstantRef, System.Int32[] numConstantsRef)
        {
            fixed (void *numConstantsRef_ = numConstantsRef)
                fixed (void *firstConstantRef_ = firstConstantRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)(constantBuffersOut?.NativePointer ?? System.IntPtr.Zero), firstConstantRef_, numConstantsRef_, (*(void ***)this._nativePointer)[119]);
        }

        /// <summary>
        /// <p>Sets the constant buffers that the vertex shader pipeline stage uses.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd>  <p>Number of buffers to set (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - <em>StartSlot</em>).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd>  <p>Array of constant buffers being given to the device.</p> </dd></param>
        /// <param name = "firstConstantRef"><dd>  <p>An array that holds the offsets into the buffers that  <em>ppConstantBuffers</em> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants.</p> </dd></param>
        /// <param name = "numConstantsRef"><dd>  <p>An array that holds the numbers of constants in the buffers that  <em>ppConstantBuffers</em> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <em>pFirstConstant</em> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096]. </p> </dd></param>
        /// <remarks>
        /// <p>The runtime drops the call to <strong>VSSetConstantBuffers1</strong> if the number of constants to which <em>pNumConstants</em> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <em>pFirstConstant</em> and <em>pFirstConstant</em> + <em>pNumConstants</em> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <em>pFirstConstant</em>, value in an element of <em>pFirstConstant</em> + value in an element of <em>pNumConstants</em>]. The runtime also drops the call to <strong>VSSetConstantBuffers1</strong> on existing drivers that don't support this offsetting.</p><p>The runtime will emulate this feature for feature level 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</p><p>From the shader?s point of view, element [0] in the constant buffers array is the constant at <em>pFirstConstant</em>.</p><p>Out of bounds access to the constant buffers from the shader to the range that is defined by <em>pFirstConstant</em> and <em>pNumConstants</em> returns 0. </p><p>If <em>pFirstConstant</em> and <em>pNumConstants</em> arrays are <strong><c>null</c></strong>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <strong>VSSetConstantBuffers</strong> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</p><p>If either <em>pFirstConstant</em> or <em>pNumConstants</em> is <strong><c>null</c></strong>, the other parameter must also be <strong><c>null</c></strong>.</p>
        /// </remarks>
        /// <doc-id>hh446795</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::VSSetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers,[In, Buffer, Optional] const unsigned int* pFirstConstant,[In, Buffer, Optional] const unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::VSSetConstantBuffers1</unmanaged-short>
        private unsafe void VSSetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, System.IntPtr constantBuffersOut, System.IntPtr firstConstantRef, System.IntPtr numConstantsRef)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut, (void *)firstConstantRef, (void *)numConstantsRef, (*(void ***)this._nativePointer)[119]);
        }

        /// <summary>
        /// <p>Sets the constant buffers that the hull-shader stage of the pipeline uses.</p>
        /// </summary>
        /// <param name = "startSlot">No documentation.</param>
        /// <param name = "numBuffers">No documentation.</param>
        /// <param name = "constantBuffersOut">No documentation.</param>
        /// <param name = "firstConstantRef">No documentation.</param>
        /// <param name = "numConstantsRef">No documentation.</param>
        /// <remarks>
        /// <p>The runtime drops the call to <strong>HSSetConstantBuffers1</strong> if the number of constants to which <em>pNumConstants</em> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <em>pFirstConstant</em> and <em>pFirstConstant</em> + <em>pNumConstants</em> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <em>pFirstConstant</em>, value in an element of <em>pFirstConstant</em> + value in an element of <em>pNumConstants</em>]. The runtime also drops the call to <strong>HSSetConstantBuffers1</strong> on existing drivers that don't support this offsetting.</p><p>The runtime will emulate this feature for feature level 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</p><p>From the shader?s point of view, element [0] in the constant buffers array is the constant at <em>pFirstConstant</em>.</p><p>Out of bounds access to the constant buffers from the shader to the range that is defined by <em>pFirstConstant</em> and <em>pNumConstants</em> returns 0. </p><p>If the <em>pFirstConstant</em> and <em>pNumConstants</em> arrays are <strong><c>null</c></strong>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <strong>HSSetConstantBuffers</strong> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</p><p>If either <em>pFirstConstant</em> or <em>pNumConstants</em> is <strong><c>null</c></strong>, the other parameter must also be <strong><c>null</c></strong>.</p>
        /// </remarks>
        /// <doc-id>hh404642</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::HSSetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers,[In, Buffer, Optional] const unsigned int* pFirstConstant,[In, Buffer, Optional] const unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::HSSetConstantBuffers1</unmanaged-short>
        public unsafe void HSSetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.ComArray<SharpDX.Direct3D11.Buffer> constantBuffersOut, System.Int32[] firstConstantRef, System.Int32[] numConstantsRef)
        {
            fixed (void *numConstantsRef_ = numConstantsRef)
                fixed (void *firstConstantRef_ = firstConstantRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)(constantBuffersOut?.NativePointer ?? System.IntPtr.Zero), firstConstantRef_, numConstantsRef_, (*(void ***)this._nativePointer)[120]);
        }

        /// <summary>
        /// <p>Sets the constant buffers that the hull-shader stage of the pipeline uses.</p>
        /// </summary>
        /// <param name = "startSlot">No documentation.</param>
        /// <param name = "numBuffers">No documentation.</param>
        /// <param name = "constantBuffersOut">No documentation.</param>
        /// <param name = "firstConstantRef">No documentation.</param>
        /// <param name = "numConstantsRef">No documentation.</param>
        /// <remarks>
        /// <p>The runtime drops the call to <strong>HSSetConstantBuffers1</strong> if the number of constants to which <em>pNumConstants</em> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <em>pFirstConstant</em> and <em>pFirstConstant</em> + <em>pNumConstants</em> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <em>pFirstConstant</em>, value in an element of <em>pFirstConstant</em> + value in an element of <em>pNumConstants</em>]. The runtime also drops the call to <strong>HSSetConstantBuffers1</strong> on existing drivers that don't support this offsetting.</p><p>The runtime will emulate this feature for feature level 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</p><p>From the shader?s point of view, element [0] in the constant buffers array is the constant at <em>pFirstConstant</em>.</p><p>Out of bounds access to the constant buffers from the shader to the range that is defined by <em>pFirstConstant</em> and <em>pNumConstants</em> returns 0. </p><p>If the <em>pFirstConstant</em> and <em>pNumConstants</em> arrays are <strong><c>null</c></strong>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <strong>HSSetConstantBuffers</strong> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</p><p>If either <em>pFirstConstant</em> or <em>pNumConstants</em> is <strong><c>null</c></strong>, the other parameter must also be <strong><c>null</c></strong>.</p>
        /// </remarks>
        /// <doc-id>hh404642</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::HSSetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers,[In, Buffer, Optional] const unsigned int* pFirstConstant,[In, Buffer, Optional] const unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::HSSetConstantBuffers1</unmanaged-short>
        private unsafe void HSSetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, System.IntPtr constantBuffersOut, System.IntPtr firstConstantRef, System.IntPtr numConstantsRef)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut, (void *)firstConstantRef, (void *)numConstantsRef, (*(void ***)this._nativePointer)[120]);
        }

        /// <summary>
        /// <p>Sets the constant buffers that the domain-shader stage uses.</p>
        /// </summary>
        /// <param name = "startSlot"><dd> <p>Index into the zero-based array to begin setting constant buffers to (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd> <p>Number of buffers to set (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - <em>StartSlot</em>).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd> <p>Array of constant buffers being given to the device.</p> </dd></param>
        /// <param name = "firstConstantRef"><dd> <p>An array that holds the offsets into the buffers that  <em>ppConstantBuffers</em> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants.</p> </dd></param>
        /// <param name = "numConstantsRef"><dd> <p>An array that holds the numbers of constants in the buffers that  <em>ppConstantBuffers</em> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <em>pFirstConstant</em> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096]. </p> </dd></param>
        /// <remarks>
        /// <p>The runtime drops the call to <strong>DSSetConstantBuffers1</strong> if the number of constants to which <em>pNumConstants</em> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <em>pFirstConstant</em> and <em>pFirstConstant</em> + <em>pNumConstants</em> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <em>pFirstConstant</em>, value in an element of <em>pFirstConstant</em> + value in an element of <em>pNumConstants</em>]. The runtime also drops the call to <strong>DSSetConstantBuffers1</strong> on existing drivers that don't support this offsetting.</p><p>The runtime will emulate this feature for feature level 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</p><p>From the shader?s point of view, element [0] in the constant buffers array is the constant at <em>pFirstConstant</em>.</p><p>Out of bounds access to the constant buffers from the shader to the range that is defined by <em>pFirstConstant</em> and <em>pNumConstants</em> returns 0. </p><p>If <em>pFirstConstant</em> and <em>pNumConstants</em> arrays are <strong><c>null</c></strong>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <strong>DSSetConstantBuffers</strong> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</p><p>If either <em>pFirstConstant</em> or <em>pNumConstants</em> is <strong><c>null</c></strong>, the other parameter must also be <strong><c>null</c></strong>.</p>
        /// </remarks>
        /// <doc-id>hh404632</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::DSSetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers,[In, Buffer, Optional] const unsigned int* pFirstConstant,[In, Buffer, Optional] const unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::DSSetConstantBuffers1</unmanaged-short>
        public unsafe void DSSetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.ComArray<SharpDX.Direct3D11.Buffer> constantBuffersOut, System.Int32[] firstConstantRef, System.Int32[] numConstantsRef)
        {
            fixed (void *numConstantsRef_ = numConstantsRef)
                fixed (void *firstConstantRef_ = firstConstantRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)(constantBuffersOut?.NativePointer ?? System.IntPtr.Zero), firstConstantRef_, numConstantsRef_, (*(void ***)this._nativePointer)[121]);
        }

        /// <summary>
        /// <p>Sets the constant buffers that the domain-shader stage uses.</p>
        /// </summary>
        /// <param name = "startSlot"><dd> <p>Index into the zero-based array to begin setting constant buffers to (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd> <p>Number of buffers to set (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - <em>StartSlot</em>).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd> <p>Array of constant buffers being given to the device.</p> </dd></param>
        /// <param name = "firstConstantRef"><dd> <p>An array that holds the offsets into the buffers that  <em>ppConstantBuffers</em> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants.</p> </dd></param>
        /// <param name = "numConstantsRef"><dd> <p>An array that holds the numbers of constants in the buffers that  <em>ppConstantBuffers</em> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <em>pFirstConstant</em> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096]. </p> </dd></param>
        /// <remarks>
        /// <p>The runtime drops the call to <strong>DSSetConstantBuffers1</strong> if the number of constants to which <em>pNumConstants</em> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <em>pFirstConstant</em> and <em>pFirstConstant</em> + <em>pNumConstants</em> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <em>pFirstConstant</em>, value in an element of <em>pFirstConstant</em> + value in an element of <em>pNumConstants</em>]. The runtime also drops the call to <strong>DSSetConstantBuffers1</strong> on existing drivers that don't support this offsetting.</p><p>The runtime will emulate this feature for feature level 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</p><p>From the shader?s point of view, element [0] in the constant buffers array is the constant at <em>pFirstConstant</em>.</p><p>Out of bounds access to the constant buffers from the shader to the range that is defined by <em>pFirstConstant</em> and <em>pNumConstants</em> returns 0. </p><p>If <em>pFirstConstant</em> and <em>pNumConstants</em> arrays are <strong><c>null</c></strong>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <strong>DSSetConstantBuffers</strong> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</p><p>If either <em>pFirstConstant</em> or <em>pNumConstants</em> is <strong><c>null</c></strong>, the other parameter must also be <strong><c>null</c></strong>.</p>
        /// </remarks>
        /// <doc-id>hh404632</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::DSSetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers,[In, Buffer, Optional] const unsigned int* pFirstConstant,[In, Buffer, Optional] const unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::DSSetConstantBuffers1</unmanaged-short>
        private unsafe void DSSetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, System.IntPtr constantBuffersOut, System.IntPtr firstConstantRef, System.IntPtr numConstantsRef)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut, (void *)firstConstantRef, (void *)numConstantsRef, (*(void ***)this._nativePointer)[121]);
        }

        /// <summary>
        /// <p>Sets the constant buffers that the geometry shader pipeline stage uses.</p>
        /// </summary>
        /// <param name = "startSlot"><dd> <p>Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd> <p>Number of buffers to set (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - <em>StartSlot</em>).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd> <p>Array of constant buffers (see <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>) being given to the device.</p> </dd></param>
        /// <param name = "firstConstantRef"><dd> <p>An array that holds the offsets into the buffers that  <em>ppConstantBuffers</em> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants.</p> </dd></param>
        /// <param name = "numConstantsRef"><dd> <p>An array that holds the numbers of constants in the buffers that  <em>ppConstantBuffers</em> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <em>pFirstConstant</em> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096]. </p> </dd></param>
        /// <remarks>
        /// <p>The runtime drops the call to <strong>GSSetConstantBuffers1</strong> if the number of constants to which <em>pNumConstants</em> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <em>pFirstConstant</em> and <em>pFirstConstant</em> + <em>pNumConstants</em> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <em>pFirstConstant</em>, value in an element of <em>pFirstConstant</em> + value in an element of <em>pNumConstants</em>]. The runtime also drops the call to <strong>GSSetConstantBuffers1</strong> on existing drivers that don't support this offsetting.</p><p>The runtime will emulate this feature for feature level 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</p><p>From the shader?s point of view, element [0] in the constant buffers array is the constant at <em>pFirstConstant</em>.</p><p>Out of bounds access to the constant buffers from the shader to the range that is defined by <em>pFirstConstant</em> and <em>pNumConstants</em> returns 0. </p><p>If <em>pFirstConstant</em> and <em>pNumConstants</em> arrays are <strong><c>null</c></strong>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <strong>GSSetConstantBuffers</strong> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</p><p>If either <em>pFirstConstant</em> or <em>pNumConstants</em> is <strong><c>null</c></strong>, the other parameter must also be <strong><c>null</c></strong>.</p>
        /// </remarks>
        /// <doc-id>hh404638</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::GSSetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers,[In, Buffer, Optional] const unsigned int* pFirstConstant,[In, Buffer, Optional] const unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::GSSetConstantBuffers1</unmanaged-short>
        public unsafe void GSSetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.ComArray<SharpDX.Direct3D11.Buffer> constantBuffersOut, System.Int32[] firstConstantRef, System.Int32[] numConstantsRef)
        {
            fixed (void *numConstantsRef_ = numConstantsRef)
                fixed (void *firstConstantRef_ = firstConstantRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)(constantBuffersOut?.NativePointer ?? System.IntPtr.Zero), firstConstantRef_, numConstantsRef_, (*(void ***)this._nativePointer)[122]);
        }

        /// <summary>
        /// <p>Sets the constant buffers that the geometry shader pipeline stage uses.</p>
        /// </summary>
        /// <param name = "startSlot"><dd> <p>Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd> <p>Number of buffers to set (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - <em>StartSlot</em>).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd> <p>Array of constant buffers (see <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>) being given to the device.</p> </dd></param>
        /// <param name = "firstConstantRef"><dd> <p>An array that holds the offsets into the buffers that  <em>ppConstantBuffers</em> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants.</p> </dd></param>
        /// <param name = "numConstantsRef"><dd> <p>An array that holds the numbers of constants in the buffers that  <em>ppConstantBuffers</em> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <em>pFirstConstant</em> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096]. </p> </dd></param>
        /// <remarks>
        /// <p>The runtime drops the call to <strong>GSSetConstantBuffers1</strong> if the number of constants to which <em>pNumConstants</em> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <em>pFirstConstant</em> and <em>pFirstConstant</em> + <em>pNumConstants</em> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <em>pFirstConstant</em>, value in an element of <em>pFirstConstant</em> + value in an element of <em>pNumConstants</em>]. The runtime also drops the call to <strong>GSSetConstantBuffers1</strong> on existing drivers that don't support this offsetting.</p><p>The runtime will emulate this feature for feature level 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</p><p>From the shader?s point of view, element [0] in the constant buffers array is the constant at <em>pFirstConstant</em>.</p><p>Out of bounds access to the constant buffers from the shader to the range that is defined by <em>pFirstConstant</em> and <em>pNumConstants</em> returns 0. </p><p>If <em>pFirstConstant</em> and <em>pNumConstants</em> arrays are <strong><c>null</c></strong>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <strong>GSSetConstantBuffers</strong> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</p><p>If either <em>pFirstConstant</em> or <em>pNumConstants</em> is <strong><c>null</c></strong>, the other parameter must also be <strong><c>null</c></strong>.</p>
        /// </remarks>
        /// <doc-id>hh404638</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::GSSetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers,[In, Buffer, Optional] const unsigned int* pFirstConstant,[In, Buffer, Optional] const unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::GSSetConstantBuffers1</unmanaged-short>
        private unsafe void GSSetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, System.IntPtr constantBuffersOut, System.IntPtr firstConstantRef, System.IntPtr numConstantsRef)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut, (void *)firstConstantRef, (void *)numConstantsRef, (*(void ***)this._nativePointer)[122]);
        }

        /// <summary>
        /// <p> Sets the constant buffers that the pixel shader pipeline stage uses, and enables the shader to access other parts of the buffer. </p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p> Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1). </p> </dd></param>
        /// <param name = "numBuffers"><dd>  <p> Number of buffers to set (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - <em>StartSlot</em>). </p> </dd></param>
        /// <param name = "constantBuffersOut"><dd>  <p> Array of constant buffers being given to the device. </p> </dd></param>
        /// <param name = "firstConstantRef"><dd>  <p> An array that holds the offsets into the buffers that  <em>ppConstantBuffers</em> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts. Each offset is measured in shader constants, which are 16 bytes (4*32-bit components). Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants. </p> </dd></param>
        /// <param name = "numConstantsRef"><dd>  <p> An array that holds the numbers of constants in the buffers that  <em>ppConstantBuffers</em> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <em>pFirstConstant</em> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096]. </p> </dd></param>
        /// <remarks>
        /// <p> To enable the shader to access other parts of the buffer, call <strong>PSSetConstantBuffers1</strong> instead of <strong>PSSetConstantBuffers</strong>. <strong>PSSetConstantBuffers1</strong> has additional parameters <em>pFirstConstant</em> and <em>pNumConstants</em>. </p><p> The runtime drops the call to <strong>PSSetConstantBuffers1</strong> if the numbers of constants to which <em>pNumConstants</em> points is larger than the maximum constant buffer size that is supported by shaders. The maximum constant buffer size that is supported by shaders holds 4096 constants, where each constant has four 32-bit components. </p><p> The values in the elements of the <em>pFirstConstant</em> and <em>pFirstConstant</em> + <em>pNumConstants</em> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the following window (range): </p><p> [value in an element of <em>pFirstConstant</em>, value in an element of <em>pFirstConstant</em> + value in an element of <em>pNumConstants</em>] </p><p> That is, the window is the range is from (value in an element of <em>pFirstConstant</em>) to (value in an element of <em>pFirstConstant</em> + value in an element of <em>pNumConstants</em>). </p><p> The runtime also drops the call to <strong>PSSetConstantBuffers1</strong> on existing drivers that do not support this offsetting. </p><p> The runtime will emulate this feature for feature level 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3. This feature is always available on new drivers for feature level 10 and higher. </p><p> From the shader?s point of view, element [0] in the constant buffers array is the constant at <em>pFirstConstant</em>. </p><p> Out of bounds access to the constant buffers from the shader to the range that is defined by <em>pFirstConstant</em> and <em>pNumConstants</em> returns 0. </p><p> If <em>pFirstConstant</em> and <em>pNumConstants</em> arrays are <strong><c>null</c></strong>, you get the same result as if you were binding the entire buffer into view. You get this same result if you call the <strong>PSSetConstantBuffers</strong> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants. </p><p> If either <em>pFirstConstant</em> or <em>pNumConstants</em> is <strong><c>null</c></strong>, the other parameter must also be <strong><c>null</c></strong>. </p>
        /// </remarks>
        /// <doc-id>hh404649</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::PSSetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers,[In, Buffer, Optional] const unsigned int* pFirstConstant,[In, Buffer, Optional] const unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::PSSetConstantBuffers1</unmanaged-short>
        public unsafe void PSSetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.ComArray<SharpDX.Direct3D11.Buffer> constantBuffersOut, System.Int32[] firstConstantRef, System.Int32[] numConstantsRef)
        {
            fixed (void *numConstantsRef_ = numConstantsRef)
                fixed (void *firstConstantRef_ = firstConstantRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)(constantBuffersOut?.NativePointer ?? System.IntPtr.Zero), firstConstantRef_, numConstantsRef_, (*(void ***)this._nativePointer)[123]);
        }

        /// <summary>
        /// <p> Sets the constant buffers that the pixel shader pipeline stage uses, and enables the shader to access other parts of the buffer. </p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p> Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1). </p> </dd></param>
        /// <param name = "numBuffers"><dd>  <p> Number of buffers to set (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - <em>StartSlot</em>). </p> </dd></param>
        /// <param name = "constantBuffersOut"><dd>  <p> Array of constant buffers being given to the device. </p> </dd></param>
        /// <param name = "firstConstantRef"><dd>  <p> An array that holds the offsets into the buffers that  <em>ppConstantBuffers</em> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts. Each offset is measured in shader constants, which are 16 bytes (4*32-bit components). Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants. </p> </dd></param>
        /// <param name = "numConstantsRef"><dd>  <p> An array that holds the numbers of constants in the buffers that  <em>ppConstantBuffers</em> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <em>pFirstConstant</em> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096]. </p> </dd></param>
        /// <remarks>
        /// <p> To enable the shader to access other parts of the buffer, call <strong>PSSetConstantBuffers1</strong> instead of <strong>PSSetConstantBuffers</strong>. <strong>PSSetConstantBuffers1</strong> has additional parameters <em>pFirstConstant</em> and <em>pNumConstants</em>. </p><p> The runtime drops the call to <strong>PSSetConstantBuffers1</strong> if the numbers of constants to which <em>pNumConstants</em> points is larger than the maximum constant buffer size that is supported by shaders. The maximum constant buffer size that is supported by shaders holds 4096 constants, where each constant has four 32-bit components. </p><p> The values in the elements of the <em>pFirstConstant</em> and <em>pFirstConstant</em> + <em>pNumConstants</em> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the following window (range): </p><p> [value in an element of <em>pFirstConstant</em>, value in an element of <em>pFirstConstant</em> + value in an element of <em>pNumConstants</em>] </p><p> That is, the window is the range is from (value in an element of <em>pFirstConstant</em>) to (value in an element of <em>pFirstConstant</em> + value in an element of <em>pNumConstants</em>). </p><p> The runtime also drops the call to <strong>PSSetConstantBuffers1</strong> on existing drivers that do not support this offsetting. </p><p> The runtime will emulate this feature for feature level 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3. This feature is always available on new drivers for feature level 10 and higher. </p><p> From the shader?s point of view, element [0] in the constant buffers array is the constant at <em>pFirstConstant</em>. </p><p> Out of bounds access to the constant buffers from the shader to the range that is defined by <em>pFirstConstant</em> and <em>pNumConstants</em> returns 0. </p><p> If <em>pFirstConstant</em> and <em>pNumConstants</em> arrays are <strong><c>null</c></strong>, you get the same result as if you were binding the entire buffer into view. You get this same result if you call the <strong>PSSetConstantBuffers</strong> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants. </p><p> If either <em>pFirstConstant</em> or <em>pNumConstants</em> is <strong><c>null</c></strong>, the other parameter must also be <strong><c>null</c></strong>. </p>
        /// </remarks>
        /// <doc-id>hh404649</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::PSSetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers,[In, Buffer, Optional] const unsigned int* pFirstConstant,[In, Buffer, Optional] const unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::PSSetConstantBuffers1</unmanaged-short>
        private unsafe void PSSetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, System.IntPtr constantBuffersOut, System.IntPtr firstConstantRef, System.IntPtr numConstantsRef)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut, (void *)firstConstantRef, (void *)numConstantsRef, (*(void ***)this._nativePointer)[123]);
        }

        /// <summary>
        /// <p>Sets the constant buffers that the compute-shader stage uses.</p>
        /// </summary>
        /// <param name = "startSlot"><dd> <p>Index into the zero-based array to begin setting constant buffers to (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd> <p>Number of buffers to set (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - <em>StartSlot</em>).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd> <p>Array of constant buffers (see <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>) being given to the device.</p> </dd></param>
        /// <param name = "firstConstantRef"><dd> <p>An array that holds the offsets into the buffers that  <em>ppConstantBuffers</em> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants.</p> </dd></param>
        /// <param name = "numConstantsRef"><dd> <p>An array that holds the numbers of constants in the buffers that  <em>ppConstantBuffers</em> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <em>pFirstConstant</em> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096]. </p> </dd></param>
        /// <remarks>
        /// <p>The runtime drops the call to <strong>CSSetConstantBuffers1</strong> if the number of constants to which <em>pNumConstants</em> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <em>pFirstConstant</em> and <em>pFirstConstant</em> + <em>pNumConstants</em> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <em>pFirstConstant</em>, value in an element of <em>pFirstConstant</em> + value in an element of <em>pNumConstants</em>]. The runtime also drops the call to <strong>CSSetConstantBuffers1</strong> on existing drivers that don't support this offsetting.</p><p>The runtime will emulate this feature for feature level 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</p><p>From the shader?s point of view, element [0] in the constant buffers array is the constant at <em>pFirstConstant</em>.</p><p>Out of bounds access to the constant buffers from the shader to the range that is defined by <em>pFirstConstant</em> and <em>pNumConstants</em> returns 0. </p><p>If <em>pFirstConstant</em> and <em>pNumConstants</em> arrays are <strong><c>null</c></strong>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <strong>CSSetConstantBuffers</strong> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</p><p>If either <em>pFirstConstant</em> or <em>pNumConstants</em> is <strong><c>null</c></strong>, the other parameter must also be <strong><c>null</c></strong>.</p>
        /// </remarks>
        /// <doc-id>hh404610</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::CSSetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers,[In, Buffer, Optional] const unsigned int* pFirstConstant,[In, Buffer, Optional] const unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::CSSetConstantBuffers1</unmanaged-short>
        public unsafe void CSSetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.ComArray<SharpDX.Direct3D11.Buffer> constantBuffersOut, System.Int32[] firstConstantRef, System.Int32[] numConstantsRef)
        {
            fixed (void *numConstantsRef_ = numConstantsRef)
                fixed (void *firstConstantRef_ = firstConstantRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)(constantBuffersOut?.NativePointer ?? System.IntPtr.Zero), firstConstantRef_, numConstantsRef_, (*(void ***)this._nativePointer)[124]);
        }

        /// <summary>
        /// <p>Sets the constant buffers that the compute-shader stage uses.</p>
        /// </summary>
        /// <param name = "startSlot"><dd> <p>Index into the zero-based array to begin setting constant buffers to (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd> <p>Number of buffers to set (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - <em>StartSlot</em>).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd> <p>Array of constant buffers (see <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>) being given to the device.</p> </dd></param>
        /// <param name = "firstConstantRef"><dd> <p>An array that holds the offsets into the buffers that  <em>ppConstantBuffers</em> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants.</p> </dd></param>
        /// <param name = "numConstantsRef"><dd> <p>An array that holds the numbers of constants in the buffers that  <em>ppConstantBuffers</em> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <em>pFirstConstant</em> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096]. </p> </dd></param>
        /// <remarks>
        /// <p>The runtime drops the call to <strong>CSSetConstantBuffers1</strong> if the number of constants to which <em>pNumConstants</em> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <em>pFirstConstant</em> and <em>pFirstConstant</em> + <em>pNumConstants</em> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <em>pFirstConstant</em>, value in an element of <em>pFirstConstant</em> + value in an element of <em>pNumConstants</em>]. The runtime also drops the call to <strong>CSSetConstantBuffers1</strong> on existing drivers that don't support this offsetting.</p><p>The runtime will emulate this feature for feature level 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</p><p>From the shader?s point of view, element [0] in the constant buffers array is the constant at <em>pFirstConstant</em>.</p><p>Out of bounds access to the constant buffers from the shader to the range that is defined by <em>pFirstConstant</em> and <em>pNumConstants</em> returns 0. </p><p>If <em>pFirstConstant</em> and <em>pNumConstants</em> arrays are <strong><c>null</c></strong>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <strong>CSSetConstantBuffers</strong> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</p><p>If either <em>pFirstConstant</em> or <em>pNumConstants</em> is <strong><c>null</c></strong>, the other parameter must also be <strong><c>null</c></strong>.</p>
        /// </remarks>
        /// <doc-id>hh404610</doc-id>
        /// <unmanaged>void ID3D11DeviceContext1::CSSetConstantBuffers1([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers,[In, Buffer, Optional] const unsigned int* pFirstConstant,[In, Buffer, Optional] const unsigned int* pNumConstants)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext1::CSSetConstantBuffers1</unmanaged-short>
        private unsafe void CSSetConstantBuffers1(System.Int32 startSlot, System.Int32 numBuffers, System.IntPtr constantBuffersOut, System.IntPtr firstConstantRef, System.IntPtr numConstantsRef)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut, (void *)firstConstantRef, (void *)numConstantsRef, (*(void ***)this._nativePointer)[124]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("420d5b32-b90c-4da4-bef0-359f6a24a83a")]
    public partial class DeviceContext2 : SharpDX.Direct3D11.DeviceContext1
    {
        public DeviceContext2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DeviceContext2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DeviceContext2(nativePtr);
        /// <summary>
        /// <p> Allows apps to determine when either a capture or profiling request is enabled.</p>
        /// </summary>
        /// <remarks>
        /// <p>Returns <strong>TRUE</strong> if the capture tool is present and capturing or the app is being profiled such that <strong>SetMarkerInt</strong> or <strong>BeginEventInt</strong> will be logged to <strong>ETW</strong>. Otherwise, it returns <strong><see cref = "SharpDX.Result.False"/></strong>. Apps can use this to turn off self-throttling mechanisms in order to accurately capture what is currently being seen as app output. Apps can also avoid generating event markers and the associated overhead it may entail when there is no benefit to do so. </p><p>If apps detect that capture is being performed, they can prevent the Direct3D debugging tools, such as Microsoft Visual Studio?2013, from capturing them. The purpose of the <strong>D3D11_CREATE_DEVICE_PREVENT_ALTERING_LAYER_SETTINGS_FROM_REGISTRY</strong> flag prior to Windows?8.1 was to allow the Direct3D runtime to prevent debugging tools from capturing apps.</p>
        /// </remarks>
        /// <doc-id>dn280504</doc-id>
        /// <unmanaged>IsAnnotationEnabled</unmanaged>
        /// <unmanaged-short>IsAnnotationEnabled</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsAnnotationEnabled
        {
            get => IsAnnotationEnabled_();
        }

        /// <summary>
        /// <p>Updates mappings of tile locations in tiled resources to memory locations in a tile pool.</p>
        /// </summary>
        /// <param name = "tiledResourceRef"><dd>  <p>A reference to the tiled resource.</p> </dd></param>
        /// <param name = "numTiledResourceRegions"><dd>  <p>The number of tiled resource regions.</p> </dd></param>
        /// <param name = "tiledResourceRegionStartCoordinatesRef"><dd>  <p> An array of <strong><see cref = "SharpDX.Direct3D11.TiledResourceCoordinate"/></strong> structures that describe the starting coordinates of the tiled resource regions. The <em>NumTiledResourceRegions</em> parameter specifies the number of <strong><see cref = "SharpDX.Direct3D11.TiledResourceCoordinate"/></strong> structures in the array. </p> </dd></param>
        /// <param name = "tiledResourceRegionSizesRef"><dd>  <p> An array of <strong><see cref = "SharpDX.Direct3D11.TileRegionSize"/></strong> structures that describe the sizes of the tiled resource regions. The <em>NumTiledResourceRegions</em> parameter specifies the number of <strong><see cref = "SharpDX.Direct3D11.TileRegionSize"/></strong> structures in the array. </p> </dd></param>
        /// <param name = "tilePoolRef"><dd>  <p>A reference to the tile pool.</p> </dd></param>
        /// <param name = "numRanges"><dd>  <p>The number of tile-pool ranges.</p> </dd></param>
        /// <param name = "rangeFlagsRef"><dd>  <p> An array of <strong><see cref = "SharpDX.Direct3D11.TileRangeFlags"/></strong> values that describe each tile-pool range. The <em>NumRanges</em> parameter specifies the number of values in the array. </p> </dd></param>
        /// <param name = "tilePoolStartOffsetsRef"><dd>  <p>An array of offsets into the tile pool. These are 0-based tile offsets, counting in tiles (not bytes).</p> </dd></param>
        /// <param name = "rangeTileCountsRef"><dd>  <p>An array of tiles. </p> <p> An array of values that specify the number of tiles in each tile-pool range. The <em>NumRanges</em> parameter specifies the number of values in the array. </p> </dd></param>
        /// <param name = "flags"><dd>  <p> A combination of <strong>D3D11_TILE_MAPPING_FLAGS</strong> values that are combined by using a bitwise OR operation. </p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns one of the following:</p><ul> <li> Returns <strong>E_INVALIDARG</strong> if various conditions such as invalid flags result in the call being dropped.<p>The debug layer will emit an error.</p> </li> <li> Returns <strong>E_OUTOFMEMORY</strong> if the call results in the driver having to allocate space for new page table mappings but running out of memory.<p>If out of memory occurs when this is called in a commandlist and the commandlist is being executed, the device will be removed. Apps can avoid this situation by only doing update calls that change existing mappings from tiled resources within commandlists (so drivers will not have to allocate page table memory, only change the mapping).</p> </li> <li> Returns <strong><see cref = "DeviceRemoved"/></strong> if the video card has been physically removed from the system, or a driver upgrade for the video card has occurred. </li> </ul></returns>
        /// <remarks>
        /// <p>In a single call to <strong>UpdateTileMappings</strong>, you can map one or more ranges of resource tiles to one or more ranges of tile-pool tiles. </p><p>You can organize the parameters of  <strong>UpdateTileMappings</strong> in these ways to perform an update:</p><ul> <li><strong>Tiled resource whose mappings are updated.</strong> This is a resource that was created with the <strong>D3D11_RESOURCE_MISC_TILED</strong> flag. Mappings start off all <c>null</c> when a resource is initially created.</li> <li><strong>Set of tile regions on the tiled resource whose mappings are updated.</strong> You can make one <strong>UpdateTileMappings</strong> call to update many mappings or multiple calls with a bit more API call overhead as well if that is more convenient. <em>NumTiledResourceRegions</em> specifies how many regions there are, <em>pTiledResourceRegionStartCoordinates</em> and <em>pTiledResourceRegionSizes</em> are each arrays that identify the start location and extend of each region. If <em>NumTiledResourceRegions</em> is 1, for convenience either or both of the arrays that describe the regions can be <c>null</c>.  <c>null</c> for <em>pTiledResourceRegionStartCoordinates</em> means the start coordinate is all 0s, and <c>null</c> for <em>pTiledResourceRegionSizes</em> identifies a default region that is the full set of tiles for the entire tiled resource, including all mipmaps, array slices, or both.  <p>If <em>pTiledResourceRegionStartCoordinates</em> isn't <c>null</c> and <em>pTiledResourceRegionSizes</em> is <c>null</c>, the region size defaults to 1 tile for all regions.  This makes it easy to define mappings for a set of individual tiles each at disparate locations by providing an array of locations in <em>pTiledResourceRegionStartCoordinates</em> without having to send an array of <em>pTiledResourceRegionSizes</em> all set to 1.</p> <p>The updates are applied from first region to last; so, if regions overlap in a single call, the updates later in the list overwrite the areas that overlap with previous updates.</p> </li> <li><strong>Tile pool that provides memory where tile mappings can go.</strong> A tiled resource can point to a single tile pool at a time.  If a new tile pool is specified (for the first time or different from the last time a tile pool was specified), all existing tile mappings for the tiled resource are cleared and the new set of mappings in the current <strong>UpdateTileMappings</strong> call are applied for the new tile pool. If no tile pool is specified (<c>null</c>) or the same tile pool as a previous <strong>UpdateTileMappings</strong> call is provided, the <strong>UpdateTileMappings</strong> call just adds the new mappings to existing ones (overwriting on overlap). If <strong>UpdateTileMappings</strong> only defines <c>null</c> mappings, you don't need to specify a tile pool because it is irrelevant. But if you specify a tile pool anyway, it takes the same behavior as previously described when providing a tile pool. </li> <li><strong>Set of tile ranges where mappings are going.</strong> Each given tile range can specify one of a few types of ranges: a range of tiles in a tile pool (default), a count of tiles in the tiled resource to map to a single tile in a tile pool (sharing the tile), a count of tile mappings in the tiled resource to skip and leave as they are, or a count of tiles in the tile pool to map to <c>null</c>.<p><em>NumRanges</em> specifies the number of tile ranges, where the total tiles identified across all ranges must match the total number of tiles in the tile regions from the previously described tiled resource.  Mappings are defined by iterating through the tiles in the tile regions in sequential order - x then y then z order for box regions - while walking through the set of tile ranges in sequential order.  The breakdown of tile regions doesn't have to line up with the breakdown of tile ranges, but the total number of tiles on both sides must be equal so that each tiled resource tile specified has a mapping specified.</p> <p><em>pRangeFlags</em>, <em>pTilePoolStartOffsets</em>, and <em>pRangeTileCounts</em> are all arrays, of size <em>NumRanges</em>, that describe the tile ranges.  If <em>pRangeFlags</em> is <c>null</c>, all ranges are sequential tiles in the tile pool; otherwise, for each range i, pRangeFlags[i] identifies how the mappings in that range of tiles work:</p> <ul> <li>If pRangeFlags[i] is 0, that range defines sequential tiles in the tile pool, with the number of tiles being pRangeTileCounts[i] and the starting location pTilePoolStartOffsets[i].  If <em>NumRanges</em> is 1, <em>pRangeTileCounts</em> can be <c>null</c> and defaults to the total number of tiles specified by all the tile regions.</li> <li>If pRangeFlags[i] is <strong>D3D11_TILE_RANGE_REUSE_SINGLE_TILE</strong>, pTilePoolStartOffsets[i] identifies the single tile in the tile pool to map to, and pRangeTileCounts[i] specifies how many tiles from the tile regions to map to that tile pool location.  If <em>NumRanges</em> is 1, <em>pRangeTileCounts</em> can be <c>null</c> and defaults to the total number of tiles specified by all the tile regions.</li> <li>If pRangeFlags[i] is <strong>D3D11_TILE_RANGE_NULL</strong>, pRangeTileCounts[i] specifies how many tiles from the tile regions to map to <c>null</c>.  If <em>NumRanges</em> is 1, <em>pRangeTileCounts</em> can be <c>null</c> and defaults to the total number of tiles specified by all the tile regions. pTilePoolStartOffsets[i] is ignored for <c>null</c> mappings. </li> <li>If pRangeFlags[i] is <strong>D3D11_TILE_RANGE_SKIP</strong>, pRangeTileCounts[i] specifies how many tiles from the tile regions to skip over and leave existing mappings unchanged for.  This can be useful if a tile region conveniently bounds an area of tile mappings to update except with some exceptions that need to be left the same as whatever they were mapped to before. pTilePoolStartOffsets[i] is ignored for SKIP mappings.</li> </ul> </li> <li><strong>Flags parameter for overall options.</strong> <strong>D3D11_TILE_MAPPING_NO_OVERWRITE</strong> means the caller promises that previously submitted commands to the device that may still be executing do not reference any of the tile region being updated. This allows the device to avoid having to flush previously submitted work in order to do the tile mapping  update.  If the app violates this promise by updating tile mappings for locations in tiled resources still being referenced by outstanding commands, undefined rendering behavior results, which includes the potential for significant slowdowns on some architectures.  This is like the "no overwrite" concept that exists elsewhere in the Direct3D API, except applied to tile mapping data structure itself, which in hardware is a page table. The absence of this flag requires that tile mapping updates specified by this <strong>UpdateTileMappings</strong> call must be completed before any subsequent Direct3D command can proceed.</li> </ul><p>If tile mappings have changed on a tiled resource that the app will render via <strong>RenderTargetView</strong> or <strong>DepthStencilView</strong>, the app must clear, by using the fixed function <strong>Clear</strong> APIs, the tiles that have changed within the area being rendered (mapped or not). If an app doesn't clear in these situations, the app receives undefined values when it reads from the tiled resource.  
        /// </p><strong>Note</strong>??In Direct3D 11.2, hardware can now support <strong>ClearView</strong> on depth-only formats. For more info, see <strong><see cref = "SharpDX.Direct3D11.FeatureDataD3D11Options1"/></strong>.?<p>If an app needs to preserve existing memory contents of areas in a tiled resource where mappings have changed, the app can first save the contents where tile mappings have changed, by copying them to a temporary surface, for example using <strong>CopyTiles</strong>, issuing the required <strong>Clear</strong>, and then copying the contents back.
        /// </p><p>Suppose a tile is mapped into multiple tiled resources at the same time and tile contents are manipulated by any means (render, copy, and so on) via one of the tiled resources. Then, if the same tile is to be rendered via any other tiled resource, the tile must be cleared first as previously described.
        /// </p><p>For more info about tiled resources, see Tiled resources.</p><p>Here are some examples of common <strong>UpdateTileMappings</strong> cases:</p>
        /// </remarks>
        /// <doc-id>dn280508</doc-id>
        /// <unmanaged>HRESULT ID3D11DeviceContext2::UpdateTileMappings([In] ID3D11Resource* pTiledResource,[In] unsigned int NumTiledResourceRegions,[In, Buffer, Optional] const D3D11_TILED_RESOURCE_COORDINATE* pTiledResourceRegionStartCoordinates,[In, Buffer, Optional] const D3D11_TILE_REGION_SIZE* pTiledResourceRegionSizes,[In, Optional] ID3D11Buffer* pTilePool,[In] unsigned int NumRanges,[In, Buffer, Optional] const unsigned int* pRangeFlags,[In, Buffer, Optional] const unsigned int* pTilePoolStartOffsets,[In, Buffer, Optional] const unsigned int* pRangeTileCounts,[In] unsigned int Flags)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext2::UpdateTileMappings</unmanaged-short>
        public unsafe void UpdateTileMappings(SharpDX.Direct3D11.Resource tiledResourceRef, System.Int32 numTiledResourceRegions, SharpDX.Direct3D11.TiledResourceCoordinate[] tiledResourceRegionStartCoordinatesRef, SharpDX.Direct3D11.TileRegionSize[] tiledResourceRegionSizesRef, SharpDX.Direct3D11.Buffer tilePoolRef, System.Int32 numRanges, SharpDX.Direct3D11.TileRangeFlags[] rangeFlagsRef, System.Int32[] tilePoolStartOffsetsRef, System.Int32[] rangeTileCountsRef, SharpDX.Direct3D11.TileMappingFlags flags)
        {
            System.IntPtr tiledResourceRef_ = System.IntPtr.Zero;
            System.IntPtr tilePoolRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            tiledResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(tiledResourceRef);
            tilePoolRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Buffer>(tilePoolRef);
            fixed (void *rangeTileCountsRef_ = rangeTileCountsRef)
                fixed (void *tilePoolStartOffsetsRef_ = tilePoolStartOffsetsRef)
                    fixed (void *rangeFlagsRef_ = rangeFlagsRef)
                        fixed (void *tiledResourceRegionSizesRef_ = tiledResourceRegionSizesRef)
                            fixed (void *tiledResourceRegionStartCoordinatesRef_ = tiledResourceRegionStartCoordinatesRef)
                                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)tiledResourceRef_, numTiledResourceRegions, tiledResourceRegionStartCoordinatesRef_, tiledResourceRegionSizesRef_, (void *)tilePoolRef_, numRanges, rangeFlagsRef_, tilePoolStartOffsetsRef_, rangeTileCountsRef_, unchecked ((System.Int32)flags), (*(void ***)this._nativePointer)[134]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Copies mappings from a source tiled resource to a destination tiled resource.</p>
        /// </summary>
        /// <param name = "destTiledResourceRef"><dd>  <p>A reference to the destination tiled resource.</p> </dd></param>
        /// <param name = "destRegionStartCoordinateRef"><dd>  <p> A reference to a <strong><see cref = "SharpDX.Direct3D11.TiledResourceCoordinate"/></strong> structure that describes the starting coordinates of the destination tiled resource. </p> </dd></param>
        /// <param name = "sourceTiledResourceRef"><dd>  <p>A reference to the source tiled resource.</p> </dd></param>
        /// <param name = "sourceRegionStartCoordinateRef"><dd>  <p> A reference to a <strong><see cref = "SharpDX.Direct3D11.TiledResourceCoordinate"/></strong> structure that describes the starting coordinates of the source tiled resource. </p> </dd></param>
        /// <param name = "tileRegionSizeRef"><dd>  <p> A reference to a <strong><see cref = "SharpDX.Direct3D11.TileRegionSize"/></strong> structure that describes the size of the tiled region. </p> </dd></param>
        /// <param name = "flags"><dd>  <p> A combination of <strong>D3D11_TILE_MAPPING_FLAGS</strong> values that are combined by using a bitwise OR operation. The only valid value is <strong>D3D11_TILE_MAPPING_NO_OVERWRITE</strong>, which indicates that previously submitted commands to the device that may still be executing do not reference any of the tile region being updated. The device can then avoid having to flush previously submitted work to perform the tile mapping update.  If the app violates this promise by updating tile mappings for locations in tiled resources that are still being referenced by outstanding commands, undefined rendering behavior results, including the potential for significant slowdowns on some architectures.  This is like the "no overwrite" concept that exists elsewhere in the Direct3D API, except applied to the tile mapping data structure itself (which in hardware is a page table). The absence of the <strong>D3D11_TILE_MAPPING_NO_OVERWRITE</strong> value requires that tile mapping updates that <strong>CopyTileMappings</strong> specifies must be completed before any subsequent Direct3D command can proceed. </p> </dd></param>
        /// <returns><p> Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns one of the following: </p><ul> <li> Returns <strong>E_INVALIDARG</strong> if various conditions such as invalid flags or passing in non Tiled Resources result in the call being dropped. <p> The dest and the source regions must each entirely fit in their resource or behavior is undefined (debug layer will emit an error). </p> </li> <li> Returns <strong>E_OUTOFMEMORY</strong> if the call results in the driver having to allocate space for new page table mappings but running out of memory. <p> If out of memory occurs when this is called in a commandlist and the commandlist is being executed, the device will be removed. Applications can avoid this situation by only doing update calls that change existing mappings from Tiled Resources within commandlists (so drivers will not have to allocate page table memory, only change the mapping). </p> </li> </ul></returns>
        /// <remarks>
        /// <p><strong>CopyTileMappings</strong> helps with tasks such as shifting mappings around within and across tiled resources, for example, scrolling tiles. The source and destination regions can overlap; the result of the copy in this situation is as if the source was saved to a temp location and then from there written to the destination.</p><p>For more info about tiled resources, see Tiled resources.</p>
        /// </remarks>
        /// <doc-id>dn280500</doc-id>
        /// <unmanaged>HRESULT ID3D11DeviceContext2::CopyTileMappings([In] ID3D11Resource* pDestTiledResource,[In] const D3D11_TILED_RESOURCE_COORDINATE* pDestRegionStartCoordinate,[In] ID3D11Resource* pSourceTiledResource,[In] const D3D11_TILED_RESOURCE_COORDINATE* pSourceRegionStartCoordinate,[In] const D3D11_TILE_REGION_SIZE* pTileRegionSize,[In] unsigned int Flags)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext2::CopyTileMappings</unmanaged-short>
        public unsafe void CopyTileMappings(SharpDX.Direct3D11.Resource destTiledResourceRef, SharpDX.Direct3D11.TiledResourceCoordinate destRegionStartCoordinateRef, SharpDX.Direct3D11.Resource sourceTiledResourceRef, SharpDX.Direct3D11.TiledResourceCoordinate sourceRegionStartCoordinateRef, SharpDX.Direct3D11.TileRegionSize tileRegionSizeRef, SharpDX.Direct3D11.TileMappingFlags flags)
        {
            System.IntPtr destTiledResourceRef_ = System.IntPtr.Zero;
            System.IntPtr sourceTiledResourceRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            destTiledResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(destTiledResourceRef);
            sourceTiledResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(sourceTiledResourceRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)destTiledResourceRef_, &destRegionStartCoordinateRef, (void *)sourceTiledResourceRef_, &sourceRegionStartCoordinateRef, &tileRegionSizeRef, unchecked ((System.Int32)flags), (*(void ***)this._nativePointer)[135]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Copies tiles from buffer to tiled resource or vice versa. </p>
        /// </summary>
        /// <param name = "tiledResourceRef"><dd>  <p>A reference to a tiled resource.</p> </dd></param>
        /// <param name = "tileRegionStartCoordinateRef"><dd>  <p> A reference to a <strong><see cref = "SharpDX.Direct3D11.TiledResourceCoordinate"/></strong> structure that describes the starting coordinates of the tiled resource. </p> </dd></param>
        /// <param name = "tileRegionSizeRef"><dd>  <p> A reference to a <strong><see cref = "SharpDX.Direct3D11.TileRegionSize"/></strong> structure that describes the size of the tiled region. </p> </dd></param>
        /// <param name = "bufferRef"><dd>  <p> A reference to an <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong> that represents a default, dynamic, or staging buffer. </p> </dd></param>
        /// <param name = "bufferStartOffsetInBytes"><dd>  <p> The offset in bytes into the buffer at <em>pBuffer</em> to start the operation. </p> </dd></param>
        /// <param name = "flags"><dd>  <p> A combination of <strong><see cref = "SharpDX.Direct3D11.TileCopyFlags"/></strong>-typed values that are combined by using a bitwise OR operation and that identifies how to copy tiles. </p> </dd></param>
        /// <remarks>
        /// <p><strong>CopyTiles</strong> drops write operations to unmapped areas and handles read operations from unmapped areas (except on <strong>Tier_1</strong> tiled resources, where reading and writing unmapped areas is invalid). </p><p>If a copy operation involves writing to the same memory location multiple times because multiple locations in the destination resource are mapped to the same tile memory, the resulting write operations to multi-mapped tiles are non-deterministic and non-repeatable; that is, accesses to the tile memory happen in whatever order the hardware happens to execute the copy operation.</p><p> The tiles involved in the copy operation can't include tiles that contain packed mipmaps or results of the copy operation are undefined. To transfer data to and from mipmaps that the hardware packs into one tile, you must use the standard (that is, non-tile specific) copy and update APIs (like <strong>ID3D11DeviceContext1::CopySubresourceRegion1</strong> and <strong>ID3D11DeviceContext1::UpdateSubresource1</strong>) or <strong>ID3D11DeviceContext::GenerateMips</strong> for the whole mipmap chain. </p><p> The memory layout of the tiles in the non-tiled buffer resource side of the copy operation is linear in memory within 64 KB tiles, which the hardware and driver swizzle and deswizzle per tile as appropriate when they transfer to and from a tiled resource. For multisample antialiasing (MSAA) surfaces, the hardware and driver traverse each pixel's samples in sample-index order before they move to the next pixel. For tiles that are partially filled on the right side (for a surface that has a width not a multiple of tile width in pixels), the pitch and stride to move down a row is the full size in bytes of the number pixels that would fit across the tile if the tile was full. So, there can be a gap between each row of pixels in memory. Mipmaps that are smaller than a tile are not packed together in the linear layout, which might seem to be a waste of memory space, but as mentioned you can't use <strong>CopyTiles</strong> or <strong>ID3D11DeviceContext2::UpdateTiles</strong> to copy to mipmaps that the hardware packs together. You can just use generic copy and update APIs (like <strong>ID3D11DeviceContext1::CopySubresourceRegion1</strong> and <strong>ID3D11DeviceContext1::UpdateSubresource1</strong>) to copy small mipmaps individually. Although in the case of a generic copy API (like <strong>ID3D11DeviceContext1::CopySubresourceRegion1</strong>), the linear memory must be the same dimension as the tiled resource; <strong>ID3D11DeviceContext1::CopySubresourceRegion1</strong> can't copy from a buffer resource to a Texture2D for instance. </p><p> For more info about tiled resources, see Tiled resources. </p>
        /// </remarks>
        /// <doc-id>dn280501</doc-id>
        /// <unmanaged>void ID3D11DeviceContext2::CopyTiles([In] ID3D11Resource* pTiledResource,[In] const D3D11_TILED_RESOURCE_COORDINATE* pTileRegionStartCoordinate,[In] const D3D11_TILE_REGION_SIZE* pTileRegionSize,[In] ID3D11Buffer* pBuffer,[In] unsigned longlong BufferStartOffsetInBytes,[In] unsigned int Flags)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext2::CopyTiles</unmanaged-short>
        public unsafe void CopyTiles(SharpDX.Direct3D11.Resource tiledResourceRef, SharpDX.Direct3D11.TiledResourceCoordinate tileRegionStartCoordinateRef, SharpDX.Direct3D11.TileRegionSize tileRegionSizeRef, SharpDX.Direct3D11.Buffer bufferRef, System.Int64 bufferStartOffsetInBytes, SharpDX.Direct3D11.TileMappingFlags flags)
        {
            System.IntPtr tiledResourceRef_ = System.IntPtr.Zero;
            System.IntPtr bufferRef_ = System.IntPtr.Zero;
            tiledResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(tiledResourceRef);
            bufferRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Buffer>(bufferRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)tiledResourceRef_, &tileRegionStartCoordinateRef, &tileRegionSizeRef, (void *)bufferRef_, bufferStartOffsetInBytes, unchecked ((System.Int32)flags), (*(void ***)this._nativePointer)[136]);
        }

        /// <summary>
        /// <p>Updates tiles by copying from app memory to the tiled resource. </p>
        /// </summary>
        /// <param name = "destTiledResourceRef"><dd>  <p>A reference to a tiled resource to update.</p> </dd></param>
        /// <param name = "destTileRegionStartCoordinateRef"><dd>  <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.TiledResourceCoordinate"/></strong> structure that describes the starting coordinates of the tiled resource.</p> </dd></param>
        /// <param name = "destTileRegionSizeRef"><dd>  <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.TileRegionSize"/></strong> structure that describes the size of the tiled region.</p> </dd></param>
        /// <param name = "sourceTileDataRef"><dd>  <p>A reference to memory that contains the source tile data that <strong>UpdateTiles</strong> uses to update the tiled resource.</p> </dd></param>
        /// <param name = "flags"><dd>  <p>A combination of <strong><see cref = "SharpDX.Direct3D11.TileCopyFlags"/></strong>-typed values that are combined by using a bitwise OR operation. The only valid value is <strong>D3D11_TILE_COPY_NO_OVERWRITE</strong>. The other values aren't meaningful here, thoughby definition the <strong>D3D11_TILE_COPY_LINEAR_BUFFER_TO_SWIZZLED_TILED_RESOURCE</strong> value is basically what <strong>UpdateTiles</strong> does, but sources from app memory.</p> </dd></param>
        /// <remarks>
        /// <p><strong>UpdateTiles</strong> drops write operations to unmapped areas (except on <strong>Tier_1</strong> tiled resources, where writing to unmapped areas is invalid).  </p><p>If a copy operation involves writing to the same memory location multiple times because multiple locations in the destination resource are mapped to the same tile memory, the resulting write operations to multi-mapped tiles are non-deterministic and non-repeatable; that is, accesses to the tile memory happen in whatever order the hardware happens to execute the copy operation.</p><p>The tiles involved in the copy operation can't include tiles that contain packed mipmaps or results of the copy operation are undefined. To transfer data to and from mipmaps that the hardware packs into one tile, you must use the standard (that is, non-tile specific) copy and update APIs (like <strong>ID3D11DeviceContext1::CopySubresourceRegion1</strong> and <strong>ID3D11DeviceContext1::UpdateSubresource1</strong>) or <strong>ID3D11DeviceContext::GenerateMips</strong> for the whole mipmap chain.</p><p>The memory layout of the data on the source side of the copy operation is linear in memory within 64 KB tiles, which the hardware and driver swizzle and deswizzle per tile as appropriate when they transfer to and from a tiled resource. For multisample antialiasing (MSAA) surfaces, the hardware and driver traverse each pixel's samples in sample-index order before they move to the next pixel. For tiles that are partially filled on the right side (for a surface that has a width not a multiple of tile width in pixels), the pitch and stride to move down a row is the full size in bytes of the number pixels that would fit across the tile if the tile was full. So, there can be a gap between each row of pixels in memory. Mipmaps that are smaller than a tile are not packed together in the linear layout, which might seem to be a waste of memory space, but as mentioned you can't use <strong>ID3D11DeviceContext2::CopyTiles</strong> or <strong>UpdateTiles</strong> to copy to mipmaps that the hardware packs together. You can just use generic copy and update APIs (like <strong>ID3D11DeviceContext1::CopySubresourceRegion1</strong> and <strong>ID3D11DeviceContext1::UpdateSubresource1</strong>) to copy small mipmaps individually. Although in the case of a generic copy API (like <strong>ID3D11DeviceContext1::CopySubresourceRegion1</strong>), the linear memory must be the same dimension as the tiled resource; <strong>ID3D11DeviceContext1::CopySubresourceRegion1</strong> can't copy from a buffer resource to a Texture2D for instance.</p><p>For more info about tiled resources, see Tiled resources.</p>
        /// </remarks>
        /// <doc-id>dn280509</doc-id>
        /// <unmanaged>void ID3D11DeviceContext2::UpdateTiles([In] ID3D11Resource* pDestTiledResource,[In] const D3D11_TILED_RESOURCE_COORDINATE* pDestTileRegionStartCoordinate,[In] const D3D11_TILE_REGION_SIZE* pDestTileRegionSize,[In] const void* pSourceTileData,[In] unsigned int Flags)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext2::UpdateTiles</unmanaged-short>
        public unsafe void UpdateTiles(SharpDX.Direct3D11.Resource destTiledResourceRef, SharpDX.Direct3D11.TiledResourceCoordinate destTileRegionStartCoordinateRef, SharpDX.Direct3D11.TileRegionSize destTileRegionSizeRef, System.IntPtr sourceTileDataRef, SharpDX.Direct3D11.TileMappingFlags flags)
        {
            System.IntPtr destTiledResourceRef_ = System.IntPtr.Zero;
            destTiledResourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(destTiledResourceRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)destTiledResourceRef_, &destTileRegionStartCoordinateRef, &destTileRegionSizeRef, (void *)sourceTileDataRef, unchecked ((System.Int32)flags), (*(void ***)this._nativePointer)[137]);
        }

        /// <summary>
        /// <p>Resizes a tile pool.</p>
        /// </summary>
        /// <param name = "tilePoolRef"><dd>  <p>A reference to an <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong> for the tile pool to resize.</p> </dd></param>
        /// <param name = "newSizeInBytes"><dd>  <p>The new size in bytes of the tile pool. The size must be a multiple of 64 KB or 0.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> if successful; otherwise, returns one of the following:</p><ul> <li>Returns <strong>E_INVALIDARG</strong> if the new tile pool size isn't a multiple of 64 KB or 0.</li> <li>Returns <strong>E_OUTOFMEMORY</strong> if the call results in the driver having to allocate space for new page table mappings but running out of memory.</li> <li>Returns <strong><see cref = "DeviceRemoved"/></strong> if the video card has been physically removed from the system, or a driver upgrade for the video card has occurred.</li> </ul><p>For <strong>E_INVALIDARG</strong> or <strong>E_OUTOFMEMORY</strong>, the existing tile pool remains unchanged, which includes existing mappings.  </p></returns>
        /// <remarks>
        /// <p><strong>ResizeTilePool</strong> increases or decreases the size of the tile pool depending on whether the app needs more or less working set for the tiled resources that are mapped into it. An app can allocate additional tile pools for new tiled resources, but if any single tiled resource needs more space than initially available in its tile pool, the app can increase the size of the resource's tile pool. A tiled resource can't have mappings into multiple tile pools simultaneously. </p><p>When you increase the size of a tile pool, additional tiles are added to the end of the tile pool via one or more new allocations by the driver; your app can't detect the breakdown into the new allocations. Existing memory in the tile pool is left untouched, and existing tiled resource mappings into that memory remain intact.</p><p>When you decrease the size of a tile pool, tiles are removed from the end (this is allowed even below the initial allocation size, down to 0). This means that new mappings can't be made past the new size. But, existing mappings past the end of the new size remain intact and useable. The memory is kept active as long as mappings to any part of the allocations that are being used for the tile pool memory remains. If after decreasing, some memory has been kept active because tile mappings are pointing to it and the tile pool is increased again (by any amount), the existing memory is reused first before any additional allocations occur to service the size of the increase. </p><p>To be able to save memory, an app has to not only decrease a tile pool but also remove and remap existing mappings past the end of the new smaller tile pool size.</p><p>The act of decreasing (and removing mappings) doesn't necessarily produce immediate memory savings. Freeing of memory depends on how granular the driver's underlying allocations for the tile pool are. When a decrease in the size of a tile pool happens to be enough to make a driver allocation unused, the driver can free the allocation. If a tile pool was increased and if you then decrease to previous sizes (and remove and remap tile mappings correspondingly), you will most likely yield memory savings. But, this scenario isn't guaranteed in the case that the sizes don't exactly align with the underlying allocation sizes chosen by the driver. </p><p>For more info about tiled resources, see Tiled resources.</p>
        /// </remarks>
        /// <doc-id>dn280505</doc-id>
        /// <unmanaged>HRESULT ID3D11DeviceContext2::ResizeTilePool([In] ID3D11Buffer* pTilePool,[In] unsigned longlong NewSizeInBytes)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext2::ResizeTilePool</unmanaged-short>
        public unsafe void ResizeTilePool(SharpDX.Direct3D11.Buffer tilePoolRef, System.Int64 newSizeInBytes)
        {
            System.IntPtr tilePoolRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            tilePoolRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Buffer>(tilePoolRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)tilePoolRef_, newSizeInBytes, (*(void ***)this._nativePointer)[138]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies a data access ordering constraint between multiple tiled resources.  For more info about this constraint, see Remarks.</p>
        /// </summary>
        /// <param name = "tiledResourceOrViewAccessBeforeBarrierRef"><dd>  <p>A reference to an <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong> or <strong><see cref = "SharpDX.Direct3D11.ResourceView"/></strong> for a resource that was created with the <strong>D3D11_RESOURCE_MISC_TILED</strong> flag.  Access operations on this object must complete before the access operations on the object that <em>pTiledResourceOrViewAccessAfterBarrier</em> specifies.</p> </dd></param>
        /// <param name = "tiledResourceOrViewAccessAfterBarrierRef"><dd>  <p>A reference to an <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong> or <strong><see cref = "SharpDX.Direct3D11.ResourceView"/></strong> for a resource that was created with the <strong>D3D11_RESOURCE_MISC_TILED</strong> flag.  Access operations on this object must begin after the access operations on the object that <em>pTiledResourceOrViewAccessBeforeBarrier</em> specifies.</p> </dd></param>
        /// <remarks>
        /// <p>Apps can use tiled resources to reuse tiles in different resources. But, a device and driver might not be able to determine whether some memory in a tile pool that was just rendered to is now being used for reading.
        /// </p><p>For example, an app can render to some tiles in a tile pool with one tiled resource but then read from the same tiles by using a different tiled resource. These tiled-resource operations are different from using one resource and then just switching from writing with <strong><see cref = "SharpDX.Direct3D11.RenderTargetView"/></strong> to reading with <strong><see cref = "SharpDX.Direct3D11.ShaderResourceView"/></strong>. The runtime already tracks and handles these one resource operations using <strong><see cref = "SharpDX.Direct3D11.RenderTargetView"/></strong> and <strong><see cref = "SharpDX.Direct3D11.ShaderResourceView"/></strong>.
        /// </p><p>When an app transitions from accessing (reading or writing) some location in a tile pool with one resource to accessing the same memory (read or write) via another tiled resource (with mappings to the same memory), the app must call <strong>TiledResourceBarrier</strong> after the first use of the resource and before the second. The parameters are the <em>pTiledResourceOrViewAccessBeforeBarrier</em> for accesses before the barrier (via rendering, copying), and the <em>pTiledResourceOrViewAccessAfterBarrier</em> for accesses after the barrier by using the same tile pool memory. If the resources are identical, the app doesn't need to call <strong>TiledResourceBarrier</strong> because this kind of hazard is already tracked and handled.
        /// </p><p>The barrier call informs the driver that operations issued to the resource before the call must complete before any accesses that occur after the call via a different tiled resource that shares the same memory.
        /// </p><p>Either or both of the parameters (before or after the barrier) can be <strong><c>null</c></strong>. <strong><c>null</c></strong> before the barrier means all tiled resource accesses before the barrier must complete before the resource specified after the barrier can be referenced by the graphics processing unit (GPU). <strong><c>null</c></strong> after the barrier means that any tiled resources accessed after the barrier can only be executed by the GPU after accesses to the tiled resources before the barrier are finished. Both <strong><c>null</c></strong> means all previous tiled resource accesses are complete before any subsequent tiled resource access can proceed. 
        /// </p><p>An app can pass a view reference, a resource, or <strong><c>null</c></strong> for each parameter. Views are allowed not only for convenience but also to allow the app to scope the barrier effect to a relevant portion of a resource.
        /// </p><p>For more info about tiled resources, see Tiled resources.</p>
        /// </remarks>
        /// <doc-id>dn280507</doc-id>
        /// <unmanaged>void ID3D11DeviceContext2::TiledResourceBarrier([In, Optional] ID3D11DeviceChild* pTiledResourceOrViewAccessBeforeBarrier,[In, Optional] ID3D11DeviceChild* pTiledResourceOrViewAccessAfterBarrier)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext2::TiledResourceBarrier</unmanaged-short>
        public unsafe void TiledResourceBarrier(SharpDX.Direct3D11.DeviceChild tiledResourceOrViewAccessBeforeBarrierRef, SharpDX.Direct3D11.DeviceChild tiledResourceOrViewAccessAfterBarrierRef)
        {
            System.IntPtr tiledResourceOrViewAccessBeforeBarrierRef_ = System.IntPtr.Zero;
            System.IntPtr tiledResourceOrViewAccessAfterBarrierRef_ = System.IntPtr.Zero;
            tiledResourceOrViewAccessBeforeBarrierRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.DeviceChild>(tiledResourceOrViewAccessBeforeBarrierRef);
            tiledResourceOrViewAccessAfterBarrierRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.DeviceChild>(tiledResourceOrViewAccessAfterBarrierRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)tiledResourceOrViewAccessBeforeBarrierRef_, (void *)tiledResourceOrViewAccessAfterBarrierRef_, (*(void ***)this._nativePointer)[139]);
        }

        /// <summary>
        /// <p> Allows apps to determine when either a capture or profiling request is enabled.</p>
        /// </summary>
        /// <returns><p>Returns <strong>TRUE</strong> if capture or profiling is enabled and <strong><see cref = "SharpDX.Result.False"/></strong> otherwise.</p></returns>
        /// <remarks>
        /// <p>Returns <strong>TRUE</strong> if the capture tool is present and capturing or the app is being profiled such that <strong>SetMarkerInt</strong> or <strong>BeginEventInt</strong> will be logged to <strong>ETW</strong>. Otherwise, it returns <strong><see cref = "SharpDX.Result.False"/></strong>. Apps can use this to turn off self-throttling mechanisms in order to accurately capture what is currently being seen as app output. Apps can also avoid generating event markers and the associated overhead it may entail when there is no benefit to do so. </p><p>If apps detect that capture is being performed, they can prevent the Direct3D debugging tools, such as Microsoft Visual Studio?2013, from capturing them. The purpose of the <strong>D3D11_CREATE_DEVICE_PREVENT_ALTERING_LAYER_SETTINGS_FROM_REGISTRY</strong> flag prior to Windows?8.1 was to allow the Direct3D runtime to prevent debugging tools from capturing apps.</p>
        /// </remarks>
        /// <doc-id>dn280504</doc-id>
        /// <unmanaged>BOOL ID3D11DeviceContext2::IsAnnotationEnabled()</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext2::IsAnnotationEnabled</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawBool IsAnnotationEnabled_()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[140]);
            return __result__;
        }

        /// <summary>
        /// <p>Allows applications to annotate graphics commands.</p>
        /// </summary>
        /// <param name = "labelRef"><dd> <p>An optional string that will be logged to <strong>ETW</strong> when ETW logging is active. If <strong>?#d?</strong> appears in the string, it will be replaced by the value of the <em>Data</em> parameter similar to the way <strong>printf</strong> works.</p> </dd></param>
        /// <param name = "data"><dd> <p>A signed data value that will be logged to ETW when ETW logging is active.</p> </dd></param>
        /// <remarks>
        /// <p><strong>SetMarkerInt</strong> allows applications to annotate graphics commands, in order to provide more context to what the GPU is executing. When ETW logging or a support tool is enabled, an additional marker is correlated between the CPU and GPU timelines. The <em>pLabel</em> and <em>Data</em> value are logged to ETW. When the appropriate ETW logging is not enabled, this method does nothing.</p>
        /// </remarks>
        /// <doc-id>dn280506</doc-id>
        /// <unmanaged>void ID3D11DeviceContext2::SetMarkerInt([In] const wchar_t* pLabel,[In] int Data)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext2::SetMarkerInt</unmanaged-short>
        public unsafe void SetMarkerInt(System.String labelRef, System.Int32 data)
        {
            fixed (char *labelRef_ = labelRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)labelRef_, data, (*(void ***)this._nativePointer)[141]);
        }

        /// <summary>
        /// <p>Allows applications to annotate the beginning of a range of graphics commands.</p>
        /// </summary>
        /// <param name = "labelRef"><dd> <p>An optional string that will be logged to <strong>ETW</strong> when ETW logging is active. If <strong>?#d?</strong> appears in the string, it will be replaced by the value of the <em>Data</em> parameter similar to the way <strong>printf</strong> works.</p> </dd></param>
        /// <param name = "data"><dd> <p>A signed data value that will be logged to ETW when ETW logging is active.</p> </dd></param>
        /// <remarks>
        /// <p><strong>BeginEventInt</strong> allows applications to annotate the beginning of a range of graphics commands, in order to provide more context to what the GPU is executing. When <strong>ETW</strong> logging (or a supported tool) is enabled, an additional marker is correlated between the CPU and GPU timelines. The <em>pLabel</em> and <em>Data</em> value are logged to ETW. When the appropriate ETW logging is not enabled, this method does nothing.</p>
        /// </remarks>
        /// <doc-id>dn280499</doc-id>
        /// <unmanaged>void ID3D11DeviceContext2::BeginEventInt([In] const wchar_t* pLabel,[In] int Data)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext2::BeginEventInt</unmanaged-short>
        public unsafe void BeginEventInt(System.String labelRef, System.Int32 data)
        {
            fixed (char *labelRef_ = labelRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)labelRef_, data, (*(void ***)this._nativePointer)[142]);
        }

        /// <summary>
        /// <p>Allows applications to annotate the end of a range of graphics commands.</p>
        /// </summary>
        /// <remarks>
        /// <p><strong>EndEvent</strong> allows applications to annotate the end of a range of graphics commands, in order to provide more context to what the GPU is executing. When the appropriate <strong>ETW</strong> logging is not enabled, this method does nothing. When ETW logging is enabled, an additional marker is correlated between the CPU and GPU timelines.</p>
        /// </remarks>
        /// <doc-id>dn280502</doc-id>
        /// <unmanaged>void ID3D11DeviceContext2::EndEvent()</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext2::EndEvent</unmanaged-short>
        public unsafe void EndEvent()
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[143]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("b4e3c01d-e79e-4637-91b2-510e9f4c9b8f")]
    public partial class DeviceContext3 : SharpDX.Direct3D11.DeviceContext2
    {
        public DeviceContext3(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DeviceContext3(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DeviceContext3(nativePtr);
        /// <summary>
        /// <p>Gets or sets whether hardware protection is enabled. </p>
        /// </summary>
        /// <doc-id>mt158224</doc-id>
        /// <unmanaged>GetHardwareProtectionState / SetHardwareProtectionState</unmanaged>
        /// <unmanaged-short>GetHardwareProtectionState</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool HardwareProtectionState
        {
            get
            {
                GetHardwareProtectionState(out var __output__);
                return __output__;
            }

            set => SetHardwareProtectionState(value);
        }

        /// <summary>
        /// <p> Sends queued-up commands in the command buffer to the graphics processing unit (GPU), with a specified context type and an optional event handle to create an event query. </p>
        /// </summary>
        /// <param name = "contextType"><dd>  <p> A <strong><see cref = "SharpDX.Direct3D11.ContextType"/></strong> that specifies the context in which a query occurs, such as a 3D command queue, 3D compute queue, 3D copy queue, video, or image. </p> </dd></param>
        /// <param name = "hEvent"><dd>  <p> An optional event handle. When specified, this method creates an event query. </p> <p><strong>Flush1</strong> operates asynchronously, therefore it can return either before or after the GPU finishes executing the queued graphics commands, which will eventually complete. To create an event query, you can call <strong>ID3D11Device::CreateQuery</strong> with the value <strong>D3D11_QUERY_EVENT</strong> value. To determine when the GPU is finished processing the graphics commands, you can then use that event query in a call to <strong>ID3D11DeviceContext::GetData</strong>. </p> </dd></param>
        /// <remarks>
        /// <p><strong>Flush1</strong> has parameters. For more information, see <strong>ID3D11DeviceContext::Flush</strong>, which doesn't have parameters. </p>
        /// </remarks>
        /// <doc-id>dn912876</doc-id>
        /// <unmanaged>void ID3D11DeviceContext3::Flush1([In] D3D11_CONTEXT_TYPE ContextType,[In, Optional] void* hEvent)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext3::Flush1</unmanaged-short>
        public unsafe void Flush1(SharpDX.Direct3D11.ContextType contextType, System.IntPtr hEvent)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)contextType), (void *)hEvent, (*(void ***)this._nativePointer)[144]);
        }

        /// <summary>
        /// <p> Sets the hardware protection state. </p>
        /// </summary>
        /// <param name = "hwProtectionEnable"><dd>  <p> Specifies whether to enable hardware protection. </p> </dd></param>
        /// <doc-id>mt158225</doc-id>
        /// <unmanaged>void ID3D11DeviceContext3::SetHardwareProtectionState([In] BOOL HwProtectionEnable)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext3::SetHardwareProtectionState</unmanaged-short>
        internal unsafe void SetHardwareProtectionState(SharpDX.Mathematics.Interop.RawBool hwProtectionEnable)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid0(this._nativePointer, hwProtectionEnable, (*(void ***)this._nativePointer)[145]);
        }

        /// <summary>
        /// <p> Gets whether hardware protection is enabled. </p>
        /// </summary>
        /// <param name = "hwProtectionEnableRef"><dd>  <p> After this method returns, points to a <see cref = "SharpDX.Mathematics.Interop.RawBool"/> that indicates whether hardware protection is enabled. </p> </dd></param>
        /// <doc-id>mt158224</doc-id>
        /// <unmanaged>void ID3D11DeviceContext3::GetHardwareProtectionState([Out] BOOL* pHwProtectionEnable)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext3::GetHardwareProtectionState</unmanaged-short>
        internal unsafe void GetHardwareProtectionState(out SharpDX.Mathematics.Interop.RawBool hwProtectionEnableRef)
        {
            hwProtectionEnableRef = default (SharpDX.Mathematics.Interop.RawBool);
            fixed (void *hwProtectionEnableRef_ = &hwProtectionEnableRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, hwProtectionEnableRef_, (*(void ***)this._nativePointer)[146]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("917600da-f58c-4c33-98d8-3e15b390fa24")]
    public partial class DeviceContext4 : SharpDX.Direct3D11.DeviceContext3
    {
        public DeviceContext4(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DeviceContext4(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DeviceContext4(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "fenceRef">No documentation.</param>
        /// <param name = "value">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D11DeviceContext4::Signal([In] ID3D11Fence* pFence,[In] unsigned longlong Value)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext4::Signal</unmanaged-short>
        public unsafe void Signal(SharpDX.Direct3D11.Fence fenceRef, System.Int64 value)
        {
            System.IntPtr fenceRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fenceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Fence>(fenceRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fenceRef_, value, (*(void ***)this._nativePointer)[147]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "fenceRef">No documentation.</param>
        /// <param name = "value">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D11DeviceContext4::Wait([In] ID3D11Fence* pFence,[In] unsigned longlong Value)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext4::Wait</unmanaged-short>
        public unsafe void Wait(SharpDX.Direct3D11.Fence fenceRef, System.Int64 value)
        {
            System.IntPtr fenceRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fenceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Fence>(fenceRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fenceRef_, value, (*(void ***)this._nativePointer)[148]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("5c1e0d8a-7c23-48f9-8c59-a92958ceff11")]
    public partial class DeviceContextState : SharpDX.Direct3D11.DeviceChild
    {
        public DeviceContextState(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DeviceContextState(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DeviceContextState(nativePtr);
    }

    [System.Runtime.InteropServices.GuidAttribute("79cf2233-7536-4948-9d36-1e4692dc5760")]
    public partial class DeviceDebug : SharpDX.ComObject
    {
        public DeviceDebug(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DeviceDebug(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DeviceDebug(nativePtr);
        /// <summary>
        /// <p>Get or sets the number of milliseconds to sleep after <strong>IDXGISwapChain::Present</strong> is called.</p>
        /// </summary>
        /// <remarks>
        /// <p>Value is set with <strong>ID3D11Debug::SetPresentPerRenderOpDelay</strong>.</p>
        /// </remarks>
        /// <doc-id>ff476368</doc-id>
        /// <unmanaged>GetPresentPerRenderOpDelay / SetPresentPerRenderOpDelay</unmanaged>
        /// <unmanaged-short>GetPresentPerRenderOpDelay</unmanaged-short>
        public System.Int32 PresentDelay
        {
            get => GetPresentDelay();
            set => SetPresentDelay(value);
        }

        /// <summary>
        /// <p>Get or sets the swap chain that the runtime will use for automatically calling <strong>IDXGISwapChain::Present</strong>.</p>
        /// </summary>
        /// <remarks>
        /// <p>The swap chain retrieved by this method will only be used if D3D11_DEBUG_FEATURE_PRESENT_PER_RENDER_OP is set in the <strong>feature mask</strong>.</p>
        /// </remarks>
        /// <doc-id>ff476369</doc-id>
        /// <unmanaged>GetSwapChain / SetSwapChain</unmanaged>
        /// <unmanaged-short>GetSwapChain</unmanaged-short>
        public SharpDX.DXGI.SwapChain SwapChain
        {
            get
            {
                GetSwapChain(out var __output__);
                return __output__;
            }

            set => SetSwapChain(value);
        }

        /// <summary>
        /// <p>Set a bit field of flags that will turn debug features on and off.</p>
        /// </summary>
        /// <param name = "mask"><dd>  <p>A combination of feature-mask flags that are combined by using a bitwise OR operation. If a flag is present, that feature will be set to on, otherwise the feature will be set to off. For descriptions of the feature-mask flags, see Remarks.</p> </dd></param>
        /// <returns><p>This method returns one of the Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??If you call this API in a Session 0 process, it returns <strong><see cref = "NotCurrentlyAvailable"/></strong>.?<p>Setting one of the following feature-mask flags will cause a rendering-operation method (listed below) to do some extra task when called. </p><table> <tr><td>D3D11_DEBUG_FEATURE_FINISH_PER_RENDER_OP (0x2)</td><td>Application will wait for the GPU to finish processing the rendering operation before continuing.</td></tr> <tr><td>D3D11_DEBUG_FEATURE_FLUSH_PER_RENDER_OP (0x1)</td><td>Runtime will additionally call <strong>ID3D11DeviceContext::Flush</strong>.</td></tr> <tr><td>D3D11_DEBUG_FEATURE_PRESENT_PER_RENDER_OP (0x4)</td><td>Runtime will call <strong>IDXGISwapChain::Present</strong>. Presentation of render buffers will occur according to the settings established by prior calls to <strong>ID3D11Debug::SetSwapChain</strong> and <strong>ID3D11Debug::SetPresentPerRenderOpDelay</strong>.</td></tr> </table><p>?</p><p>These feature-mask flags apply to the following rendering-operation methods:</p><ul> <li> <strong>ID3D11DeviceContext::Draw</strong> </li> <li> <strong>ID3D11DeviceContext::DrawIndexed</strong> </li> <li> <strong>ID3D11DeviceContext::DrawInstanced</strong> </li> <li> <strong>ID3D11DeviceContext::DrawIndexedInstanced</strong> </li> <li> <strong>ID3D11DeviceContext::DrawAuto</strong> </li> <li> <strong>ID3D11DeviceContext::ClearRenderTargetView</strong> </li> <li> <strong>ID3D11DeviceContext::ClearDepthStencilView</strong> </li> <li> <strong>ID3D11DeviceContext::CopySubresourceRegion</strong> </li> <li> <strong>ID3D11DeviceContext::CopyResource</strong> </li> <li> <strong>ID3D11DeviceContext::UpdateSubresource</strong> </li> <li> <strong>ID3D11DeviceContext::GenerateMips</strong> </li> <li> <strong>ID3D11DeviceContext::ResolveSubresource</strong> </li> </ul><p>By setting one of the following feature-mask flags, you can control the behavior of the <strong>IDXGIDevice2::OfferResources</strong> and <strong>IDXGIDevice2::ReclaimResources</strong> methods to aid in testing and debugging. </p><strong>Note</strong>??These flags are supported by the Direct3D 11.1 runtime, which is available starting with Windows?8.?<table> <tr><td>D3D11_DEBUG_FEATURE_ALWAYS_DISCARD_OFFERED_RESOURCE (0x8)</td><td>When you call <strong>IDXGIDevice2::OfferResources</strong> to offer resources while this flag is enabled, their content is always discarded.  Use this flag to test code paths that regenerate resource content on reclaim.  You cannot use this flag in combination with D3D11_DEBUG_FEATURE_NEVER_DISCARD_OFFERED_RESOURCE.</td></tr> <tr><td>D3D11_DEBUG_FEATURE_NEVER_DISCARD_OFFERED_RESOURCE (0x10)</td><td>When you call <strong>IDXGIDevice2::OfferResources</strong> to offer resources while this flag is enabled, their content is never discarded.  Use this flag to test code paths that do not need to regenerate resource content on reclaim.  You cannot use this flag in combination with D3D11_DEBUG_FEATURE_ALWAYS_DISCARD_OFFERED_RESOURCE.</td></tr> </table><p>?</p><p>The behavior of the <strong>IDXGIDevice2::OfferResources</strong> and <strong>IDXGIDevice2::ReclaimResources</strong> methods depends on system-wide memory pressure. Therefore, the scenario where content is lost and must be regenerated is uncommon for most applications.  The preceding new options in the Direct3D debug layer let you simulate that scenario consistently and test code paths.</p><p>The following flag is supported by the Direct3D 11.1 runtime.</p><table> <tr><td>D3D11_DEBUG_FEATURE_AVOID_BEHAVIOR_CHANGING_DEBUG_AIDS (0x40)</td><td>Disables the following default debugging behavior.</td></tr> </table><p>?</p><p>When the debug layer is enabled, it performs certain actions to reveal application problems.  By setting the D3D11_DEBUG_FEATURE_AVOID_BEHAVIOR_CHANGING_DEBUG_AIDS feature-mask flag, you can enable the debug layer without getting the following default debugging behavior:</p><ul> <li>If an application calls <strong>ID3D11DeviceContext1::DiscardView</strong>, the runtime fills in the resource with a random color.</li> <li>If an application calls <strong>IDXGISwapChain1::Present1</strong> with partial presentation parameters, the runtime ignores the partial presentation information.</li> </ul><p>The following flag is supported by the Direct3D 11.2 runtime.</p><table> <tr><td>D3D11_DEBUG_FEATURE_DISABLE_TILED_RESOURCE_MAPPING_TRACKING_AND_VALIDATION (0x80)</td><td>Disables the following default debugging behavior.</td></tr> </table><p>?</p><p>By default (that is, without D3D11_DEBUG_FEATURE_DISABLE_TILED_RESOURCE_MAPPING_TRACKING_AND_VALIDATION set), the debug layer validates the proper usage of all tile mappings for tiled resources for bound resources for every operation performed on the device context (for example, draw, copy, and so on).  Depending on the size of the tiled resources used (if any), this validation can be processor intensive and slow.  Apps might want to initially run with tiled resource tile mapping validation on; then, when they determine that the calling pattern is safe, they can disable the validation by setting D3D11_DEBUG_FEATURE_DISABLE_TILED_RESOURCE_MAPPING_TRACKING_AND_VALIDATION.</p><p>If D3D11_DEBUG_FEATURE_DISABLE_TILED_RESOURCE_MAPPING_TRACKING_AND_VALIDATION is set when a tiled resource is created, the debug layer never performs the tracking of tile mapping for that resource for its entire lifetime.  Alternatively, if D3D11_DEBUG_FEATURE_DISABLE_TILED_RESOURCE_MAPPING_TRACKING_AND_VALIDATION is set for any given device context method call (like draw or copy calls) involving tiled resources, the debug layer skips all tile mapping validation for the call.</p>
        /// </remarks>
        /// <doc-id>ff476371</doc-id>
        /// <unmanaged>HRESULT ID3D11Debug::SetFeatureMask([In] unsigned int Mask)</unmanaged>
        /// <unmanaged-short>ID3D11Debug::SetFeatureMask</unmanaged-short>
        internal unsafe void SetFeatureFlags(System.Int32 mask)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, mask, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get a bitfield of flags that indicates which debug features are on or off.</p>
        /// </summary>
        /// <returns><p>Mask of feature-mask flags bitwise ORed together. If a flag is present, then that feature will be set to on, otherwise the feature will be set to off. See <strong>ID3D11Debug::SetFeatureMask</strong> for a list of possible feature-mask flags.</p></returns>
        /// <doc-id>ff476367</doc-id>
        /// <unmanaged>unsigned int ID3D11Debug::GetFeatureMask()</unmanaged>
        /// <unmanaged-short>ID3D11Debug::GetFeatureMask</unmanaged-short>
        internal unsafe System.Int32 GetFeatureFlags()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            return __result__;
        }

        /// <summary>
        /// <p>Set the number of milliseconds to sleep after <strong>IDXGISwapChain::Present</strong> is called.</p>
        /// </summary>
        /// <param name = "milliseconds">No documentation.</param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??If you call this API in a Session 0 process, it returns <strong><see cref = "NotCurrentlyAvailable"/></strong>.?<p>The application will only sleep if D3D11_DEBUG_FEATURE_PRESENT_PER_RENDER_OP is a set in the <strong>feature mask</strong>. If that flag is not set the number of milliseconds is set but ignored and the application does not sleep. 10ms is used as a default value if this method is never called.</p>
        /// </remarks>
        /// <doc-id>ff476372</doc-id>
        /// <unmanaged>HRESULT ID3D11Debug::SetPresentPerRenderOpDelay([In] unsigned int Milliseconds)</unmanaged>
        /// <unmanaged-short>ID3D11Debug::SetPresentPerRenderOpDelay</unmanaged-short>
        internal unsafe void SetPresentDelay(System.Int32 milliseconds)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, milliseconds, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get the number of milliseconds to sleep after <strong>IDXGISwapChain::Present</strong> is called.</p>
        /// </summary>
        /// <returns><p>Number of milliseconds to sleep after Present is called.</p></returns>
        /// <remarks>
        /// <p>Value is set with <strong>ID3D11Debug::SetPresentPerRenderOpDelay</strong>.</p>
        /// </remarks>
        /// <doc-id>ff476368</doc-id>
        /// <unmanaged>unsigned int ID3D11Debug::GetPresentPerRenderOpDelay()</unmanaged>
        /// <unmanaged-short>ID3D11Debug::GetPresentPerRenderOpDelay</unmanaged-short>
        internal unsafe System.Int32 GetPresentDelay()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[6]);
            return __result__;
        }

        /// <summary>
        /// <p>Sets a swap chain that the runtime will use for automatically calling <strong>IDXGISwapChain::Present</strong>.</p>
        /// </summary>
        /// <param name = "swapChainRef">No documentation.</param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??If you call this API in a Session 0 process, it returns <strong><see cref = "NotCurrentlyAvailable"/></strong>.?<p>The swap chain set by this method will only be used if D3D11_DEBUG_FEATURE_PRESENT_PER_RENDER_OP is set in the <strong>feature mask</strong>.</p>
        /// </remarks>
        /// <doc-id>ff476373</doc-id>
        /// <unmanaged>HRESULT ID3D11Debug::SetSwapChain([In, Optional] IDXGISwapChain* pSwapChain)</unmanaged>
        /// <unmanaged-short>ID3D11Debug::SetSwapChain</unmanaged-short>
        internal unsafe void SetSwapChain(SharpDX.DXGI.SwapChain swapChainRef)
        {
            System.IntPtr swapChainRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            swapChainRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.SwapChain>(swapChainRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)swapChainRef_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get the swap chain that the runtime will use for automatically calling <strong>IDXGISwapChain::Present</strong>.</p>
        /// </summary>
        /// <param name = "swapChainOut">No documentation.</param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>The swap chain retrieved by this method will only be used if D3D11_DEBUG_FEATURE_PRESENT_PER_RENDER_OP is set in the <strong>feature mask</strong>.</p>
        /// </remarks>
        /// <doc-id>ff476369</doc-id>
        /// <unmanaged>HRESULT ID3D11Debug::GetSwapChain([Out] IDXGISwapChain** ppSwapChain)</unmanaged>
        /// <unmanaged-short>ID3D11Debug::GetSwapChain</unmanaged-short>
        internal unsafe void GetSwapChain(out SharpDX.DXGI.SwapChain swapChainOut)
        {
            System.IntPtr swapChainOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &swapChainOut_, (*(void ***)this._nativePointer)[8]);
            if (swapChainOut_ != System.IntPtr.Zero)
                swapChainOut = new SharpDX.DXGI.SwapChain(swapChainOut_);
            else
                swapChainOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Check to see if the draw pipeline state is valid.</p>
        /// </summary>
        /// <param name = "contextRef"><dd>  <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.DeviceContext"/></strong>, that represents a device context.</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>Use validate prior to calling a draw method (for example, <strong>ID3D11DeviceContext::Draw</strong>); validation requires the debug layer.</p>
        /// </remarks>
        /// <doc-id>ff476374</doc-id>
        /// <unmanaged>HRESULT ID3D11Debug::ValidateContext([In] ID3D11DeviceContext* pContext)</unmanaged>
        /// <unmanaged-short>ID3D11Debug::ValidateContext</unmanaged-short>
        public unsafe void ValidateContext(SharpDX.Direct3D11.DeviceContext contextRef)
        {
            System.IntPtr contextRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            contextRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.DeviceContext>(contextRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)contextRef_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Report information about a device object's lifetime.</p>
        /// </summary>
        /// <param name = "flags"><dd>  <p>A value from the <strong><see cref = "SharpDX.Direct3D11.ReportingLevel"/></strong> enumeration.</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p><strong>ReportLiveDeviceObjects</strong> uses the value in  <em>Flags</em> to determine the amount of information to report about a device object's lifetime.</p>
        /// </remarks>
        /// <doc-id>ff476370</doc-id>
        /// <unmanaged>HRESULT ID3D11Debug::ReportLiveDeviceObjects([In] D3D11_RLDO_FLAGS Flags)</unmanaged>
        /// <unmanaged-short>ID3D11Debug::ReportLiveDeviceObjects</unmanaged-short>
        public unsafe void ReportLiveDeviceObjects(SharpDX.Direct3D11.ReportingLevel flags)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)flags), (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Verifies whether the dispatch pipeline state is valid.</p>
        /// </summary>
        /// <param name = "contextRef"><dd>  <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.DeviceContext"/></strong> that represents a device context.</p> </dd></param>
        /// <returns><p>This method returns one of the return codes described in the topic Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>Use this method before you call a dispatch method (for example, <strong>ID3D11DeviceContext::Dispatch</strong>). Validation requires the debug layer.</p>
        /// </remarks>
        /// <doc-id>ff728740</doc-id>
        /// <unmanaged>HRESULT ID3D11Debug::ValidateContextForDispatch([In] ID3D11DeviceContext* pContext)</unmanaged>
        /// <unmanaged-short>ID3D11Debug::ValidateContextForDispatch</unmanaged-short>
        public unsafe void ValidateContextForDispatch(SharpDX.Direct3D11.DeviceContext contextRef)
        {
            System.IntPtr contextRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            contextRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.DeviceContext>(contextRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)contextRef_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("f582c508-0f36-490c-9977-31eece268cfa")]
    public partial class DomainShader : SharpDX.Direct3D11.DeviceChild
    {
        public DomainShader(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DomainShader(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DomainShader(nativePtr);
    }

    [System.Runtime.InteropServices.GuidAttribute("c0bfa96c-e089-44fb-8eaf-26f8796190da")]
    public partial class DomainShaderStage : CommonShaderStage<DomainShader>
    {
        public DomainShaderStage(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DomainShaderStage(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DomainShaderStage(nativePtr);
        /// <summary>
        /// <p>Bind an array of shader resources to the domain-shader stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin setting shader resources to (ranges from 0 to <see cref = "InputResourceSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numViews"><dd>  <p>Number of shader resources to set. Up to a maximum of 128 slots are available for shader resources(ranges from 0 to <see cref = "InputResourceSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "shaderResourceViewsOut"><dd>  <p>Array of <strong>shader resource view</strong> interfaces to set to the device.</p> </dd></param>
        /// <remarks>
        /// <p>If an overlapping resource view is already bound to an output slot, such as a render target, then the method will fill the destination shader resource slot with <strong><c>null</c></strong>.</p><p>For information about creating shader-resource views, see <strong>ID3D11Device::CreateShaderResourceView</strong>.</p><p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p>
        /// </remarks>
        /// <doc-id>ff476421</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::DSSetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[In, Buffer, Optional] const ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::DSSetShaderResources</unmanaged-short>
        internal override unsafe void SetShaderResources(System.Int32 startSlot, System.Int32 numViews, System.IntPtr shaderResourceViewsOut)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numViews, (void *)shaderResourceViewsOut, (*(void ***)this._nativePointer)[63]);
        }

        /// <summary>
        /// <p>Set a domain shader to the device.</p>
        /// </summary>
        /// <param name = "domainShaderRef"><dd>  <p> Pointer to a domain shader (see <strong><see cref = "SharpDX.Direct3D11.DomainShader"/></strong>). Passing in <strong><c>null</c></strong> disables the shader for this pipeline stage. </p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p> A reference to an array of class-instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <strong><c>null</c></strong> if the shader does not use any interfaces. </p> </dd></param>
        /// <param name = "numClassInstances"><dd>  <p>The number of class-instance interfaces in the array.</p> </dd></param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p>The maximum number of instances a shader can have is 256.</p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476420</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::DSSetShader([In, Optional] ID3D11DomainShader* pDomainShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[In] unsigned int NumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::DSSetShader</unmanaged-short>
        internal override unsafe void SetShader(SharpDX.Direct3D11.DomainShader domainShaderRef, SharpDX.Direct3D11.ClassInstance[] classInstancesOut, System.Int32 numClassInstances)
        {
            System.IntPtr domainShaderRef_ = System.IntPtr.Zero;
            System.IntPtr*classInstancesOut_;
            classInstancesOut_ = (System.IntPtr*)0;
            if (classInstancesOut != null)
            {
                System.IntPtr*_classInstancesOut = stackalloc System.IntPtr[classInstancesOut.Length];
                classInstancesOut_ = _classInstancesOut;
            }

            domainShaderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.DomainShader>(domainShaderRef);
            if (classInstancesOut != null)
                for (int i = 0; i < classInstancesOut.Length; ++i)
                    (classInstancesOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.ClassInstance>(classInstancesOut[i]);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)domainShaderRef_, (void *)classInstancesOut_, numClassInstances, (*(void ***)this._nativePointer)[64]);
        }

        /// <summary>
        /// <p>Set an array of sampler states to the domain-shader stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin setting samplers to (ranges from 0 to <see cref = "SamplerSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numSamplers"><dd>  <p>Number of samplers in the array. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to <see cref = "SamplerSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "samplersOut"><dd>  <p>Pointer to an array of sampler-state interfaces (see <strong><see cref = "SharpDX.Direct3D11.SamplerState"/></strong>). See Remarks.</p> </dd></param>
        /// <remarks>
        /// <p>Any sampler may be set to <strong><c>null</c></strong>; this invokes the default state, which is defined to be the following.</p><pre> //Default sampler state:
        /// <see cref = "SharpDX.Direct3D11.SamplerStateDescription"/> SamplerDesc;
        /// SamplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
        /// SamplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
        /// SamplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
        /// SamplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
        /// SamplerDesc.MipLODBias = 0;
        /// SamplerDesc.MaxAnisotropy = 1;
        /// SamplerDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;
        /// SamplerDesc.BorderColor[0] = 1.0f;
        /// SamplerDesc.BorderColor[1] = 1.0f;
        /// SamplerDesc.BorderColor[2] = 1.0f;
        /// SamplerDesc.BorderColor[3] = 1.0f;
        /// SamplerDesc.MinLOD = -FLT_MAX;
        /// SamplerDesc.MaxLOD = FLT_MAX; </pre><p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p>
        /// </remarks>
        /// <doc-id>ff476419</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::DSSetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[In, Buffer, Optional] const ID3D11SamplerState** ppSamplers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::DSSetSamplers</unmanaged-short>
        internal override unsafe void SetSamplers(System.Int32 startSlot, System.Int32 numSamplers, System.IntPtr samplersOut)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numSamplers, (void *)samplersOut, (*(void ***)this._nativePointer)[65]);
        }

        /// <summary>
        /// <p>Sets the constant buffers used by the domain-shader stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p> Index into the zero-based array to begin setting constant buffers to (ranges from 0 to <strong><see cref = "ConstantBufferApiSlotCount"/></strong> - 1). </p> </dd></param>
        /// <param name = "numBuffers"><dd>  <p> Number of buffers to set (ranges from 0 to <strong><see cref = "ConstantBufferApiSlotCount"/></strong> - <em>StartSlot</em>). </p> </dd></param>
        /// <param name = "constantBuffersOut"><dd>  <p> Array of constant buffers (see <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>) being given to the device. </p> </dd></param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p> The Direct3D 11.1 runtime, which is available starting with Windows?8, can bind a larger number of <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong> resources to the shader than the maximum constant buffer size that is supported by shaders (4096 constants ? 4*32-bit components each).  When you bind such a large buffer, the shader can access only the first 4096 4*32-bit component constants in the buffer, as if 4096 constants is the full size of the buffer. </p><p> If the application wants the shader to access other parts of the buffer, it must call the <strong>DSSetConstantBuffers1</strong> method instead. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476418</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::DSSetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::DSSetConstantBuffers</unmanaged-short>
        internal override unsafe void SetConstantBuffers(System.Int32 startSlot, System.Int32 numBuffers, System.IntPtr constantBuffersOut)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut, (*(void ***)this._nativePointer)[66]);
        }

        /// <summary>
        /// <p>Get the domain-shader resources.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin getting shader resources from (ranges from 0 to <see cref = "InputResourceSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numViews"><dd>  <p>The number of resources to get from the device. Up to a maximum of 128 slots are available for shader resources (ranges from 0 to <see cref = "InputResourceSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "shaderResourceViewsOut"><dd>  <p>Array of <strong>shader resource view</strong> interfaces to be returned by the device.</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476417</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::DSGetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[Out, Buffer, Optional] ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::DSGetShaderResources</unmanaged-short>
        internal override unsafe void GetShaderResources(System.Int32 startSlot, System.Int32 numViews, SharpDX.Direct3D11.ShaderResourceView[] shaderResourceViewsOut)
        {
            System.IntPtr*shaderResourceViewsOut_;
            shaderResourceViewsOut_ = (System.IntPtr*)0;
            if (shaderResourceViewsOut != null)
            {
                System.IntPtr*_shaderResourceViewsOut = stackalloc System.IntPtr[shaderResourceViewsOut.Length];
                shaderResourceViewsOut_ = _shaderResourceViewsOut;
            }

            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numViews, (void *)shaderResourceViewsOut_, (*(void ***)this._nativePointer)[101]);
            if (shaderResourceViewsOut != null)
                for (int i = 0; i < shaderResourceViewsOut.Length; ++i)
                    if ((shaderResourceViewsOut_)[i] != System.IntPtr.Zero)
                        shaderResourceViewsOut[i] = new SharpDX.Direct3D11.ShaderResourceView((shaderResourceViewsOut_)[i]);
                    else
                        shaderResourceViewsOut[i] = null;
        }

        /// <summary>
        /// <p>Get the domain shader currently set on the device.</p>
        /// </summary>
        /// <param name = "domainShaderOut"><dd>  <p>Address of a reference to a domain shader (see <strong><see cref = "SharpDX.Direct3D11.DomainShader"/></strong>) to be returned by the method.</p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p>Pointer to an array of class instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>).</p> </dd></param>
        /// <param name = "numClassInstancesRef"><dd>  <p>The number of class-instance elements in the array.</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476416</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::DSGetShader([Out, Optional] ID3D11DomainShader** ppDomainShader,[Out, Buffer, Optional] ID3D11ClassInstance** ppClassInstances,[InOut] unsigned int* pNumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::DSGetShader</unmanaged-short>
        internal override unsafe void GetShader(out SharpDX.Direct3D11.DomainShader domainShaderOut, SharpDX.Direct3D11.ClassInstance[] classInstancesOut, ref System.Int32 numClassInstancesRef)
        {
            System.IntPtr domainShaderOut_ = System.IntPtr.Zero;
            System.IntPtr*classInstancesOut_;
            classInstancesOut_ = (System.IntPtr*)0;
            if (classInstancesOut != null)
            {
                System.IntPtr*_classInstancesOut = stackalloc System.IntPtr[classInstancesOut.Length];
                classInstancesOut_ = _classInstancesOut;
            }

            fixed (void *numClassInstancesRef_ = &numClassInstancesRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, &domainShaderOut_, (void *)classInstancesOut_, numClassInstancesRef_, (*(void ***)this._nativePointer)[102]);
            if (domainShaderOut_ != System.IntPtr.Zero)
                domainShaderOut = new SharpDX.Direct3D11.DomainShader(domainShaderOut_);
            else
                domainShaderOut = null;
            if (classInstancesOut != null)
                for (int i = 0; i < classInstancesOut.Length; ++i)
                    if ((classInstancesOut_)[i] != System.IntPtr.Zero)
                        classInstancesOut[i] = new SharpDX.Direct3D11.ClassInstance((classInstancesOut_)[i]);
                    else
                        classInstancesOut[i] = null;
        }

        /// <summary>
        /// <p>Get an array of sampler state interfaces from the domain-shader stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into a zero-based array to begin getting samplers from (ranges from 0 to <see cref = "SamplerSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numSamplers"><dd>  <p>Number of samplers to get from a device context. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to <see cref = "SamplerSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "samplersOut"><dd>  <p>Pointer to an array of sampler-state interfaces (see <strong><see cref = "SharpDX.Direct3D11.SamplerState"/></strong>).</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476415</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::DSGetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[Out, Buffer, Optional] ID3D11SamplerState** ppSamplers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::DSGetSamplers</unmanaged-short>
        internal override unsafe void GetSamplers(System.Int32 startSlot, System.Int32 numSamplers, SharpDX.Direct3D11.SamplerState[] samplersOut)
        {
            System.IntPtr*samplersOut_;
            samplersOut_ = (System.IntPtr*)0;
            if (samplersOut != null)
            {
                System.IntPtr*_samplersOut = stackalloc System.IntPtr[samplersOut.Length];
                samplersOut_ = _samplersOut;
            }

            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numSamplers, (void *)samplersOut_, (*(void ***)this._nativePointer)[103]);
            if (samplersOut != null)
                for (int i = 0; i < samplersOut.Length; ++i)
                    if ((samplersOut_)[i] != System.IntPtr.Zero)
                        samplersOut[i] = new SharpDX.Direct3D11.SamplerState((samplersOut_)[i]);
                    else
                        samplersOut[i] = null;
        }

        /// <summary>
        /// <p>Get the constant buffers used by the domain-shader stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd>  <p>Number of buffers to retrieve (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd>  <p>Array of constant buffer interface references (see <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>) to be returned by the method.</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476414</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::DSGetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[Out, Buffer, Optional] ID3D11Buffer** ppConstantBuffers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::DSGetConstantBuffers</unmanaged-short>
        internal override unsafe void GetConstantBuffers(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.Direct3D11.Buffer[] constantBuffersOut)
        {
            System.IntPtr*constantBuffersOut_;
            constantBuffersOut_ = (System.IntPtr*)0;
            if (constantBuffersOut != null)
            {
                System.IntPtr*_constantBuffersOut = stackalloc System.IntPtr[constantBuffersOut.Length];
                constantBuffersOut_ = _constantBuffersOut;
            }

            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut_, (*(void ***)this._nativePointer)[104]);
            if (constantBuffersOut != null)
                for (int i = 0; i < constantBuffersOut.Length; ++i)
                    if ((constantBuffersOut_)[i] != System.IntPtr.Zero)
                        constantBuffersOut[i] = new SharpDX.Direct3D11.Buffer((constantBuffersOut_)[i]);
                    else
                        constantBuffersOut[i] = null;
        }

        /// <summary>
        /// <p>Set a domain shader to the device.</p>
        /// </summary>
        /// <param name = "domainShaderRef"><dd>  <p> Pointer to a domain shader (see <strong><see cref = "SharpDX.Direct3D11.DomainShader"/></strong>). Passing in <strong><c>null</c></strong> disables the shader for this pipeline stage. </p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p> A reference to an array of class-instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <strong><c>null</c></strong> if the shader does not use any interfaces. </p> </dd></param>
        /// <param name = "numClassInstances"><dd>  <p>The number of class-instance interfaces in the array.</p> </dd></param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p>The maximum number of instances a shader can have is 256.</p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476420</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::DSSetShader([In, Optional] ID3D11DomainShader* pDomainShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[In] unsigned int NumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::DSSetShader</unmanaged-short>
        internal override unsafe void SetShader(SharpDX.Direct3D11.DomainShader domainShaderRef, SharpDX.ComArray<SharpDX.Direct3D11.ClassInstance> classInstancesOut, System.Int32 numClassInstances)
        {
            System.IntPtr domainShaderRef_ = System.IntPtr.Zero;
            domainShaderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.DomainShader>(domainShaderRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)domainShaderRef_, (void *)(classInstancesOut?.NativePointer ?? System.IntPtr.Zero), numClassInstances, (*(void ***)this._nativePointer)[64]);
        }

        /// <summary>
        /// <p>Set a domain shader to the device.</p>
        /// </summary>
        /// <param name = "domainShaderRef"><dd>  <p> Pointer to a domain shader (see <strong><see cref = "SharpDX.Direct3D11.DomainShader"/></strong>). Passing in <strong><c>null</c></strong> disables the shader for this pipeline stage. </p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p> A reference to an array of class-instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <strong><c>null</c></strong> if the shader does not use any interfaces. </p> </dd></param>
        /// <param name = "numClassInstances"><dd>  <p>The number of class-instance interfaces in the array.</p> </dd></param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p>The maximum number of instances a shader can have is 256.</p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476420</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::DSSetShader([In, Optional] ID3D11DomainShader* pDomainShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[In] unsigned int NumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::DSSetShader</unmanaged-short>
        private unsafe void SetShader(System.IntPtr domainShaderRef, System.IntPtr classInstancesOut, System.Int32 numClassInstances)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)domainShaderRef, (void *)classInstancesOut, numClassInstances, (*(void ***)this._nativePointer)[64]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("affde9d1-1df7-4bb7-8a34-0f46251dab80")]
    public partial class Fence : SharpDX.Direct3D11.DeviceChild
    {
        public Fence(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Fence(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Fence(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetCompletedValue</unmanaged>
        /// <unmanaged-short>GetCompletedValue</unmanaged-short>
        public System.Int64 CompletedValue
        {
            get => GetCompletedValue();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "attributesRef">No documentation.</param>
        /// <param name = "dwAccess">No documentation.</param>
        /// <param name = "lpName">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D11Fence::CreateSharedHandle([In, Optional] const SECURITY_ATTRIBUTES* pAttributes,[In] DWORD dwAccess,[In, Optional] const wchar_t* lpName,[Out] void** pHandle)</unmanaged>
        /// <unmanaged-short>ID3D11Fence::CreateSharedHandle</unmanaged-short>
        public unsafe System.IntPtr CreateSharedHandle(SharpDX.Win32.SecurityAttributes? attributesRef, System.Int32 dwAccess, System.String lpName)
        {
            SharpDX.Win32.SecurityAttributes attributesRef_;
            System.IntPtr handleRef;
            SharpDX.Result __result__;
            if (attributesRef != null)
                attributesRef_ = attributesRef.Value;
            fixed (char *lpName_ = lpName)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, attributesRef == null ? (void *)0 : &attributesRef_, dwAccess, (void *)lpName_, &handleRef, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
            return handleRef;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>unsigned longlong ID3D11Fence::GetCompletedValue()</unmanaged>
        /// <unmanaged-short>ID3D11Fence::GetCompletedValue</unmanaged-short>
        internal unsafe System.Int64 GetCompletedValue()
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCalllong(this._nativePointer, (*(void ***)this._nativePointer)[8]);
            return __result__;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "value">No documentation.</param>
        /// <param name = "hEvent">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D11Fence::SetEventOnCompletion([In] unsigned longlong Value,[In] void* hEvent)</unmanaged>
        /// <unmanaged-short>ID3D11Fence::SetEventOnCompletion</unmanaged-short>
        public unsafe void SetEventOnCompletion(System.Int64 value, System.IntPtr hEvent)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, value, (void *)hEvent, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("38325b96-effb-4022-ba02-2e795b70275c")]
    public partial class GeometryShader : SharpDX.Direct3D11.DeviceChild
    {
        public GeometryShader(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator GeometryShader(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new GeometryShader(nativePtr);
                ///<summary>Constant StreamOutputNoRasterizedStream</summary>
        ///<unmanaged>D3D11_SO_NO_RASTERIZED_STREAM</unmanaged>
        public const int StreamOutputNoRasterizedStream = unchecked ((int)4294967295U);
                ///<summary>Constant StreamOutputStreamCount</summary>
        ///<unmanaged>D3D11_SO_STREAM_COUNT</unmanaged>
        public const int StreamOutputStreamCount = unchecked ((int)4);
                ///<summary>Constant StreamOutputOutputComponentCount</summary>
        ///<unmanaged>D3D11_SO_OUTPUT_COMPONENT_COUNT</unmanaged>
        public const int StreamOutputOutputComponentCount = unchecked ((int)128);
                ///<summary>Constant StreamOutputBufferSlotCount</summary>
        ///<unmanaged>D3D11_SO_BUFFER_SLOT_COUNT</unmanaged>
        public const int StreamOutputBufferSlotCount = unchecked ((int)4);
    }

    [System.Runtime.InteropServices.GuidAttribute("c0bfa96c-e089-44fb-8eaf-26f8796190da")]
    public partial class GeometryShaderStage : CommonShaderStage<GeometryShader>
    {
        public GeometryShaderStage(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator GeometryShaderStage(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new GeometryShaderStage(nativePtr);
        /// <summary>
        /// <p>Sets the constant buffers used by the geometry shader pipeline stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to <strong><see cref = "ConstantBufferApiSlotCount"/></strong> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd>  <p>Number of buffers to set (ranges from 0 to <strong><see cref = "ConstantBufferApiSlotCount"/></strong> - <em>StartSlot</em>).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd>  <p>Array of constant buffers (see <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>) being given to the device.</p> </dd></param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p>You can't use the <strong><see cref = "SharpDX.D3DCompiler.ConstantBuffer"/></strong> interface to get information about what is currently bound to the pipeline in the device context. But you can use <strong><see cref = "SharpDX.D3DCompiler.ConstantBuffer"/></strong> to get information from a compiled shader. For example, you can use <strong><see cref = "SharpDX.D3DCompiler.ConstantBuffer"/></strong> and <strong><see cref = "SharpDX.D3DCompiler.ShaderReflectionVariable"/></strong> to determine the slot in which a geometry shader expects a constant buffer. You can then pass this slot number to <strong>GSSetConstantBuffers</strong> to set the constant buffer. You can call the <strong>D3D11Reflect</strong> function to retrieve the address of a reference to the <strong><see cref = "SharpDX.D3DCompiler.ShaderReflection"/></strong> interface and then call <strong>ID3D11ShaderReflection::GetConstantBufferByName</strong> to get a reference to <strong><see cref = "SharpDX.D3DCompiler.ConstantBuffer"/></strong>.</p><p>The Direct3D 11.1 runtime, which is available starting with Windows?8, can bind a larger number of <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong> resources to the shader than the maximum constant buffer size that is supported by shaders (4096 constants ? 4*32-bit components each).  When you bind such a large buffer, the shader can access only the first 4096 4*32-bit component constants in the buffer, as if 4096 constants is the full size of the buffer.  </p><p>If the application wants the shader to access other parts of the buffer, it must call the <strong>GSSetConstantBuffers1</strong> method instead. </p>
        /// </remarks>
        /// <doc-id>ff476436</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::GSSetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::GSSetConstantBuffers</unmanaged-short>
        internal override unsafe void SetConstantBuffers(System.Int32 startSlot, System.Int32 numBuffers, System.IntPtr constantBuffersOut)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut, (*(void ***)this._nativePointer)[22]);
        }

        /// <summary>
        /// <p>Set a geometry shader to the device.</p>
        /// </summary>
        /// <param name = "shaderRef"><dd>  <p>Pointer to a geometry shader (see <strong><see cref = "SharpDX.Direct3D11.GeometryShader"/></strong>). Passing in <strong><c>null</c></strong> disables the shader for this pipeline stage.</p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p>A reference to an array of class-instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <strong><c>null</c></strong> if the shader does not use any interfaces.</p> </dd></param>
        /// <param name = "numClassInstances"><dd>  <p>The number of class-instance interfaces in the array.</p> </dd></param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p>The maximum number of instances a shader can have is 256.</p>
        /// </remarks>
        /// <doc-id>ff476438</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::GSSetShader([In, Optional] ID3D11GeometryShader* pShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[In] unsigned int NumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::GSSetShader</unmanaged-short>
        internal override unsafe void SetShader(SharpDX.Direct3D11.GeometryShader shaderRef, SharpDX.Direct3D11.ClassInstance[] classInstancesOut, System.Int32 numClassInstances)
        {
            System.IntPtr shaderRef_ = System.IntPtr.Zero;
            System.IntPtr*classInstancesOut_;
            classInstancesOut_ = (System.IntPtr*)0;
            if (classInstancesOut != null)
            {
                System.IntPtr*_classInstancesOut = stackalloc System.IntPtr[classInstancesOut.Length];
                classInstancesOut_ = _classInstancesOut;
            }

            shaderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.GeometryShader>(shaderRef);
            if (classInstancesOut != null)
                for (int i = 0; i < classInstancesOut.Length; ++i)
                    (classInstancesOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.ClassInstance>(classInstancesOut[i]);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)shaderRef_, (void *)classInstancesOut_, numClassInstances, (*(void ***)this._nativePointer)[23]);
        }

        /// <summary>
        /// <p>Bind an array of shader resources to the geometry shader stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin setting shader resources to (ranges from 0 to <see cref = "InputResourceSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numViews"><dd>  <p>Number of shader resources to set. Up to a maximum of 128 slots are available for shader resources(ranges from 0 to <see cref = "InputResourceSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "shaderResourceViewsOut"><dd>  <p>Array of <strong>shader resource view</strong> interfaces to set to the device.</p> </dd></param>
        /// <remarks>
        /// <p>If an overlapping resource view is already bound to an output slot, such as a render target, then the method will fill the destination shader resource slot with <strong><c>null</c></strong>.</p><p>For information about creating shader-resource views, see <strong>ID3D11Device::CreateShaderResourceView</strong>.</p><p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p>
        /// </remarks>
        /// <doc-id>ff476439</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::GSSetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[In, Buffer, Optional] const ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::GSSetShaderResources</unmanaged-short>
        internal override unsafe void SetShaderResources(System.Int32 startSlot, System.Int32 numViews, System.IntPtr shaderResourceViewsOut)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numViews, (void *)shaderResourceViewsOut, (*(void ***)this._nativePointer)[31]);
        }

        /// <summary>
        /// <p>Set an array of sampler states to the geometry shader pipeline stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin setting samplers to (ranges from 0 to <see cref = "SamplerSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numSamplers"><dd>  <p>Number of samplers in the array. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to <see cref = "SamplerSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "samplersOut"><dd>  <p>Pointer to an array of sampler-state interfaces (see <strong><see cref = "SharpDX.Direct3D11.SamplerState"/></strong>). See Remarks.</p> </dd></param>
        /// <remarks>
        /// <p>Any sampler may be set to <strong><c>null</c></strong>; this invokes the default state, which is defined to be the following.</p><pre> //Default sampler state:
        /// <see cref = "SharpDX.Direct3D11.SamplerStateDescription"/> SamplerDesc;
        /// SamplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
        /// SamplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
        /// SamplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
        /// SamplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
        /// SamplerDesc.MipLODBias = 0;
        /// SamplerDesc.MaxAnisotropy = 1;
        /// SamplerDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;
        /// SamplerDesc.BorderColor[0] = 1.0f;
        /// SamplerDesc.BorderColor[1] = 1.0f;
        /// SamplerDesc.BorderColor[2] = 1.0f;
        /// SamplerDesc.BorderColor[3] = 1.0f;
        /// SamplerDesc.MinLOD = -FLT_MAX;
        /// SamplerDesc.MaxLOD = FLT_MAX; </pre><p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p>
        /// </remarks>
        /// <doc-id>ff476437</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::GSSetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[In, Buffer, Optional] const ID3D11SamplerState** ppSamplers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::GSSetSamplers</unmanaged-short>
        internal override unsafe void SetSamplers(System.Int32 startSlot, System.Int32 numSamplers, System.IntPtr samplersOut)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numSamplers, (void *)samplersOut, (*(void ***)this._nativePointer)[32]);
        }

        /// <summary>
        /// <p>Get the constant buffers used by the geometry shader pipeline stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd>  <p>Number of buffers to retrieve (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd>  <p>Array of constant buffer interface references (see <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>) to be returned by the method.</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476432</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::GSGetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[Out, Buffer, Optional] ID3D11Buffer** ppConstantBuffers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::GSGetConstantBuffers</unmanaged-short>
        internal override unsafe void GetConstantBuffers(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.Direct3D11.Buffer[] constantBuffersOut)
        {
            System.IntPtr*constantBuffersOut_;
            constantBuffersOut_ = (System.IntPtr*)0;
            if (constantBuffersOut != null)
            {
                System.IntPtr*_constantBuffersOut = stackalloc System.IntPtr[constantBuffersOut.Length];
                constantBuffersOut_ = _constantBuffersOut;
            }

            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut_, (*(void ***)this._nativePointer)[81]);
            if (constantBuffersOut != null)
                for (int i = 0; i < constantBuffersOut.Length; ++i)
                    if ((constantBuffersOut_)[i] != System.IntPtr.Zero)
                        constantBuffersOut[i] = new SharpDX.Direct3D11.Buffer((constantBuffersOut_)[i]);
                    else
                        constantBuffersOut[i] = null;
        }

        /// <summary>
        /// <p>Get the geometry shader currently set on the device.</p>
        /// </summary>
        /// <param name = "geometryShaderOut"><dd>  <p>Address of a reference to a geometry shader (see <strong><see cref = "SharpDX.Direct3D11.GeometryShader"/></strong>) to be returned by the method.</p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p>Pointer to an array of class instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>).</p> </dd></param>
        /// <param name = "numClassInstancesRef"><dd>  <p>The number of class-instance elements in the array.</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476434</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::GSGetShader([Out, Optional] ID3D11GeometryShader** ppGeometryShader,[Out, Buffer, Optional] ID3D11ClassInstance** ppClassInstances,[InOut] unsigned int* pNumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::GSGetShader</unmanaged-short>
        internal override unsafe void GetShader(out SharpDX.Direct3D11.GeometryShader geometryShaderOut, SharpDX.Direct3D11.ClassInstance[] classInstancesOut, ref System.Int32 numClassInstancesRef)
        {
            System.IntPtr geometryShaderOut_ = System.IntPtr.Zero;
            System.IntPtr*classInstancesOut_;
            classInstancesOut_ = (System.IntPtr*)0;
            if (classInstancesOut != null)
            {
                System.IntPtr*_classInstancesOut = stackalloc System.IntPtr[classInstancesOut.Length];
                classInstancesOut_ = _classInstancesOut;
            }

            fixed (void *numClassInstancesRef_ = &numClassInstancesRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, &geometryShaderOut_, (void *)classInstancesOut_, numClassInstancesRef_, (*(void ***)this._nativePointer)[82]);
            if (geometryShaderOut_ != System.IntPtr.Zero)
                geometryShaderOut = new SharpDX.Direct3D11.GeometryShader(geometryShaderOut_);
            else
                geometryShaderOut = null;
            if (classInstancesOut != null)
                for (int i = 0; i < classInstancesOut.Length; ++i)
                    if ((classInstancesOut_)[i] != System.IntPtr.Zero)
                        classInstancesOut[i] = new SharpDX.Direct3D11.ClassInstance((classInstancesOut_)[i]);
                    else
                        classInstancesOut[i] = null;
        }

        /// <summary>
        /// <p>Get the geometry shader resources.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin getting shader resources from (ranges from 0 to <see cref = "InputResourceSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numViews"><dd>  <p>The number of resources to get from the device. Up to a maximum of 128 slots are available for shader resources (ranges from 0 to <see cref = "InputResourceSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "shaderResourceViewsOut"><dd>  <p>Array of <strong>shader resource view</strong> interfaces to be returned by the device.</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476435</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::GSGetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[Out, Buffer, Optional] ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::GSGetShaderResources</unmanaged-short>
        internal override unsafe void GetShaderResources(System.Int32 startSlot, System.Int32 numViews, SharpDX.Direct3D11.ShaderResourceView[] shaderResourceViewsOut)
        {
            System.IntPtr*shaderResourceViewsOut_;
            shaderResourceViewsOut_ = (System.IntPtr*)0;
            if (shaderResourceViewsOut != null)
            {
                System.IntPtr*_shaderResourceViewsOut = stackalloc System.IntPtr[shaderResourceViewsOut.Length];
                shaderResourceViewsOut_ = _shaderResourceViewsOut;
            }

            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numViews, (void *)shaderResourceViewsOut_, (*(void ***)this._nativePointer)[87]);
            if (shaderResourceViewsOut != null)
                for (int i = 0; i < shaderResourceViewsOut.Length; ++i)
                    if ((shaderResourceViewsOut_)[i] != System.IntPtr.Zero)
                        shaderResourceViewsOut[i] = new SharpDX.Direct3D11.ShaderResourceView((shaderResourceViewsOut_)[i]);
                    else
                        shaderResourceViewsOut[i] = null;
        }

        /// <summary>
        /// <p>Get an array of sampler state interfaces from the geometry shader pipeline stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into a zero-based array to begin getting samplers from (ranges from 0 to <see cref = "SamplerSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numSamplers"><dd>  <p>Number of samplers to get from a device context. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to <see cref = "SamplerSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "samplersOut"><dd>  <p>Pointer to an array of sampler-state interfaces (see <strong><see cref = "SharpDX.Direct3D11.SamplerState"/></strong>).</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476433</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::GSGetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[Out, Buffer, Optional] ID3D11SamplerState** ppSamplers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::GSGetSamplers</unmanaged-short>
        internal override unsafe void GetSamplers(System.Int32 startSlot, System.Int32 numSamplers, SharpDX.Direct3D11.SamplerState[] samplersOut)
        {
            System.IntPtr*samplersOut_;
            samplersOut_ = (System.IntPtr*)0;
            if (samplersOut != null)
            {
                System.IntPtr*_samplersOut = stackalloc System.IntPtr[samplersOut.Length];
                samplersOut_ = _samplersOut;
            }

            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numSamplers, (void *)samplersOut_, (*(void ***)this._nativePointer)[88]);
            if (samplersOut != null)
                for (int i = 0; i < samplersOut.Length; ++i)
                    if ((samplersOut_)[i] != System.IntPtr.Zero)
                        samplersOut[i] = new SharpDX.Direct3D11.SamplerState((samplersOut_)[i]);
                    else
                        samplersOut[i] = null;
        }

        /// <summary>
        /// <p>Set a geometry shader to the device.</p>
        /// </summary>
        /// <param name = "shaderRef"><dd>  <p>Pointer to a geometry shader (see <strong><see cref = "SharpDX.Direct3D11.GeometryShader"/></strong>). Passing in <strong><c>null</c></strong> disables the shader for this pipeline stage.</p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p>A reference to an array of class-instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <strong><c>null</c></strong> if the shader does not use any interfaces.</p> </dd></param>
        /// <param name = "numClassInstances"><dd>  <p>The number of class-instance interfaces in the array.</p> </dd></param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p>The maximum number of instances a shader can have is 256.</p>
        /// </remarks>
        /// <doc-id>ff476438</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::GSSetShader([In, Optional] ID3D11GeometryShader* pShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[In] unsigned int NumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::GSSetShader</unmanaged-short>
        internal override unsafe void SetShader(SharpDX.Direct3D11.GeometryShader shaderRef, SharpDX.ComArray<SharpDX.Direct3D11.ClassInstance> classInstancesOut, System.Int32 numClassInstances)
        {
            System.IntPtr shaderRef_ = System.IntPtr.Zero;
            shaderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.GeometryShader>(shaderRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)shaderRef_, (void *)(classInstancesOut?.NativePointer ?? System.IntPtr.Zero), numClassInstances, (*(void ***)this._nativePointer)[23]);
        }

        /// <summary>
        /// <p>Set a geometry shader to the device.</p>
        /// </summary>
        /// <param name = "shaderRef"><dd>  <p>Pointer to a geometry shader (see <strong><see cref = "SharpDX.Direct3D11.GeometryShader"/></strong>). Passing in <strong><c>null</c></strong> disables the shader for this pipeline stage.</p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p>A reference to an array of class-instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <strong><c>null</c></strong> if the shader does not use any interfaces.</p> </dd></param>
        /// <param name = "numClassInstances"><dd>  <p>The number of class-instance interfaces in the array.</p> </dd></param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p>The maximum number of instances a shader can have is 256.</p>
        /// </remarks>
        /// <doc-id>ff476438</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::GSSetShader([In, Optional] ID3D11GeometryShader* pShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[In] unsigned int NumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::GSSetShader</unmanaged-short>
        private unsafe void SetShader(System.IntPtr shaderRef, System.IntPtr classInstancesOut, System.Int32 numClassInstances)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)shaderRef, (void *)classInstancesOut, numClassInstances, (*(void ***)this._nativePointer)[23]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("8e5c6061-628a-4c8e-8264-bbe45cb3d5dd")]
    public partial class HullShader : SharpDX.Direct3D11.DeviceChild
    {
        public HullShader(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator HullShader(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new HullShader(nativePtr);
    }

    [System.Runtime.InteropServices.GuidAttribute("c0bfa96c-e089-44fb-8eaf-26f8796190da")]
    public partial class HullShaderStage : CommonShaderStage<HullShader>
    {
        public HullShaderStage(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator HullShaderStage(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new HullShaderStage(nativePtr);
        /// <summary>
        /// <p>Bind an array of shader resources to the hull-shader stage.</p>
        /// </summary>
        /// <param name = "startSlot">No documentation.</param>
        /// <param name = "numViews">No documentation.</param>
        /// <param name = "shaderResourceViewsOut">No documentation.</param>
        /// <remarks>
        /// <p>If an overlapping resource view is already bound to an output slot, such as a render target, then the method will fill the destination shader resource slot with <strong><c>null</c></strong>.</p><p>For information about creating shader-resource views, see <strong>ID3D11Device::CreateShaderResourceView</strong>.</p><p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p>
        /// </remarks>
        /// <doc-id>ff476448</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::HSSetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[In, Buffer, Optional] const ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::HSSetShaderResources</unmanaged-short>
        internal override unsafe void SetShaderResources(System.Int32 startSlot, System.Int32 numViews, System.IntPtr shaderResourceViewsOut)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numViews, (void *)shaderResourceViewsOut, (*(void ***)this._nativePointer)[59]);
        }

        /// <summary>
        /// <p>Set a hull shader to the device.</p>
        /// </summary>
        /// <param name = "hullShaderRef"><dd>  <p>Pointer to a hull shader (see <strong><see cref = "SharpDX.Direct3D11.HullShader"/></strong>). Passing in <strong><c>null</c></strong> disables the shader for this pipeline stage.</p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p>A reference to an array of class-instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <strong><c>null</c></strong> if the shader does not use any interfaces.</p> </dd></param>
        /// <param name = "numClassInstances"><dd>  <p>The number of class-instance interfaces in the array.</p> </dd></param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p>The maximum number of instances a shader can have is 256.</p>
        /// </remarks>
        /// <doc-id>ff476447</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::HSSetShader([In, Optional] ID3D11HullShader* pHullShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[In] unsigned int NumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::HSSetShader</unmanaged-short>
        internal override unsafe void SetShader(SharpDX.Direct3D11.HullShader hullShaderRef, SharpDX.Direct3D11.ClassInstance[] classInstancesOut, System.Int32 numClassInstances)
        {
            System.IntPtr hullShaderRef_ = System.IntPtr.Zero;
            System.IntPtr*classInstancesOut_;
            classInstancesOut_ = (System.IntPtr*)0;
            if (classInstancesOut != null)
            {
                System.IntPtr*_classInstancesOut = stackalloc System.IntPtr[classInstancesOut.Length];
                classInstancesOut_ = _classInstancesOut;
            }

            hullShaderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.HullShader>(hullShaderRef);
            if (classInstancesOut != null)
                for (int i = 0; i < classInstancesOut.Length; ++i)
                    (classInstancesOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.ClassInstance>(classInstancesOut[i]);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)hullShaderRef_, (void *)classInstancesOut_, numClassInstances, (*(void ***)this._nativePointer)[60]);
        }

        /// <summary>
        /// <p>Set an array of sampler states to the hull-shader stage.</p>
        /// </summary>
        /// <param name = "startSlot">No documentation.</param>
        /// <param name = "numSamplers">No documentation.</param>
        /// <param name = "samplersOut">No documentation.</param>
        /// <remarks>
        /// <p>Any sampler may be set to <strong><c>null</c></strong>; this invokes the default state, which is defined to be the following.</p><pre> //Default sampler state:
        /// <see cref = "SharpDX.Direct3D11.SamplerStateDescription"/> SamplerDesc;
        /// SamplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
        /// SamplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
        /// SamplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
        /// SamplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
        /// SamplerDesc.MipLODBias = 0;
        /// SamplerDesc.MaxAnisotropy = 1;
        /// SamplerDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;
        /// SamplerDesc.BorderColor[0] = 1.0f;
        /// SamplerDesc.BorderColor[1] = 1.0f;
        /// SamplerDesc.BorderColor[2] = 1.0f;
        /// SamplerDesc.BorderColor[3] = 1.0f;
        /// SamplerDesc.MinLOD = -FLT_MAX;
        /// SamplerDesc.MaxLOD = FLT_MAX; </pre><p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p>
        /// </remarks>
        /// <doc-id>ff476446</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::HSSetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[In, Buffer, Optional] const ID3D11SamplerState** ppSamplers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::HSSetSamplers</unmanaged-short>
        internal override unsafe void SetSamplers(System.Int32 startSlot, System.Int32 numSamplers, System.IntPtr samplersOut)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numSamplers, (void *)samplersOut, (*(void ***)this._nativePointer)[61]);
        }

        /// <summary>
        /// <p>Set the constant buffers used by the hull-shader stage.</p>
        /// </summary>
        /// <param name = "startSlot">No documentation.</param>
        /// <param name = "numBuffers">No documentation.</param>
        /// <param name = "constantBuffersOut">No documentation.</param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p>The Direct3D 11.1 runtime, which is available starting with Windows?8, can bind a larger number of <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong> resources to the shader than the maximum constant buffer size that is supported by shaders (4096 constants ? 4*32-bit components each).  When you bind such a large buffer, the shader can access only the first 4096 4*32-bit component constants in the buffer, as if 4096 constants is the full size of the buffer.  </p><p>If the application wants the shader to access other parts of the buffer, it must call the <strong>HSSetConstantBuffers1</strong> method instead. </p>
        /// </remarks>
        /// <doc-id>ff476445</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::HSSetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::HSSetConstantBuffers</unmanaged-short>
        internal override unsafe void SetConstantBuffers(System.Int32 startSlot, System.Int32 numBuffers, System.IntPtr constantBuffersOut)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut, (*(void ***)this._nativePointer)[62]);
        }

        /// <summary>
        /// <p>Get the hull-shader resources.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin getting shader resources from (ranges from 0 to <see cref = "InputResourceSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numViews"><dd>  <p>The number of resources to get from the device. Up to a maximum of 128 slots are available for shader resources (ranges from 0 to <see cref = "InputResourceSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "shaderResourceViewsOut"><dd>  <p>Array of <strong>shader resource view</strong> interfaces to be returned by the device.</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476443</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::HSGetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[Out, Buffer, Optional] ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::HSGetShaderResources</unmanaged-short>
        internal override unsafe void GetShaderResources(System.Int32 startSlot, System.Int32 numViews, SharpDX.Direct3D11.ShaderResourceView[] shaderResourceViewsOut)
        {
            System.IntPtr*shaderResourceViewsOut_;
            shaderResourceViewsOut_ = (System.IntPtr*)0;
            if (shaderResourceViewsOut != null)
            {
                System.IntPtr*_shaderResourceViewsOut = stackalloc System.IntPtr[shaderResourceViewsOut.Length];
                shaderResourceViewsOut_ = _shaderResourceViewsOut;
            }

            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numViews, (void *)shaderResourceViewsOut_, (*(void ***)this._nativePointer)[97]);
            if (shaderResourceViewsOut != null)
                for (int i = 0; i < shaderResourceViewsOut.Length; ++i)
                    if ((shaderResourceViewsOut_)[i] != System.IntPtr.Zero)
                        shaderResourceViewsOut[i] = new SharpDX.Direct3D11.ShaderResourceView((shaderResourceViewsOut_)[i]);
                    else
                        shaderResourceViewsOut[i] = null;
        }

        /// <summary>
        /// <p>Get the hull shader currently set on the device.</p>
        /// </summary>
        /// <param name = "hullShaderOut"><dd>  <p>Address of a reference to a hull shader (see <strong><see cref = "SharpDX.Direct3D11.HullShader"/></strong>) to be returned by the method.</p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p>Pointer to an array of class instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>).</p> </dd></param>
        /// <param name = "numClassInstancesRef"><dd>  <p>The number of class-instance elements in the array.</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476442</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::HSGetShader([Out, Optional] ID3D11HullShader** ppHullShader,[Out, Buffer, Optional] ID3D11ClassInstance** ppClassInstances,[InOut] unsigned int* pNumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::HSGetShader</unmanaged-short>
        internal override unsafe void GetShader(out SharpDX.Direct3D11.HullShader hullShaderOut, SharpDX.Direct3D11.ClassInstance[] classInstancesOut, ref System.Int32 numClassInstancesRef)
        {
            System.IntPtr hullShaderOut_ = System.IntPtr.Zero;
            System.IntPtr*classInstancesOut_;
            classInstancesOut_ = (System.IntPtr*)0;
            if (classInstancesOut != null)
            {
                System.IntPtr*_classInstancesOut = stackalloc System.IntPtr[classInstancesOut.Length];
                classInstancesOut_ = _classInstancesOut;
            }

            fixed (void *numClassInstancesRef_ = &numClassInstancesRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, &hullShaderOut_, (void *)classInstancesOut_, numClassInstancesRef_, (*(void ***)this._nativePointer)[98]);
            if (hullShaderOut_ != System.IntPtr.Zero)
                hullShaderOut = new SharpDX.Direct3D11.HullShader(hullShaderOut_);
            else
                hullShaderOut = null;
            if (classInstancesOut != null)
                for (int i = 0; i < classInstancesOut.Length; ++i)
                    if ((classInstancesOut_)[i] != System.IntPtr.Zero)
                        classInstancesOut[i] = new SharpDX.Direct3D11.ClassInstance((classInstancesOut_)[i]);
                    else
                        classInstancesOut[i] = null;
        }

        /// <summary>
        /// <p>Get an array of sampler state interfaces from the hull-shader stage.</p>
        /// </summary>
        /// <param name = "startSlot">No documentation.</param>
        /// <param name = "numSamplers">No documentation.</param>
        /// <param name = "samplersOut">No documentation.</param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476441</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::HSGetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[Out, Buffer, Optional] ID3D11SamplerState** ppSamplers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::HSGetSamplers</unmanaged-short>
        internal override unsafe void GetSamplers(System.Int32 startSlot, System.Int32 numSamplers, SharpDX.Direct3D11.SamplerState[] samplersOut)
        {
            System.IntPtr*samplersOut_;
            samplersOut_ = (System.IntPtr*)0;
            if (samplersOut != null)
            {
                System.IntPtr*_samplersOut = stackalloc System.IntPtr[samplersOut.Length];
                samplersOut_ = _samplersOut;
            }

            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numSamplers, (void *)samplersOut_, (*(void ***)this._nativePointer)[99]);
            if (samplersOut != null)
                for (int i = 0; i < samplersOut.Length; ++i)
                    if ((samplersOut_)[i] != System.IntPtr.Zero)
                        samplersOut[i] = new SharpDX.Direct3D11.SamplerState((samplersOut_)[i]);
                    else
                        samplersOut[i] = null;
        }

        /// <summary>
        /// <p>Get the constant buffers used by the hull-shader stage.</p>
        /// </summary>
        /// <param name = "startSlot">No documentation.</param>
        /// <param name = "numBuffers">No documentation.</param>
        /// <param name = "constantBuffersOut">No documentation.</param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476440</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::HSGetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[Out, Buffer, Optional] ID3D11Buffer** ppConstantBuffers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::HSGetConstantBuffers</unmanaged-short>
        internal override unsafe void GetConstantBuffers(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.Direct3D11.Buffer[] constantBuffersOut)
        {
            System.IntPtr*constantBuffersOut_;
            constantBuffersOut_ = (System.IntPtr*)0;
            if (constantBuffersOut != null)
            {
                System.IntPtr*_constantBuffersOut = stackalloc System.IntPtr[constantBuffersOut.Length];
                constantBuffersOut_ = _constantBuffersOut;
            }

            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut_, (*(void ***)this._nativePointer)[100]);
            if (constantBuffersOut != null)
                for (int i = 0; i < constantBuffersOut.Length; ++i)
                    if ((constantBuffersOut_)[i] != System.IntPtr.Zero)
                        constantBuffersOut[i] = new SharpDX.Direct3D11.Buffer((constantBuffersOut_)[i]);
                    else
                        constantBuffersOut[i] = null;
        }

        /// <summary>
        /// <p>Set a hull shader to the device.</p>
        /// </summary>
        /// <param name = "hullShaderRef"><dd>  <p>Pointer to a hull shader (see <strong><see cref = "SharpDX.Direct3D11.HullShader"/></strong>). Passing in <strong><c>null</c></strong> disables the shader for this pipeline stage.</p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p>A reference to an array of class-instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <strong><c>null</c></strong> if the shader does not use any interfaces.</p> </dd></param>
        /// <param name = "numClassInstances"><dd>  <p>The number of class-instance interfaces in the array.</p> </dd></param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p>The maximum number of instances a shader can have is 256.</p>
        /// </remarks>
        /// <doc-id>ff476447</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::HSSetShader([In, Optional] ID3D11HullShader* pHullShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[In] unsigned int NumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::HSSetShader</unmanaged-short>
        internal override unsafe void SetShader(SharpDX.Direct3D11.HullShader hullShaderRef, SharpDX.ComArray<SharpDX.Direct3D11.ClassInstance> classInstancesOut, System.Int32 numClassInstances)
        {
            System.IntPtr hullShaderRef_ = System.IntPtr.Zero;
            hullShaderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.HullShader>(hullShaderRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)hullShaderRef_, (void *)(classInstancesOut?.NativePointer ?? System.IntPtr.Zero), numClassInstances, (*(void ***)this._nativePointer)[60]);
        }

        /// <summary>
        /// <p>Set a hull shader to the device.</p>
        /// </summary>
        /// <param name = "hullShaderRef"><dd>  <p>Pointer to a hull shader (see <strong><see cref = "SharpDX.Direct3D11.HullShader"/></strong>). Passing in <strong><c>null</c></strong> disables the shader for this pipeline stage.</p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p>A reference to an array of class-instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <strong><c>null</c></strong> if the shader does not use any interfaces.</p> </dd></param>
        /// <param name = "numClassInstances"><dd>  <p>The number of class-instance interfaces in the array.</p> </dd></param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p>The maximum number of instances a shader can have is 256.</p>
        /// </remarks>
        /// <doc-id>ff476447</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::HSSetShader([In, Optional] ID3D11HullShader* pHullShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[In] unsigned int NumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::HSSetShader</unmanaged-short>
        private unsafe void SetShader(System.IntPtr hullShaderRef, System.IntPtr classInstancesOut, System.Int32 numClassInstances)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)hullShaderRef, (void *)classInstancesOut, numClassInstances, (*(void ***)this._nativePointer)[60]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("bdb64df4-ea2f-4c70-b861-aaab1258bb5d")]
    public partial class ID3D11On12Device1 : SharpDX.Direct3D11.Device11On12
    {
        public ID3D11On12Device1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ID3D11On12Device1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ID3D11On12Device1(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "riid">No documentation.</param>
        /// <param name = "vDeviceOut">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D11On12Device1::GetD3D12Device([In] const GUID&amp; riid,[Out] void** ppvDevice)</unmanaged>
        /// <unmanaged-short>ID3D11On12Device1::GetD3D12Device</unmanaged-short>
        public unsafe void GetD3D12Device(System.Guid riid, out System.IntPtr vDeviceOut)
        {
            SharpDX.Result __result__;
            fixed (void *vDeviceOut_ = &vDeviceOut)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &riid, vDeviceOut_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("6543dbb6-1b48-42f5-ab82-e97ec74326f6")]
    public partial class InfoQueue : SharpDX.ComObject
    {
        public InfoQueue(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator InfoQueue(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new InfoQueue(nativePtr);
        /// <summary>
        /// <p>Get or sets the maximum number of messages that can be added to the message queue.</p>
        /// </summary>
        /// <remarks>
        /// <p>When the number of messages in the message queue has reached the maximum limit, new messages coming in will push old messages out.</p>
        /// </remarks>
        /// <doc-id>ff476550</doc-id>
        /// <unmanaged>GetMessageCountLimit / SetMessageCountLimit</unmanaged>
        /// <unmanaged-short>GetMessageCountLimit</unmanaged-short>
        public System.Int64 MessageCountLimit
        {
            get => GetMessageCountLimit();
            set => SetMessageCountLimit(value);
        }

        /// <summary>
        /// <p>Get the number of messages that were allowed to pass through a storage filter.</p>
        /// </summary>
        /// <doc-id>ff476552</doc-id>
        /// <unmanaged>GetNumMessagesAllowedByStorageFilter</unmanaged>
        /// <unmanaged-short>GetNumMessagesAllowedByStorageFilter</unmanaged-short>
        public System.Int64 NumMessagesAllowedByStorageFilter
        {
            get => GetNumMessagesAllowedByStorageFilter();
        }

        /// <summary>
        /// <p>Get the number of messages that were denied passage through a storage filter.</p>
        /// </summary>
        /// <doc-id>ff476553</doc-id>
        /// <unmanaged>GetNumMessagesDeniedByStorageFilter</unmanaged>
        /// <unmanaged-short>GetNumMessagesDeniedByStorageFilter</unmanaged-short>
        public System.Int64 NumMessagesDeniedByStorageFilter
        {
            get => GetNumMessagesDeniedByStorageFilter();
        }

        /// <summary>
        /// <p>Get the number of messages currently stored in the message queue.</p>
        /// </summary>
        /// <doc-id>ff476556</doc-id>
        /// <unmanaged>GetNumStoredMessages</unmanaged>
        /// <unmanaged-short>GetNumStoredMessages</unmanaged-short>
        public System.Int64 NumStoredMessages
        {
            get => GetNumStoredMessages();
        }

        /// <summary>
        /// <p>Get the number of messages that are able to pass through a retrieval filter.</p>
        /// </summary>
        /// <doc-id>ff476557</doc-id>
        /// <unmanaged>GetNumStoredMessagesAllowedByRetrievalFilter</unmanaged>
        /// <unmanaged-short>GetNumStoredMessagesAllowedByRetrievalFilter</unmanaged-short>
        public System.Int64 NumStoredMessagesAllowedByRetrievalFilter
        {
            get => GetNumStoredMessagesAllowedByRetrievalFilter();
        }

        /// <summary>
        /// <p>Get the number of messages that were discarded due to the message count limit.</p>
        /// </summary>
        /// <remarks>
        /// <p>Get and set the message count limit with <strong>ID3D11InfoQueue::GetMessageCountLimit</strong> and <strong>ID3D11InfoQueue::SetMessageCountLimit</strong>, respectively.</p>
        /// </remarks>
        /// <doc-id>ff476554</doc-id>
        /// <unmanaged>GetNumMessagesDiscardedByMessageCountLimit</unmanaged>
        /// <unmanaged-short>GetNumMessagesDiscardedByMessageCountLimit</unmanaged-short>
        public System.Int64 NumMessagesDiscardedByMessageCountLimit
        {
            get => GetNumMessagesDiscardedByMessageCountLimit();
        }

        /// <summary>
        /// <p>Get the size of the storage-filter stack in bytes.</p>
        /// </summary>
        /// <doc-id>ff476561</doc-id>
        /// <unmanaged>GetStorageFilterStackSize</unmanaged>
        /// <unmanaged-short>GetStorageFilterStackSize</unmanaged-short>
        public System.Int32 StorageFilterStackSize
        {
            get => GetStorageFilterStackSize();
        }

        /// <summary>
        /// <p>Get the size of the retrieval-filter stack in bytes.</p>
        /// </summary>
        /// <doc-id>ff476559</doc-id>
        /// <unmanaged>GetRetrievalFilterStackSize</unmanaged>
        /// <unmanaged-short>GetRetrievalFilterStackSize</unmanaged-short>
        public System.Int32 RetrievalFilterStackSize
        {
            get => GetRetrievalFilterStackSize();
        }

        /// <summary>
        /// <p>Get or sets a boolean that turns the debug output on or off.</p>
        /// </summary>
        /// <doc-id>ff476551</doc-id>
        /// <unmanaged>GetMuteDebugOutput / SetMuteDebugOutput</unmanaged>
        /// <unmanaged-short>GetMuteDebugOutput</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool MuteDebugOutput
        {
            get => GetMuteDebugOutput();
            set => SetMuteDebugOutput(value);
        }

        /// <summary>
        /// <p>Set the maximum number of messages that can be added to the message queue.</p>
        /// </summary>
        /// <param name = "messageCountLimit"><dd>  <p>Maximum number of messages that can be added to the message queue. -1 means no limit.</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>When the number of messages in the message queue has reached the maximum limit, new messages coming in will push old messages out.</p>
        /// </remarks>
        /// <doc-id>ff476573</doc-id>
        /// <unmanaged>HRESULT ID3D11InfoQueue::SetMessageCountLimit([In] unsigned longlong MessageCountLimit)</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::SetMessageCountLimit</unmanaged-short>
        internal unsafe void SetMessageCountLimit(System.Int64 messageCountLimit)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, messageCountLimit, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Clear all messages from the message queue.</p>
        /// </summary>
        /// <doc-id>ff476545</doc-id>
        /// <unmanaged>void ID3D11InfoQueue::ClearStoredMessages()</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::ClearStoredMessages</unmanaged-short>
        public unsafe void ClearStoredMessages()
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[4]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "messageIndex">No documentation.</param>
        /// <param name = "messageRef">No documentation.</param>
        /// <param name = "messageByteLengthRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D11InfoQueue::GetMessage([In] unsigned longlong MessageIndex,[In] D3D11_MESSAGE* pMessage,[InOut] SIZE_T* pMessageByteLength)</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::GetMessage</unmanaged-short>
        internal unsafe void GetMessage(System.Int64 messageIndex, System.IntPtr messageRef, ref SharpDX.PointerSize messageByteLengthRef)
        {
            SharpDX.Result __result__;
            fixed (void *messageByteLengthRef_ = &messageByteLengthRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, messageIndex, (void *)messageRef, messageByteLengthRef_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get the number of messages that were allowed to pass through a storage filter.</p>
        /// </summary>
        /// <returns><p>Number of messages allowed by a storage filter.</p></returns>
        /// <doc-id>ff476552</doc-id>
        /// <unmanaged>unsigned longlong ID3D11InfoQueue::GetNumMessagesAllowedByStorageFilter()</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::GetNumMessagesAllowedByStorageFilter</unmanaged-short>
        internal unsafe System.Int64 GetNumMessagesAllowedByStorageFilter()
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCalllong(this._nativePointer, (*(void ***)this._nativePointer)[6]);
            return __result__;
        }

        /// <summary>
        /// <p>Get the number of messages that were denied passage through a storage filter.</p>
        /// </summary>
        /// <returns><p>Number of messages denied by a storage filter.</p></returns>
        /// <doc-id>ff476553</doc-id>
        /// <unmanaged>unsigned longlong ID3D11InfoQueue::GetNumMessagesDeniedByStorageFilter()</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::GetNumMessagesDeniedByStorageFilter</unmanaged-short>
        internal unsafe System.Int64 GetNumMessagesDeniedByStorageFilter()
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCalllong(this._nativePointer, (*(void ***)this._nativePointer)[7]);
            return __result__;
        }

        /// <summary>
        /// <p>Get the number of messages currently stored in the message queue.</p>
        /// </summary>
        /// <returns><p>Number of messages currently stored in the message queue.</p></returns>
        /// <doc-id>ff476556</doc-id>
        /// <unmanaged>unsigned longlong ID3D11InfoQueue::GetNumStoredMessages()</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::GetNumStoredMessages</unmanaged-short>
        internal unsafe System.Int64 GetNumStoredMessages()
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCalllong(this._nativePointer, (*(void ***)this._nativePointer)[8]);
            return __result__;
        }

        /// <summary>
        /// <p>Get the number of messages that are able to pass through a retrieval filter.</p>
        /// </summary>
        /// <returns><p>Number of messages allowed by a retrieval filter.</p></returns>
        /// <doc-id>ff476557</doc-id>
        /// <unmanaged>unsigned longlong ID3D11InfoQueue::GetNumStoredMessagesAllowedByRetrievalFilter()</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::GetNumStoredMessagesAllowedByRetrievalFilter</unmanaged-short>
        internal unsafe System.Int64 GetNumStoredMessagesAllowedByRetrievalFilter()
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCalllong(this._nativePointer, (*(void ***)this._nativePointer)[9]);
            return __result__;
        }

        /// <summary>
        /// <p>Get the number of messages that were discarded due to the message count limit.</p>
        /// </summary>
        /// <returns><p>Number of messages discarded.</p></returns>
        /// <remarks>
        /// <p>Get and set the message count limit with <strong>ID3D11InfoQueue::GetMessageCountLimit</strong> and <strong>ID3D11InfoQueue::SetMessageCountLimit</strong>, respectively.</p>
        /// </remarks>
        /// <doc-id>ff476554</doc-id>
        /// <unmanaged>unsigned longlong ID3D11InfoQueue::GetNumMessagesDiscardedByMessageCountLimit()</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::GetNumMessagesDiscardedByMessageCountLimit</unmanaged-short>
        internal unsafe System.Int64 GetNumMessagesDiscardedByMessageCountLimit()
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCalllong(this._nativePointer, (*(void ***)this._nativePointer)[10]);
            return __result__;
        }

        /// <summary>
        /// <p>Get the maximum number of messages that can be added to the message queue.</p>
        /// </summary>
        /// <returns><p>Maximum number of messages that can be added to the queue. -1 means no limit.</p></returns>
        /// <remarks>
        /// <p>When the number of messages in the message queue has reached the maximum limit, new messages coming in will push old messages out.</p>
        /// </remarks>
        /// <doc-id>ff476550</doc-id>
        /// <unmanaged>unsigned longlong ID3D11InfoQueue::GetMessageCountLimit()</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::GetMessageCountLimit</unmanaged-short>
        internal unsafe System.Int64 GetMessageCountLimit()
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCalllong(this._nativePointer, (*(void ***)this._nativePointer)[11]);
            return __result__;
        }

        /// <summary>
        /// <p>Add storage filters to the top of the storage-filter stack.</p>
        /// </summary>
        /// <param name = "filterRef"><dd>  <p>Array of storage filters (see <strong><see cref = "SharpDX.Direct3D11.InfoQueueFilter"/></strong>).</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <doc-id>ff476542</doc-id>
        /// <unmanaged>HRESULT ID3D11InfoQueue::AddStorageFilterEntries([In] D3D11_INFO_QUEUE_FILTER* pFilter)</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::AddStorageFilterEntries</unmanaged-short>
        public unsafe void AddStorageFilterEntries(SharpDX.Direct3D11.InfoQueueFilter filterRef)
        {
            SharpDX.Direct3D11.InfoQueueFilter.__Native filterRef_ = default (SharpDX.Direct3D11.InfoQueueFilter.__Native);
            SharpDX.Result __result__;
            filterRef.__MarshalTo(ref filterRef_);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &filterRef_, (*(void ***)this._nativePointer)[12]);
            filterRef.__MarshalFree(ref filterRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get the storage filter at the top of the storage-filter stack.</p>
        /// </summary>
        /// <param name = "filterRef"><dd>  <p>Storage filter at the top of the storage-filter stack.</p> </dd></param>
        /// <param name = "filterByteLengthRef"><dd>  <p>Size of the storage filter in bytes. If pFilter is <strong><c>null</c></strong>, the size of the storage filter will be output to this parameter.</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <doc-id>ff476560</doc-id>
        /// <unmanaged>HRESULT ID3D11InfoQueue::GetStorageFilter([In] D3D11_INFO_QUEUE_FILTER* pFilter,[InOut] SIZE_T* pFilterByteLength)</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::GetStorageFilter</unmanaged-short>
        internal unsafe void GetStorageFilter(System.IntPtr filterRef, ref SharpDX.PointerSize filterByteLengthRef)
        {
            SharpDX.Result __result__;
            fixed (void *filterByteLengthRef_ = &filterByteLengthRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)filterRef, filterByteLengthRef_, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Remove a storage filter from the top of the storage-filter stack.</p>
        /// </summary>
        /// <doc-id>ff476544</doc-id>
        /// <unmanaged>void ID3D11InfoQueue::ClearStorageFilter()</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::ClearStorageFilter</unmanaged-short>
        public unsafe void ClearStorageFilter()
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[14]);
        }

        /// <summary>
        /// <p>Push an empty storage filter onto the storage-filter stack.</p>
        /// </summary>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>An empty storage filter allows all messages to pass through.</p>
        /// </remarks>
        /// <doc-id>ff476567</doc-id>
        /// <unmanaged>HRESULT ID3D11InfoQueue::PushEmptyStorageFilter()</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::PushEmptyStorageFilter</unmanaged-short>
        public unsafe void PushEmptyStorageFilter()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Push a copy of storage filter currently on the top of the storage-filter stack onto the storage-filter stack.</p>
        /// </summary>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <doc-id>ff476565</doc-id>
        /// <unmanaged>HRESULT ID3D11InfoQueue::PushCopyOfStorageFilter()</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::PushCopyOfStorageFilter</unmanaged-short>
        public unsafe void PushCopyOfStorageFilter()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Push a storage filter onto the storage-filter stack.</p>
        /// </summary>
        /// <param name = "filterRef"><dd>  <p>Pointer to a storage filter (see <strong><see cref = "SharpDX.Direct3D11.InfoQueueFilter"/></strong>).</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <doc-id>ff476569</doc-id>
        /// <unmanaged>HRESULT ID3D11InfoQueue::PushStorageFilter([In] D3D11_INFO_QUEUE_FILTER* pFilter)</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::PushStorageFilter</unmanaged-short>
        public unsafe void PushStorageFilter(SharpDX.Direct3D11.InfoQueueFilter filterRef)
        {
            SharpDX.Direct3D11.InfoQueueFilter.__Native filterRef_ = default (SharpDX.Direct3D11.InfoQueueFilter.__Native);
            SharpDX.Result __result__;
            filterRef.__MarshalTo(ref filterRef_);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &filterRef_, (*(void ***)this._nativePointer)[17]);
            filterRef.__MarshalFree(ref filterRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Pop a storage filter from the top of the storage-filter stack.</p>
        /// </summary>
        /// <doc-id>ff476563</doc-id>
        /// <unmanaged>void ID3D11InfoQueue::PopStorageFilter()</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::PopStorageFilter</unmanaged-short>
        public unsafe void PopStorageFilter()
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[18]);
        }

        /// <summary>
        /// <p>Get the size of the storage-filter stack in bytes.</p>
        /// </summary>
        /// <returns><p>Size of the storage-filter stack in bytes.</p></returns>
        /// <doc-id>ff476561</doc-id>
        /// <unmanaged>unsigned int ID3D11InfoQueue::GetStorageFilterStackSize()</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::GetStorageFilterStackSize</unmanaged-short>
        internal unsafe System.Int32 GetStorageFilterStackSize()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[19]);
            return __result__;
        }

        /// <summary>
        /// <p>Add storage filters to the top of the retrieval-filter stack.</p>
        /// </summary>
        /// <param name = "filterRef"><dd>  <p>Array of retrieval filters (see <strong><see cref = "SharpDX.Direct3D11.InfoQueueFilter"/></strong>).</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>The following code example shows how to use <strong>ID3D11InfoQueue::AddRetrievalFilterEntries</strong>:</p><pre> <see cref = "SharpDX.Direct3D11.MessageCategory"/> cats[] = { ..., ..., ... };
        /// <see cref = "SharpDX.Direct3D11.MessageSeverity"/> sevs[] = { ..., ..., ... };
        /// UINT ids[] = { ..., ..., ... }; <see cref = "SharpDX.Direct3D11.InfoQueueFilter"/> filter;
        /// memset( &amp;filter, 0, sizeof(filter) ); // To set the type of messages to allow, 
        /// // set filter.AllowList as follows:
        /// filter.AllowList.NumCategories = sizeof(cats / sizeof(<see cref = "SharpDX.Direct3D11.MessageCategory"/>)); 
        /// filter.AllowList.pCategoryList = cats;
        /// filter.AllowList.NumSeverities = sizeof(sevs / sizeof(<see cref = "SharpDX.Direct3D11.MessageSeverity"/>)); 
        /// filter.AllowList.pSeverityList = sevs;
        /// filter.AllowList.NumIDs = sizeof(ids) / sizeof(UINT);
        /// filter.AllowList.pIDList = ids; // To set the type of messages to deny, set filter.DenyList 
        /// // similarly to the preceding filter.AllowList. // The following single call sets all of the preceding information.
        /// hr = infoQueue-&gt;AddRetrievalFilterEntries( &amp;filter );
        /// </pre>
        /// </remarks>
        /// <doc-id>ff476541</doc-id>
        /// <unmanaged>HRESULT ID3D11InfoQueue::AddRetrievalFilterEntries([In] D3D11_INFO_QUEUE_FILTER* pFilter)</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::AddRetrievalFilterEntries</unmanaged-short>
        public unsafe void AddRetrievalFilterEntries(SharpDX.Direct3D11.InfoQueueFilter filterRef)
        {
            SharpDX.Direct3D11.InfoQueueFilter.__Native filterRef_ = default (SharpDX.Direct3D11.InfoQueueFilter.__Native);
            SharpDX.Result __result__;
            filterRef.__MarshalTo(ref filterRef_);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &filterRef_, (*(void ***)this._nativePointer)[20]);
            filterRef.__MarshalFree(ref filterRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get the retrieval filter at the top of the retrieval-filter stack.</p>
        /// </summary>
        /// <param name = "filterRef"><dd>  <p>Retrieval filter at the top of the retrieval-filter stack.</p> </dd></param>
        /// <param name = "filterByteLengthRef"><dd>  <p>Size of the retrieval filter in bytes. If pFilter is <strong><c>null</c></strong>, the size of the retrieval filter will be output to this parameter.</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <doc-id>ff476558</doc-id>
        /// <unmanaged>HRESULT ID3D11InfoQueue::GetRetrievalFilter([In] D3D11_INFO_QUEUE_FILTER* pFilter,[InOut] SIZE_T* pFilterByteLength)</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::GetRetrievalFilter</unmanaged-short>
        internal unsafe void GetRetrievalFilter(System.IntPtr filterRef, ref SharpDX.PointerSize filterByteLengthRef)
        {
            SharpDX.Result __result__;
            fixed (void *filterByteLengthRef_ = &filterByteLengthRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)filterRef, filterByteLengthRef_, (*(void ***)this._nativePointer)[21]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Remove a retrieval filter from the top of the retrieval-filter stack.</p>
        /// </summary>
        /// <doc-id>ff476543</doc-id>
        /// <unmanaged>void ID3D11InfoQueue::ClearRetrievalFilter()</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::ClearRetrievalFilter</unmanaged-short>
        public unsafe void ClearRetrievalFilter()
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[22]);
        }

        /// <summary>
        /// <p>Push an empty retrieval filter onto the retrieval-filter stack.</p>
        /// </summary>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>An empty retrieval filter allows all messages to pass through.</p>
        /// </remarks>
        /// <doc-id>ff476566</doc-id>
        /// <unmanaged>HRESULT ID3D11InfoQueue::PushEmptyRetrievalFilter()</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::PushEmptyRetrievalFilter</unmanaged-short>
        public unsafe void PushEmptyRetrievalFilter()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[23]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Push a copy of retrieval filter currently on the top of the retrieval-filter stack onto the retrieval-filter stack.</p>
        /// </summary>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <doc-id>ff476564</doc-id>
        /// <unmanaged>HRESULT ID3D11InfoQueue::PushCopyOfRetrievalFilter()</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::PushCopyOfRetrievalFilter</unmanaged-short>
        public unsafe void PushCopyOfRetrievalFilter()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[24]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Push a retrieval filter onto the retrieval-filter stack.</p>
        /// </summary>
        /// <param name = "filterRef"><dd>  <p>Pointer to a retrieval filter (see <strong><see cref = "SharpDX.Direct3D11.InfoQueueFilter"/></strong>).</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <doc-id>ff476568</doc-id>
        /// <unmanaged>HRESULT ID3D11InfoQueue::PushRetrievalFilter([In] D3D11_INFO_QUEUE_FILTER* pFilter)</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::PushRetrievalFilter</unmanaged-short>
        public unsafe void PushRetrievalFilter(SharpDX.Direct3D11.InfoQueueFilter filterRef)
        {
            SharpDX.Direct3D11.InfoQueueFilter.__Native filterRef_ = default (SharpDX.Direct3D11.InfoQueueFilter.__Native);
            SharpDX.Result __result__;
            filterRef.__MarshalTo(ref filterRef_);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &filterRef_, (*(void ***)this._nativePointer)[25]);
            filterRef.__MarshalFree(ref filterRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Pop a retrieval filter from the top of the retrieval-filter stack.</p>
        /// </summary>
        /// <doc-id>ff476562</doc-id>
        /// <unmanaged>void ID3D11InfoQueue::PopRetrievalFilter()</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::PopRetrievalFilter</unmanaged-short>
        public unsafe void PopRetrievalFilter()
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[26]);
        }

        /// <summary>
        /// <p>Get the size of the retrieval-filter stack in bytes.</p>
        /// </summary>
        /// <returns><p>Size of the retrieval-filter stack in bytes.</p></returns>
        /// <doc-id>ff476559</doc-id>
        /// <unmanaged>unsigned int ID3D11InfoQueue::GetRetrievalFilterStackSize()</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::GetRetrievalFilterStackSize</unmanaged-short>
        internal unsafe System.Int32 GetRetrievalFilterStackSize()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[27]);
            return __result__;
        }

        /// <summary>
        /// <p>Add a debug message to the message queue and send that message to debug output.</p>
        /// </summary>
        /// <param name = "category"><dd>  <p>Category of a message (see <strong><see cref = "SharpDX.Direct3D11.MessageCategory"/></strong>).</p> </dd></param>
        /// <param name = "severity"><dd>  <p>Severity of a message (see <strong><see cref = "SharpDX.Direct3D11.MessageSeverity"/></strong>).</p> </dd></param>
        /// <param name = "id"><dd>  <p>Unique identifier of a message (see <strong><see cref = "SharpDX.Direct3D11.MessageId"/></strong>).</p> </dd></param>
        /// <param name = "descriptionRef"><dd>  <p>User-defined message.</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <remarks>
        /// <p>This method is used by the runtime's internal mechanisms to add debug messages to the message queue and send them to debug output. For applications to add their own custom messages to the message queue and send them to debug output, call <strong>ID3D11InfoQueue::AddApplicationMessage</strong>.</p>
        /// </remarks>
        /// <doc-id>ff476540</doc-id>
        /// <unmanaged>HRESULT ID3D11InfoQueue::AddMessage([In] D3D11_MESSAGE_CATEGORY Category,[In] D3D11_MESSAGE_SEVERITY Severity,[In] D3D11_MESSAGE_ID ID,[In] const char* pDescription)</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::AddMessage</unmanaged-short>
        public unsafe void AddMessage(SharpDX.Direct3D11.MessageCategory category, SharpDX.Direct3D11.MessageSeverity severity, SharpDX.Direct3D11.MessageId id, System.String descriptionRef)
        {
            System.IntPtr descriptionRef_;
            SharpDX.Result __result__;
            descriptionRef_ = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(descriptionRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)category), unchecked ((System.Int32)severity), unchecked ((System.Int32)id), (void *)descriptionRef_, (*(void ***)this._nativePointer)[28]);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(descriptionRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Add a user-defined message to the message queue and send that message to debug output.</p>
        /// </summary>
        /// <param name = "severity"><dd>  <p>Severity of a message (see <strong><see cref = "SharpDX.Direct3D11.MessageSeverity"/></strong>).</p> </dd></param>
        /// <param name = "descriptionRef"><dd>  <p>Message string.</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <doc-id>ff476539</doc-id>
        /// <unmanaged>HRESULT ID3D11InfoQueue::AddApplicationMessage([In] D3D11_MESSAGE_SEVERITY Severity,[In] const char* pDescription)</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::AddApplicationMessage</unmanaged-short>
        public unsafe void AddApplicationMessage(SharpDX.Direct3D11.MessageSeverity severity, System.String descriptionRef)
        {
            System.IntPtr descriptionRef_;
            SharpDX.Result __result__;
            descriptionRef_ = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(descriptionRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)severity), (void *)descriptionRef_, (*(void ***)this._nativePointer)[29]);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(descriptionRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Set a message category to break on when a message with that category passes through the storage filter.</p>
        /// </summary>
        /// <param name = "category"><dd>  <p>Message category to break on (see <strong><see cref = "SharpDX.Direct3D11.MessageCategory"/></strong>).</p> </dd></param>
        /// <param name = "bEnable"><dd>  <p>Turns this breaking condition on or off (true for on, false for off).</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <doc-id>ff476570</doc-id>
        /// <unmanaged>HRESULT ID3D11InfoQueue::SetBreakOnCategory([In] D3D11_MESSAGE_CATEGORY Category,[In] BOOL bEnable)</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::SetBreakOnCategory</unmanaged-short>
        public unsafe void SetBreakOnCategory(SharpDX.Direct3D11.MessageCategory category, SharpDX.Mathematics.Interop.RawBool bEnable)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint0(this._nativePointer, unchecked ((System.Int32)category), bEnable, (*(void ***)this._nativePointer)[30]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Set a message severity level to break on when a message with that severity level passes through the storage filter.</p>
        /// </summary>
        /// <param name = "severity"><dd>  <p>A <strong><see cref = "SharpDX.Direct3D11.MessageSeverity"/></strong>, which represents a message severity level to break on.</p> </dd></param>
        /// <param name = "bEnable"><dd>  <p>Turns this breaking condition on or off (true for on, false for off).</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <doc-id>ff476572</doc-id>
        /// <unmanaged>HRESULT ID3D11InfoQueue::SetBreakOnSeverity([In] D3D11_MESSAGE_SEVERITY Severity,[In] BOOL bEnable)</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::SetBreakOnSeverity</unmanaged-short>
        public unsafe void SetBreakOnSeverity(SharpDX.Direct3D11.MessageSeverity severity, SharpDX.Mathematics.Interop.RawBool bEnable)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint0(this._nativePointer, unchecked ((System.Int32)severity), bEnable, (*(void ***)this._nativePointer)[31]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Set a message identifier to break on when a message with that identifier passes through the storage filter.</p>
        /// </summary>
        /// <param name = "id"><dd>  <p>Message identifier to break on (see <strong><see cref = "SharpDX.Direct3D11.MessageId"/></strong>).</p> </dd></param>
        /// <param name = "bEnable"><dd>  <p>Turns this breaking condition on or off (true for on, false for off).</p> </dd></param>
        /// <returns><p>This method returns one of the following Direct3D 11 Return Codes.</p></returns>
        /// <doc-id>ff476571</doc-id>
        /// <unmanaged>HRESULT ID3D11InfoQueue::SetBreakOnID([In] D3D11_MESSAGE_ID ID,[In] BOOL bEnable)</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::SetBreakOnID</unmanaged-short>
        public unsafe void SetBreakOnID(SharpDX.Direct3D11.MessageId id, SharpDX.Mathematics.Interop.RawBool bEnable)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint0(this._nativePointer, unchecked ((System.Int32)id), bEnable, (*(void ***)this._nativePointer)[32]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Get a message category to break on when a message with that category passes through the storage filter.</p>
        /// </summary>
        /// <param name = "category"><dd>  <p>Message category to break on (see <strong><see cref = "SharpDX.Direct3D11.MessageCategory"/></strong>).</p> </dd></param>
        /// <returns><p>Whether this breaking condition is turned on or off (true for on, false for off).</p></returns>
        /// <doc-id>ff476546</doc-id>
        /// <unmanaged>BOOL ID3D11InfoQueue::GetBreakOnCategory([In] D3D11_MESSAGE_CATEGORY Category)</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::GetBreakOnCategory</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool GetBreakOnCategory(SharpDX.Direct3D11.MessageCategory category)
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, unchecked ((System.Int32)category), (*(void ***)this._nativePointer)[33]);
            return __result__;
        }

        /// <summary>
        /// <p>Get a message severity level to break on when a message with that severity level passes through the storage filter.</p>
        /// </summary>
        /// <param name = "severity"><dd>  <p>Message severity level to break on (see <strong><see cref = "SharpDX.Direct3D11.MessageSeverity"/></strong>).</p> </dd></param>
        /// <returns><p>Whether this breaking condition is turned on or off (true for on, false for off).</p></returns>
        /// <doc-id>ff476548</doc-id>
        /// <unmanaged>BOOL ID3D11InfoQueue::GetBreakOnSeverity([In] D3D11_MESSAGE_SEVERITY Severity)</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::GetBreakOnSeverity</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool GetBreakOnSeverity(SharpDX.Direct3D11.MessageSeverity severity)
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, unchecked ((System.Int32)severity), (*(void ***)this._nativePointer)[34]);
            return __result__;
        }

        /// <summary>
        /// <p>Get a message identifier to break on when a message with that identifier passes through the storage filter.</p>
        /// </summary>
        /// <param name = "id"><dd>  <p>Message identifier to break on (see <strong><see cref = "SharpDX.Direct3D11.MessageId"/></strong>).</p> </dd></param>
        /// <returns><p>Whether this breaking condition is turned on or off (true for on, false for off).</p></returns>
        /// <doc-id>ff476547</doc-id>
        /// <unmanaged>BOOL ID3D11InfoQueue::GetBreakOnID([In] D3D11_MESSAGE_ID ID)</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::GetBreakOnID</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool GetBreakOnID(SharpDX.Direct3D11.MessageId id)
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, unchecked ((System.Int32)id), (*(void ***)this._nativePointer)[35]);
            return __result__;
        }

        /// <summary>
        /// <p>Set a boolean that turns the debug output on or off.</p>
        /// </summary>
        /// <param name = "bMute"><dd>  <p>Disable/Enable the debug output (<strong>TRUE</strong> to disable or mute the output, <strong><see cref = "SharpDX.Result.False"/></strong> to enable the output).</p> </dd></param>
        /// <remarks>
        /// <p>This will stop messages that pass the storage filter from being printed out in the debug output, however those messages will still be added to the message queue.</p>
        /// </remarks>
        /// <doc-id>ff476574</doc-id>
        /// <unmanaged>void ID3D11InfoQueue::SetMuteDebugOutput([In] BOOL bMute)</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::SetMuteDebugOutput</unmanaged-short>
        internal unsafe void SetMuteDebugOutput(SharpDX.Mathematics.Interop.RawBool bMute)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid0(this._nativePointer, bMute, (*(void ***)this._nativePointer)[36]);
        }

        /// <summary>
        /// <p>Get a boolean that turns the debug output on or off.</p>
        /// </summary>
        /// <returns><p>Whether the debug output is on or off (true for on, false for off).</p></returns>
        /// <doc-id>ff476551</doc-id>
        /// <unmanaged>BOOL ID3D11InfoQueue::GetMuteDebugOutput()</unmanaged>
        /// <unmanaged-short>ID3D11InfoQueue::GetMuteDebugOutput</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawBool GetMuteDebugOutput()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[37]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("c0bfa96c-e089-44fb-8eaf-26f8796190da")]
    public partial class InputAssemblerStage : SharpDX.CppObject
    {
        public InputAssemblerStage(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator InputAssemblerStage(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new InputAssemblerStage(nativePtr);
                ///<summary>Constant DefaultIndexBufferOffsetInBytes</summary>
        ///<unmanaged>D3D11_IA_DEFAULT_INDEX_BUFFER_OFFSET_IN_BYTES</unmanaged>
        public const int DefaultIndexBufferOffsetInBytes = unchecked ((int)0);
                ///<summary>Constant DefaultPrimitiveTopology</summary>
        ///<unmanaged>D3D11_IA_DEFAULT_PRIMITIVE_TOPOLOGY</unmanaged>
        public const int DefaultPrimitiveTopology = unchecked ((int)0);
                ///<summary>Constant DefaultVertexBufferOffsetInBytes</summary>
        ///<unmanaged>D3D11_IA_DEFAULT_VERTEX_BUFFER_OFFSET_IN_BYTES</unmanaged>
        public const int DefaultVertexBufferOffsetInBytes = unchecked ((int)0);
                ///<summary>Constant IndexInputResourceSlotCount</summary>
        ///<unmanaged>D3D11_IA_INDEX_INPUT_RESOURCE_SLOT_COUNT</unmanaged>
        public const int IndexInputResourceSlotCount = unchecked ((int)1);
                ///<summary>Constant InstanceIdBitCount</summary>
        ///<unmanaged>D3D11_IA_INSTANCE_ID_BIT_COUNT</unmanaged>
        public const int InstanceIdBitCount = unchecked ((int)32);
                ///<summary>Constant IntegerArithmeticBitCount</summary>
        ///<unmanaged>D3D11_IA_INTEGER_ARITHMETIC_BIT_COUNT</unmanaged>
        public const int IntegerArithmeticBitCount = unchecked ((int)32);
                ///<summary>Constant PatchMaximumControlPointCount</summary>
        ///<unmanaged>D3D11_IA_PATCH_MAX_CONTROL_POINT_COUNT</unmanaged>
        public const int PatchMaximumControlPointCount = unchecked ((int)32);
                ///<summary>Constant PrimitiveIdBitCount</summary>
        ///<unmanaged>D3D11_IA_PRIMITIVE_ID_BIT_COUNT</unmanaged>
        public const int PrimitiveIdBitCount = unchecked ((int)32);
                ///<summary>Constant VertexIdBitCount</summary>
        ///<unmanaged>D3D11_IA_VERTEX_ID_BIT_COUNT</unmanaged>
        public const int VertexIdBitCount = unchecked ((int)32);
                ///<summary>Constant VertexInputResourceSlotCount</summary>
        ///<unmanaged>D3D11_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT</unmanaged>
        public const int VertexInputResourceSlotCount = unchecked ((int)32);
                ///<summary>Constant VertexInputStructureElementsComponents</summary>
        ///<unmanaged>D3D11_IA_VERTEX_INPUT_STRUCTURE_ELEMENTS_COMPONENTS</unmanaged>
        public const int VertexInputStructureElementsComponents = unchecked ((int)128);
                ///<summary>Constant VertexInputStructureElementCount</summary>
        ///<unmanaged>D3D11_IA_VERTEX_INPUT_STRUCTURE_ELEMENT_COUNT</unmanaged>
        public const int VertexInputStructureElementCount = unchecked ((int)32);
        /// <summary>
        /// <p>Get or sets a reference to the input-layout object that is bound to the input-assembler stage.</p>
        /// </summary>
        /// <remarks>
        /// <p>For information about creating an input-layout object, see Creating the Input-Layout Object.</p><p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476450</doc-id>
        /// <unmanaged>IAGetInputLayout / IASetInputLayout</unmanaged>
        /// <unmanaged-short>IAGetInputLayout</unmanaged-short>
        public SharpDX.Direct3D11.InputLayout InputLayout
        {
            get
            {
                GetInputLayout(out var __output__);
                return __output__;
            }

            set => SetInputLayout(value);
        }

        /// <summary>
        /// <p>Get or sets information about the primitive type, and data order that describes input data for the input assembler stage.</p>
        /// </summary>
        /// <doc-id>ff476451</doc-id>
        /// <unmanaged>IAGetPrimitiveTopology / IASetPrimitiveTopology</unmanaged>
        /// <unmanaged-short>IAGetPrimitiveTopology</unmanaged-short>
        public SharpDX.Direct3D.PrimitiveTopology PrimitiveTopology
        {
            get
            {
                GetPrimitiveTopology(out var __output__);
                return __output__;
            }

            set => SetPrimitiveTopology(value);
        }

        /// <summary>
        /// <p>Bind an input-layout object to the input-assembler stage.</p>
        /// </summary>
        /// <param name = "inputLayoutRef"><dd>  <p>A reference to the input-layout object (see <strong><see cref = "SharpDX.Direct3D11.InputLayout"/></strong>), which describes the input buffers that will be read by the IA stage.</p> </dd></param>
        /// <remarks>
        /// <p>Input-layout objects describe how vertex buffer data is streamed into the IA pipeline stage. To create an input-layout object, call <strong>ID3D11Device::CreateInputLayout</strong>.</p><p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p>
        /// </remarks>
        /// <doc-id>ff476454</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::IASetInputLayout([In, Optional] ID3D11InputLayout* pInputLayout)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::IASetInputLayout</unmanaged-short>
        internal unsafe void SetInputLayout(SharpDX.Direct3D11.InputLayout inputLayoutRef)
        {
            System.IntPtr inputLayoutRef_ = System.IntPtr.Zero;
            inputLayoutRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.InputLayout>(inputLayoutRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)inputLayoutRef_, (*(void ***)this._nativePointer)[17]);
        }

        /// <summary>
        /// <p> Bind an array of vertex buffers to the input-assembler stage. </p>
        /// </summary>
        /// <param name = "startSlot">No documentation.</param>
        /// <param name = "numBuffers">No documentation.</param>
        /// <param name = "vertexBuffersOut">No documentation.</param>
        /// <param name = "stridesRef">No documentation.</param>
        /// <param name = "offsetsRef">No documentation.</param>
        /// <remarks>
        /// <p> For info about creating vertex buffers, see How to: Create a Vertex Buffer. </p><p> Calling this method using a buffer that is currently bound for writing (that is, bound to the stream output pipeline stage) will effectively bind <strong><c>null</c></strong> instead because a buffer can't be bound as both an input and an output at the same time. </p><p>The debug layer will generate a warning whenever a resource is prevented from being bound simultaneously as an input and an output, but this will not prevent invalid data from being used by the runtime.</p><p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476456</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::IASetVertexBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer* ppVertexBuffers,[In, Buffer, Optional] const unsigned int* pStrides,[In, Buffer, Optional] const unsigned int* pOffsets)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::IASetVertexBuffers</unmanaged-short>
        public unsafe void SetVertexBuffers(System.Int32 startSlot, System.Int32 numBuffers, System.IntPtr vertexBuffersOut, System.IntPtr stridesRef, System.IntPtr offsetsRef)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)vertexBuffersOut, (void *)stridesRef, (void *)offsetsRef, (*(void ***)this._nativePointer)[18]);
        }

        /// <summary>
        /// <p>Bind an index buffer to the input-assembler stage.</p>
        /// </summary>
        /// <param name = "indexBufferRef"><dd>  <p> A reference to an <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong> object, that contains indices. The index buffer must have been created with the <strong>D3D11_BIND_INDEX_BUFFER</strong> flag. </p> </dd></param>
        /// <param name = "format"><dd>  <p> A <strong><see cref = "SharpDX.DXGI.Format"/></strong> that specifies the format of the data in the index buffer. The only formats allowed for index buffer data are 16-bit (DXGI_FORMAT_R16_UINT) and 32-bit (DXGI_FORMAT_R32_UINT) integers. </p> </dd></param>
        /// <param name = "offset"><dd>  <p>Offset (in bytes) from the start of the index buffer to the first index to use.</p> </dd></param>
        /// <remarks>
        /// <p> For information about creating index buffers, see How to: Create an Index Buffer. </p><p> Calling this method using a buffer that is currently bound for writing (i.e. bound to the stream output pipeline stage) will effectively bind <strong><c>null</c></strong> instead because a buffer cannot be bound as both an input and an output at the same time. </p><p> The debug layer will generate a warning whenever a resource is prevented from being bound simultaneously as an input and an output, but this will not prevent invalid data from being used by the runtime. </p><p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476453</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::IASetIndexBuffer([In, Optional] ID3D11Buffer* pIndexBuffer,[In] DXGI_FORMAT Format,[In] unsigned int Offset)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::IASetIndexBuffer</unmanaged-short>
        public unsafe void SetIndexBuffer(SharpDX.Direct3D11.Buffer indexBufferRef, SharpDX.DXGI.Format format, System.Int32 offset)
        {
            System.IntPtr indexBufferRef_ = System.IntPtr.Zero;
            indexBufferRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Buffer>(indexBufferRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)indexBufferRef_, unchecked ((System.Int32)format), offset, (*(void ***)this._nativePointer)[19]);
        }

        /// <summary>
        /// <p>Bind information about the primitive type, and data order that describes input data for the input assembler stage.</p>
        /// </summary>
        /// <param name = "topology"><dd>  <p> The type of primitive and ordering of the primitive data (see <strong>D3D11_PRIMITIVE_TOPOLOGY</strong>). </p> </dd></param>
        /// <remarks>
        /// <p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476455</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::IASetPrimitiveTopology([In] D3D_PRIMITIVE_TOPOLOGY Topology)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::IASetPrimitiveTopology</unmanaged-short>
        internal unsafe void SetPrimitiveTopology(SharpDX.Direct3D.PrimitiveTopology topology)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)topology), (*(void ***)this._nativePointer)[24]);
        }

        /// <summary>
        /// <p>Get a reference to the input-layout object that is bound to the input-assembler stage.</p>
        /// </summary>
        /// <param name = "inputLayoutOut"><dd>  <p>A reference to the input-layout object (see <strong><see cref = "SharpDX.Direct3D11.InputLayout"/></strong>), which describes the input buffers that will be read by the IA stage.</p> </dd></param>
        /// <remarks>
        /// <p>For information about creating an input-layout object, see Creating the Input-Layout Object.</p><p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476450</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::IAGetInputLayout([Out, Optional] ID3D11InputLayout** ppInputLayout)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::IAGetInputLayout</unmanaged-short>
        internal unsafe void GetInputLayout(out SharpDX.Direct3D11.InputLayout inputLayoutOut)
        {
            System.IntPtr inputLayoutOut_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, &inputLayoutOut_, (*(void ***)this._nativePointer)[78]);
            if (inputLayoutOut_ != System.IntPtr.Zero)
                inputLayoutOut = new SharpDX.Direct3D11.InputLayout(inputLayoutOut_);
            else
                inputLayoutOut = null;
        }

        /// <summary>
        /// <p>Get the vertex buffers bound to the input-assembler stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>The input slot of the first vertex buffer to get. The first vertex buffer is explicitly bound to the start slot; this causes each additional vertex buffer in the array to be implicitly bound to each subsequent input slot. The maximum of 16 or 32 input slots (ranges from 0 to <see cref = "VertexInputResourceSlotCount"/> - 1) are available; the maximum number of input slots depends on the feature level.</p> </dd></param>
        /// <param name = "numBuffers"><dd>  <p>The number of vertex buffers to get starting at the offset. The number of buffers (plus the starting slot) cannot exceed the total number of IA-stage input slots.</p> </dd></param>
        /// <param name = "vertexBuffersOut"><dd>  <p>A reference to an array of vertex buffers returned by the method (see <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>).</p> </dd></param>
        /// <param name = "stridesRef"><dd>  <p>Pointer to an array of stride values returned by the method; one stride value for each buffer in the vertex-buffer array. Each stride value is the size (in bytes) of the elements that are to be used from that vertex buffer.</p> </dd></param>
        /// <param name = "offsetsRef"><dd>  <p>Pointer to an array of offset values returned by the method; one offset value for each buffer in the vertex-buffer array. Each offset is the number of bytes between the first element of a vertex buffer and the first element that will be used.</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476452</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::IAGetVertexBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[Out, Buffer, Optional] ID3D11Buffer** ppVertexBuffers,[Out, Buffer, Optional] unsigned int* pStrides,[Out, Buffer, Optional] unsigned int* pOffsets)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::IAGetVertexBuffers</unmanaged-short>
        public unsafe void GetVertexBuffers(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.Direct3D11.Buffer[] vertexBuffersOut, System.Int32[] stridesRef, System.Int32[] offsetsRef)
        {
            System.IntPtr*vertexBuffersOut_;
            vertexBuffersOut_ = (System.IntPtr*)0;
            if (vertexBuffersOut != null)
            {
                System.IntPtr*_vertexBuffersOut = stackalloc System.IntPtr[vertexBuffersOut.Length];
                vertexBuffersOut_ = _vertexBuffersOut;
            }

            fixed (void *offsetsRef_ = offsetsRef)
                fixed (void *stridesRef_ = stridesRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)vertexBuffersOut_, stridesRef_, offsetsRef_, (*(void ***)this._nativePointer)[79]);
            if (vertexBuffersOut != null)
                for (int i = 0; i < vertexBuffersOut.Length; ++i)
                    if ((vertexBuffersOut_)[i] != System.IntPtr.Zero)
                        vertexBuffersOut[i] = new SharpDX.Direct3D11.Buffer((vertexBuffersOut_)[i]);
                    else
                        vertexBuffersOut[i] = null;
        }

        /// <summary>
        /// <p>Get a reference to the index buffer that is bound to the input-assembler stage.</p>
        /// </summary>
        /// <param name = "indexBufferRef"><dd>  <p>A reference to an index buffer returned by the method (see <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>).</p> </dd></param>
        /// <param name = "format"><dd>  <p>Specifies format of the data in the index buffer (see <strong><see cref = "SharpDX.DXGI.Format"/></strong>). These formats provide the size and type of  the data in the buffer. The only formats allowed for index buffer data are 16-bit (DXGI_FORMAT_R16_UINT) and 32-bit (DXGI_FORMAT_R32_UINT)  integers.</p> </dd></param>
        /// <param name = "offset"><dd>  <p>Offset (in bytes) from the start of the index buffer, to the first index to use.</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces  when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476449</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::IAGetIndexBuffer([Out, Optional] ID3D11Buffer** pIndexBuffer,[Out, Optional] DXGI_FORMAT* Format,[Out, Optional] unsigned int* Offset)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::IAGetIndexBuffer</unmanaged-short>
        public unsafe void GetIndexBuffer(out SharpDX.Direct3D11.Buffer indexBufferRef, out SharpDX.DXGI.Format format, out System.Int32 offset)
        {
            System.IntPtr indexBufferRef_ = System.IntPtr.Zero;
            fixed (void *offset_ = &offset)
                fixed (void *format_ = &format)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, &indexBufferRef_, format_, offset_, (*(void ***)this._nativePointer)[80]);
            if (indexBufferRef_ != System.IntPtr.Zero)
                indexBufferRef = new SharpDX.Direct3D11.Buffer(indexBufferRef_);
            else
                indexBufferRef = null;
        }

        /// <summary>
        /// <p>Get information about the primitive type, and data order that describes input data for the input assembler stage.</p>
        /// </summary>
        /// <param name = "topologyRef"><dd>  <p>A reference to the type of primitive, and ordering of the primitive data (see <strong>D3D11_PRIMITIVE_TOPOLOGY</strong>).</p> </dd></param>
        /// <doc-id>ff476451</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::IAGetPrimitiveTopology([Out] D3D_PRIMITIVE_TOPOLOGY* pTopology)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::IAGetPrimitiveTopology</unmanaged-short>
        internal unsafe void GetPrimitiveTopology(out SharpDX.Direct3D.PrimitiveTopology topologyRef)
        {
            fixed (void *topologyRef_ = &topologyRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, topologyRef_, (*(void ***)this._nativePointer)[83]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("e4819ddc-4cf0-4025-bd26-5de82a3e07b7")]
    public partial class InputLayout : SharpDX.Direct3D11.DeviceChild
    {
        public InputLayout(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator InputLayout(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new InputLayout(nativePtr);
    }

    [System.Runtime.InteropServices.GuidAttribute("9B7E4E00-342C-4106-A19F-4F2704F689F0")]
    public partial class Multithread : SharpDX.ComObject
    {
        public Multithread(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Multithread(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Multithread(nativePtr);
        /// <summary>
        /// <p>Enter a device's critical section.</p>
        /// </summary>
        /// <remarks>
        /// <p>If <strong>SetMultithreadProtected</strong> is set to true, then entering a device's critical section prevents other threads from simultaneously calling that device's methods, calling DXGI methods, and calling the methods of all resource, view, shader, state, and asynchronous interfaces.</p><p>This function should be used in multithreaded applications when there is a series of graphics commands that must happen in order. This function is typically called at the beginning of the series of graphics commands, and <strong>Leave</strong> is typically called after those graphics commands.</p>
        /// </remarks>
        /// <doc-id>mt644887</doc-id>
        /// <unmanaged>void ID3D11Multithread::Enter()</unmanaged>
        /// <unmanaged-short>ID3D11Multithread::Enter</unmanaged-short>
        public unsafe void Enter()
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[3]);
        }

        /// <summary>
        /// <p>Leave a device's critical section.</p>
        /// </summary>
        /// <remarks>
        /// <p>This function is typically used in multithreaded applications when there is a series of graphics commands  that must happen in order. <strong>Enter</strong> is typically called at the beginning of a series of graphics commands, and this function is typically  called after those graphics commands.</p>
        /// </remarks>
        /// <doc-id>mt644890</doc-id>
        /// <unmanaged>void ID3D11Multithread::Leave()</unmanaged>
        /// <unmanaged-short>ID3D11Multithread::Leave</unmanaged-short>
        public unsafe void Leave()
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[4]);
        }

        /// <summary>
        /// <p>Turns multithread protection on or off.</p>
        /// </summary>
        /// <param name = "bMTProtect"><dd>  <p>Set to true to turn multithread protection on, false to turn it off.</p> </dd></param>
        /// <returns><p>True if multithread protection was already turned on prior to calling this method, false otherwise. </p></returns>
        /// <doc-id>mt644891</doc-id>
        /// <unmanaged>BOOL ID3D11Multithread::SetMultithreadProtected([In] BOOL bMTProtect)</unmanaged>
        /// <unmanaged-short>ID3D11Multithread::SetMultithreadProtected</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool SetMultithreadProtected(SharpDX.Mathematics.Interop.RawBool bMTProtect)
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool0(this._nativePointer, bMTProtect, (*(void ***)this._nativePointer)[5]);
            return __result__;
        }

        /// <summary>
        /// <p>Find out if multithread protection is turned on or not.</p>
        /// </summary>
        /// <returns><p>Returns true if multithread protection is turned on, false otherwise. </p></returns>
        /// <doc-id>mt644889</doc-id>
        /// <unmanaged>BOOL ID3D11Multithread::GetMultithreadProtected()</unmanaged>
        /// <unmanaged-short>ID3D11Multithread::GetMultithreadProtected</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool GetMultithreadProtected()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[6]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("c0bfa96c-e089-44fb-8eaf-26f8796190da")]
    public partial class OutputMergerStage : SharpDX.CppObject
    {
        public OutputMergerStage(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator OutputMergerStage(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new OutputMergerStage(nativePtr);
                ///<summary>Constant SimultaneousRenderTargetCount</summary>
        ///<unmanaged>D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT</unmanaged>
        public const int SimultaneousRenderTargetCount = unchecked ((int)8);
        /// <summary>
        /// <p>Bind one or more render targets atomically and the depth-stencil buffer to the output-merger stage.</p>
        /// </summary>
        /// <param name = "numViews">No documentation.</param>
        /// <param name = "renderTargetViewsOut">No documentation.</param>
        /// <param name = "depthStencilViewRef">No documentation.</param>
        /// <remarks>
        /// <p>The maximum number of active render targets a device can have active at any given time is set by a #define in D3D11.h called  <strong><see cref = "SimultaneousRenderTargetCount"/></strong>. It is invalid to try to set the same subresource to multiple render target slots.  Any render targets not defined by this call are set to <strong><c>null</c></strong>.</p><p>If any subresources are also currently bound for reading in a different stage or writing (perhaps in a different part of the pipeline),  those bind points will be set to <strong><c>null</c></strong>, in order to prevent the same subresource from being read and written simultaneously in a single rendering operation.</p><p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p>If the render-target views were created from an array resource type, all of the render-target views must have the same array size.   This restriction also applies to the depth-stencil view, its array size must match that of the render-target views being bound.</p><p>The pixel shader must be able to simultaneously render to at least eight separate render targets. All of these render targets must access the same type of resource: Buffer, Texture1D, Texture1DArray, Texture2D, Texture2DArray, Texture3D, or TextureCube. All render targets must have the same size in all dimensions (width and height, and depth for 3D or array size for *Array types). If render targets use multisample anti-aliasing, all bound render targets and depth buffer must be the same form of multisample resource (that is, the sample counts must be the same). Each render target can have a different data format. These render target formats are not required to have identical bit-per-element counts.</p><p>Any combination of the eight slots for render targets can have a render target set or not set.</p><p>The same resource view cannot be bound to multiple render target slots simultaneously. However, you can set multiple non-overlapping resource views of a single resource as simultaneous multiple render targets.</p>
        /// </remarks>
        /// <doc-id>ff476464</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::OMSetRenderTargets([In] unsigned int NumViews,[In] const ID3D11RenderTargetView** ppRenderTargetViews,[In, Optional] ID3D11DepthStencilView* pDepthStencilView)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::OMSetRenderTargets</unmanaged-short>
        internal unsafe void SetRenderTargets(System.Int32 numViews, System.IntPtr renderTargetViewsOut, SharpDX.Direct3D11.DepthStencilView depthStencilViewRef)
        {
            System.IntPtr depthStencilViewRef_ = System.IntPtr.Zero;
            depthStencilViewRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.DepthStencilView>(depthStencilViewRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, numViews, (void *)renderTargetViewsOut, (void *)depthStencilViewRef_, (*(void ***)this._nativePointer)[33]);
        }

        /// <summary>
        /// <p>Binds resources to the output-merger stage.</p>
        /// </summary>
        /// <param name = "numRTVs"><dd>  <p> Number of render targets to bind (ranges between 0 and <strong><see cref = "SimultaneousRenderTargetCount"/></strong>). If this parameter is nonzero, the number of entries in the array to which <em>ppRenderTargetViews</em> points must equal the number in this parameter. If you set <em>NumRTVs</em> to D3D11_KEEP_RENDER_TARGETS_AND_DEPTH_STENCIL (0xffffffff), this method does not modify the currently bound render-target views (RTVs) and also does not modify depth-stencil view (DSV). </p> </dd></param>
        /// <param name = "renderTargetViewsOut"><dd>  <p> Pointer to an array of <strong><see cref = "SharpDX.Direct3D11.RenderTargetView"/></strong>s that represent the render targets to bind to the device. If this parameter is <strong><c>null</c></strong> and <em>NumRTVs</em> is 0, no render targets are bound. </p> </dd></param>
        /// <param name = "depthStencilViewRef"><dd>  <p> Pointer to a <strong><see cref = "SharpDX.Direct3D11.DepthStencilView"/></strong> that represents the depth-stencil view to bind to the device. If this parameter is <strong><c>null</c></strong>, the depth-stencil state is not bound. </p> </dd></param>
        /// <param name = "uAVStartSlot"><dd>  <p>Index into a zero-based array to begin setting unordered-access views (ranges from 0 to <see cref = "UnorderedAccessViewSlotCount"/> - 1).</p> <p> For the Direct3D 11.1 runtime, which is available starting with Windows?8, this value can range from 0 to D3D11_1_UAV_SLOT_COUNT - 1. D3D11_1_UAV_SLOT_COUNT is defined as 64. </p> <p> For pixel shaders, <em>UAVStartSlot</em> should be equal to the number of render-target views being bound. </p> </dd></param>
        /// <param name = "numUAVs"><dd>  <p> Number of unordered-access views (UAVs) in <em>ppUnorderedAccessViews</em>. If you set <em>NumUAVs</em> to D3D11_KEEP_UNORDERED_ACCESS_VIEWS (0xffffffff), this method does not modify the currently bound unordered-access views. </p> <p> For the Direct3D 11.1 runtime, which is available starting with Windows?8, this value can range from 0 to D3D11_1_UAV_SLOT_COUNT - <em>UAVStartSlot</em>. </p> </dd></param>
        /// <param name = "unorderedAccessViewsOut"><dd>  <p> Pointer to an array of <strong><see cref = "SharpDX.Direct3D11.UnorderedAccessView"/></strong>s that represent the unordered-access views to bind to the device. If this parameter is <strong><c>null</c></strong> and <em>NumUAVs</em> is 0, no unordered-access views are bound. </p> </dd></param>
        /// <param name = "uAVInitialCountsRef"><dd>  <p> An array of append and consume buffer offsets. A value of -1 indicates to keep the current offset. Any other values set the hidden counter for that appendable and consumable UAV. <em>pUAVInitialCounts</em> is  relevant only for UAVs that were created with either <strong>D3D11_BUFFER_UAV_FLAG_APPEND</strong> or <strong>D3D11_BUFFER_UAV_FLAG_COUNTER</strong> specified when the UAV was created; otherwise, the argument is ignored. </p> </dd></param>
        /// <remarks>
        /// <p> For pixel shaders, the render targets and unordered-access views share the same resource slots when being written out. This means that UAVs must be given an offset so that they are placed in the slots after the render target views that are being bound. </p><strong>Note</strong>??RTVs, DSV, and UAVs cannot be set independently; they all need to be set at the same time.?<p>Two RTVs conflict if they share a subresource (and therefore share the same resource).</p><p>Two UAVs conflict if they share a subresource (and therefore share the same resource).</p><p>An RTV conflicts with a UAV if they share a subresource or share a bind point.</p><p><strong>OMSetRenderTargetsAndUnorderedAccessViews</strong> operates properly in the following situations: </p><ol> <li> <p><em>NumRTVs</em> != D3D11_KEEP_RENDER_TARGETS_AND_DEPTH_STENCIL and <em>NumUAVs</em> != D3D11_KEEP_UNORDERED_ACCESS_VIEWS </p> <p> The following conditions must be true for <strong>OMSetRenderTargetsAndUnorderedAccessViews</strong> to succeed and for the runtime to pass the bind information to the driver: </p> <ul> <li><em>NumRTVs</em> &lt;= 8 </li> <li><em>UAVStartSlot</em> &gt;= <em>NumRTVs</em></li> <li><em>UAVStartSlot</em> + <em>NumUAVs</em> &lt;= 8 </li> <li> There must be no conflicts in the set of all <em>ppRenderTargetViews</em> and <em>ppUnorderedAccessViews</em>. </li> <li><em>ppDepthStencilView</em> must match the render-target views. For more information about resource views, see Introduction to a Resource in Direct3D 11. </li> </ul> <p><strong>OMSetRenderTargetsAndUnorderedAccessViews</strong> performs the following tasks: </p> <ul> <li>Unbinds all currently bound conflicting resources (stream-output target resources (SOTargets), compute shader (CS) UAVs, shader-resource views (SRVs)).</li> <li> Binds <em>ppRenderTargetViews</em>, <em>ppDepthStencilView</em>, and <em>ppUnorderedAccessViews</em>. </li> </ul> </li> <li> <p><em>NumRTVs</em> == D3D11_KEEP_RENDER_TARGETS_AND_DEPTH_STENCIL </p> <p> In this situation, <strong>OMSetRenderTargetsAndUnorderedAccessViews</strong> binds only UAVs. </p> <p> The following conditions must be true for <strong>OMSetRenderTargetsAndUnorderedAccessViews</strong> to succeed and for the runtime to pass the bind information to the driver: </p> <ul> <li><em>UAVStartSlot</em> + <em>NumUAVs</em> &lt;= 8 </li> <li> There must be no conflicts in <em>ppUnorderedAccessViews</em>. </li> </ul> <p><strong>OMSetRenderTargetsAndUnorderedAccessViews</strong> unbinds the following items: </p> <ul> <li> All RTVs in slots &gt;= <em>UAVStartSlot</em></li> <li> All RTVs that conflict with any UAVs in <em>ppUnorderedAccessViews</em></li> <li> All currently bound resources (SOTargets, CS UAVs, SRVs) that conflict with <em>ppUnorderedAccessViews</em></li> </ul> <p><strong>OMSetRenderTargetsAndUnorderedAccessViews</strong> binds <em>ppUnorderedAccessViews</em>. </p> <p><strong>OMSetRenderTargetsAndUnorderedAccessViews</strong> ignores <em>ppDepthStencilView</em>, and the current depth-stencil view remains bound. </p> </li> <li> <p><em>NumUAVs</em> == D3D11_KEEP_UNORDERED_ACCESS_VIEWS </p> <p> In this situation, <strong>OMSetRenderTargetsAndUnorderedAccessViews</strong> binds only RTVs and DSV. </p> <p> The following conditions must be true for <strong>OMSetRenderTargetsAndUnorderedAccessViews</strong> to succeed and for the runtime to pass the bind information to the driver: </p> <ul> <li><em>NumRTVs</em> &lt;= 8 </li> <li> There must be no conflicts in <em>ppRenderTargetViews</em>. </li> <li><em>ppDepthStencilView</em> must match the render-target views. For more information about resource views, see Introduction to a Resource in Direct3D 11. </li> </ul> <p><strong>OMSetRenderTargetsAndUnorderedAccessViews</strong> unbinds the following items: </p> <ul> <li> All UAVs in slots &lt; <em>NumRTVs</em></li> <li> All UAVs that conflict with any RTVs in <em>ppRenderTargetViews</em></li> <li> All currently bound resources (SOTargets, CS UAVs, SRVs) that conflict with <em>ppRenderTargetViews</em></li> </ul> <p><strong>OMSetRenderTargetsAndUnorderedAccessViews</strong> binds <em>ppRenderTargetViews</em> and <em>ppDepthStencilView</em>. </p> <p><strong>OMSetRenderTargetsAndUnorderedAccessViews</strong> ignores <em>UAVStartSlot</em>. </p> </li> </ol><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476465</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::OMSetRenderTargetsAndUnorderedAccessViews([In] unsigned int NumRTVs,[In, Buffer, Optional] const ID3D11RenderTargetView** ppRenderTargetViews,[In, Optional] ID3D11DepthStencilView* pDepthStencilView,[In] unsigned int UAVStartSlot,[In] unsigned int NumUAVs,[In, Buffer, Optional] const ID3D11UnorderedAccessView** ppUnorderedAccessViews,[In, Buffer, Optional] const unsigned int* pUAVInitialCounts)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::OMSetRenderTargetsAndUnorderedAccessViews</unmanaged-short>
        internal unsafe void SetRenderTargetsAndUnorderedAccessViews(System.Int32 numRTVs, System.IntPtr renderTargetViewsOut, SharpDX.Direct3D11.DepthStencilView depthStencilViewRef, System.Int32 uAVStartSlot, System.Int32 numUAVs, System.IntPtr unorderedAccessViewsOut, System.IntPtr uAVInitialCountsRef)
        {
            System.IntPtr depthStencilViewRef_ = System.IntPtr.Zero;
            depthStencilViewRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.DepthStencilView>(depthStencilViewRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, numRTVs, (void *)renderTargetViewsOut, (void *)depthStencilViewRef_, uAVStartSlot, numUAVs, (void *)unorderedAccessViewsOut, (void *)uAVInitialCountsRef, (*(void ***)this._nativePointer)[34]);
        }

        /// <summary>
        /// <p>Set the blend state of the output-merger stage.</p>
        /// </summary>
        /// <param name = "blendStateRef"><dd>  <p>Pointer to a blend-state interface (see <strong><see cref = "SharpDX.Direct3D11.BlendState"/></strong>). Pass <strong><c>null</c></strong> for a default blend state. For more info about default blend state, see Remarks.</p> </dd></param>
        /// <param name = "blendFactor"><dd>  <p>Array of blend factors, one for each RGBA component. The blend factors modulate values for the pixel shader, render target, or both. If you created  the blend-state object with <strong>D3D11_BLEND_BLEND_FACTOR</strong> or <strong>D3D11_BLEND_INV_BLEND_FACTOR</strong>, the blending stage uses the non-<c>null</c> array of blend factors. If you didn't create the blend-state object with <strong>D3D11_BLEND_BLEND_FACTOR</strong> or <strong>D3D11_BLEND_INV_BLEND_FACTOR</strong>, the blending stage does not use the non-<c>null</c> array of blend factors; the runtime stores the blend factors, and you can later call <strong>ID3D11DeviceContext::OMGetBlendState</strong> to retrieve the blend factors. If you pass <strong><c>null</c></strong>, the runtime uses or stores a blend factor equal to { 1, 1, 1, 1 }.</p> </dd></param>
        /// <param name = "sampleMask"><dd>  <p>32-bit sample coverage. The default value is 0xffffffff. See remarks.</p> </dd></param>
        /// <remarks>
        /// <p>Blend state is used by the output-merger stage to determine how to blend together two RGB pixel values and two alpha values. The two RGB pixel values and two alpha values are the RGB pixel value and alpha value that the pixel shader outputs and the RGB pixel value and alpha value already in the output render target. The <strong>blend option</strong> controls the data source that the blending stage uses to modulate values for the pixel shader, render target, or both. The <strong>blend operation</strong> controls how the blending stage mathematically combines these modulated values.</p><p>To create a blend-state interface, call <strong>ID3D11Device::CreateBlendState</strong>.</p><p>Passing in <strong><c>null</c></strong> for the blend-state interface indicates to the runtime to set a default blending state.  The following table indicates the default blending parameters.</p><table> <tr><th>State</th><th>Default Value</th></tr> <tr><td>AlphaToCoverageEnable</td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td>IndependentBlendEnable</td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td>RenderTarget[0].BlendEnable</td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td>RenderTarget[0].SrcBlend</td><td>D3D11_BLEND_ONE</td></tr> <tr><td>RenderTarget[0].DestBlend</td><td>D3D11_BLEND_ZERO</td></tr> <tr><td>RenderTarget[0].BlendOp</td><td>D3D11_BLEND_OP_ADD</td></tr> <tr><td>RenderTarget[0].SrcBlendAlpha</td><td>D3D11_BLEND_ONE</td></tr> <tr><td>RenderTarget[0].DestBlendAlpha</td><td>D3D11_BLEND_ZERO</td></tr> <tr><td>RenderTarget[0].BlendOpAlpha</td><td>D3D11_BLEND_OP_ADD</td></tr> <tr><td>RenderTarget[0].RenderTargetWriteMask</td><td>D3D11_COLOR_WRITE_ENABLE_ALL</td></tr> </table><p>?</p><p>A sample mask determines which samples get updated in all the active render targets. The mapping of bits in a sample mask to samples in a multisample render target is the responsibility of an individual application. A sample mask is always applied; it is independent of whether multisampling is enabled, and does not depend on whether an application uses multisample render targets.</p><p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p>
        /// </remarks>
        /// <doc-id>ff476462</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::OMSetBlendState([In, Optional] ID3D11BlendState* pBlendState,[In, Optional] const SHARPDX_COLOR4* BlendFactor,[In] unsigned int SampleMask)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::OMSetBlendState</unmanaged-short>
        public unsafe void SetBlendState(SharpDX.Direct3D11.BlendState blendStateRef, SharpDX.Mathematics.Interop.RawColor4? blendFactor = null, System.Int32 sampleMask = -1)
        {
            System.IntPtr blendStateRef_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawColor4 blendFactor_;
            blendStateRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.BlendState>(blendStateRef);
            if (blendFactor != null)
                blendFactor_ = blendFactor.Value;
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)blendStateRef_, blendFactor == null ? (void *)0 : &blendFactor_, sampleMask, (*(void ***)this._nativePointer)[35]);
        }

        /// <summary>
        /// <p>Sets the depth-stencil state of the output-merger stage.</p>
        /// </summary>
        /// <param name = "depthStencilStateRef"><dd>  <p>Pointer to a depth-stencil state interface (see <strong><see cref = "SharpDX.Direct3D11.DepthStencilState"/></strong>) to bind to the device. Set this to <strong><c>null</c></strong> to use the default state listed in <strong><see cref = "SharpDX.Direct3D11.DepthStencilStateDescription"/></strong>.</p> </dd></param>
        /// <param name = "stencilRef"><dd>  <p>Reference value to perform against when doing a depth-stencil test. See remarks.</p> </dd></param>
        /// <remarks>
        /// <p>To create a depth-stencil state interface, call <strong>ID3D11Device::CreateDepthStencilState</strong>.</p><p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p>
        /// </remarks>
        /// <doc-id>ff476463</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::OMSetDepthStencilState([In, Optional] ID3D11DepthStencilState* pDepthStencilState,[In] unsigned int StencilRef)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::OMSetDepthStencilState</unmanaged-short>
        public unsafe void SetDepthStencilState(SharpDX.Direct3D11.DepthStencilState depthStencilStateRef, System.Int32 stencilRef = 0)
        {
            System.IntPtr depthStencilStateRef_ = System.IntPtr.Zero;
            depthStencilStateRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.DepthStencilState>(depthStencilStateRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)depthStencilStateRef_, stencilRef, (*(void ***)this._nativePointer)[36]);
        }

        /// <summary>
        /// <p>Get references to the resources bound to the output-merger stage.</p>
        /// </summary>
        /// <param name = "numViews"><dd>  <p>Number of render targets to retrieve.</p> </dd></param>
        /// <param name = "renderTargetViewsOut"><dd>  <p>Pointer to an array of <strong><see cref = "SharpDX.Direct3D11.RenderTargetView"/></strong>s which represent render target views. Specify <strong><c>null</c></strong> for this parameter when retrieval of a render target is not needed. </p> </dd></param>
        /// <param name = "depthStencilViewOut"><dd>  <p>Pointer to a <strong><see cref = "SharpDX.Direct3D11.DepthStencilView"/></strong>, which represents a depth-stencil view. Specify <strong><c>null</c></strong> for this parameter when retrieval of the depth-stencil view is not needed.</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476460</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::OMGetRenderTargets([In] unsigned int NumViews,[Out, Buffer, Optional] ID3D11RenderTargetView** ppRenderTargetViews,[Out, Optional] ID3D11DepthStencilView** ppDepthStencilView)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::OMGetRenderTargets</unmanaged-short>
        internal unsafe void GetRenderTargets(System.Int32 numViews, SharpDX.Direct3D11.RenderTargetView[] renderTargetViewsOut, out SharpDX.Direct3D11.DepthStencilView depthStencilViewOut)
        {
            System.IntPtr*renderTargetViewsOut_;
            renderTargetViewsOut_ = (System.IntPtr*)0;
            if (renderTargetViewsOut != null)
            {
                System.IntPtr*_renderTargetViewsOut = stackalloc System.IntPtr[renderTargetViewsOut.Length];
                renderTargetViewsOut_ = _renderTargetViewsOut;
            }

            System.IntPtr depthStencilViewOut_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, numViews, (void *)renderTargetViewsOut_, &depthStencilViewOut_, (*(void ***)this._nativePointer)[89]);
            if (renderTargetViewsOut != null)
                for (int i = 0; i < renderTargetViewsOut.Length; ++i)
                    if ((renderTargetViewsOut_)[i] != System.IntPtr.Zero)
                        renderTargetViewsOut[i] = new SharpDX.Direct3D11.RenderTargetView((renderTargetViewsOut_)[i]);
                    else
                        renderTargetViewsOut[i] = null;
            if (depthStencilViewOut_ != System.IntPtr.Zero)
                depthStencilViewOut = new SharpDX.Direct3D11.DepthStencilView(depthStencilViewOut_);
            else
                depthStencilViewOut = null;
        }

        /// <summary>
        /// <p>Get references to the resources bound to the output-merger stage.</p>
        /// </summary>
        /// <param name = "numRTVs"><dd>  <p>The number of render-target views to retrieve.</p> </dd></param>
        /// <param name = "renderTargetViewsOut"><dd>  <p> Pointer to an array of <strong><see cref = "SharpDX.Direct3D11.RenderTargetView"/></strong>s, which represent render-target views. Specify <strong><c>null</c></strong> for this parameter when retrieval of render-target views is not required. </p> </dd></param>
        /// <param name = "depthStencilViewOut"><dd>  <p> Pointer to a <strong><see cref = "SharpDX.Direct3D11.DepthStencilView"/></strong>, which represents a depth-stencil view. Specify <strong><c>null</c></strong> for this parameter when retrieval of the depth-stencil view is not required. </p> </dd></param>
        /// <param name = "uAVStartSlot"><dd>  <p> Index into a zero-based array to begin retrieving unordered-access views (ranges from 0 to <see cref = "UnorderedAccessViewSlotCount"/> - 1). For pixel shaders <em>UAVStartSlot</em> should be equal to the number of render-target views that are bound. </p> </dd></param>
        /// <param name = "numUAVs"><dd>  <p> Number of unordered-access views to return in <em>ppUnorderedAccessViews</em>. This number ranges from 0 to <see cref = "UnorderedAccessViewSlotCount"/> - <em>UAVStartSlot</em>. </p> </dd></param>
        /// <param name = "unorderedAccessViewsOut"><dd>  <p> Pointer to an array of <strong><see cref = "SharpDX.Direct3D11.UnorderedAccessView"/></strong>s, which represent unordered-access views that are retrieved. Specify <strong><c>null</c></strong> for this parameter when retrieval of unordered-access views is not required. </p> </dd></param>
        /// <remarks>
        /// <p> Any returned interfaces will have their reference count incremented by one. Applications should call <strong>IUnknown::Release</strong> on the returned interfaces when they are no longer needed to avoid memory leaks. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476461</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::OMGetRenderTargetsAndUnorderedAccessViews([In] unsigned int NumRTVs,[Out, Buffer, Optional] ID3D11RenderTargetView** ppRenderTargetViews,[Out, Optional] ID3D11DepthStencilView** ppDepthStencilView,[In] unsigned int UAVStartSlot,[In] unsigned int NumUAVs,[Out, Buffer, Optional] ID3D11UnorderedAccessView** ppUnorderedAccessViews)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::OMGetRenderTargetsAndUnorderedAccessViews</unmanaged-short>
        internal unsafe void GetRenderTargetsAndUnorderedAccessViews(System.Int32 numRTVs, SharpDX.Direct3D11.RenderTargetView[] renderTargetViewsOut, out SharpDX.Direct3D11.DepthStencilView depthStencilViewOut, System.Int32 uAVStartSlot, System.Int32 numUAVs, SharpDX.Direct3D11.UnorderedAccessView[] unorderedAccessViewsOut)
        {
            System.IntPtr*renderTargetViewsOut_;
            renderTargetViewsOut_ = (System.IntPtr*)0;
            if (renderTargetViewsOut != null)
            {
                System.IntPtr*_renderTargetViewsOut = stackalloc System.IntPtr[renderTargetViewsOut.Length];
                renderTargetViewsOut_ = _renderTargetViewsOut;
            }

            System.IntPtr depthStencilViewOut_ = System.IntPtr.Zero;
            System.IntPtr*unorderedAccessViewsOut_;
            unorderedAccessViewsOut_ = (System.IntPtr*)0;
            if (unorderedAccessViewsOut != null)
            {
                System.IntPtr*_unorderedAccessViewsOut = stackalloc System.IntPtr[unorderedAccessViewsOut.Length];
                unorderedAccessViewsOut_ = _unorderedAccessViewsOut;
            }

            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, numRTVs, (void *)renderTargetViewsOut_, &depthStencilViewOut_, uAVStartSlot, numUAVs, (void *)unorderedAccessViewsOut_, (*(void ***)this._nativePointer)[90]);
            if (renderTargetViewsOut != null)
                for (int i = 0; i < renderTargetViewsOut.Length; ++i)
                    if ((renderTargetViewsOut_)[i] != System.IntPtr.Zero)
                        renderTargetViewsOut[i] = new SharpDX.Direct3D11.RenderTargetView((renderTargetViewsOut_)[i]);
                    else
                        renderTargetViewsOut[i] = null;
            if (depthStencilViewOut_ != System.IntPtr.Zero)
                depthStencilViewOut = new SharpDX.Direct3D11.DepthStencilView(depthStencilViewOut_);
            else
                depthStencilViewOut = null;
            if (unorderedAccessViewsOut != null)
                for (int i = 0; i < unorderedAccessViewsOut.Length; ++i)
                    if ((unorderedAccessViewsOut_)[i] != System.IntPtr.Zero)
                        unorderedAccessViewsOut[i] = new SharpDX.Direct3D11.UnorderedAccessView((unorderedAccessViewsOut_)[i]);
                    else
                        unorderedAccessViewsOut[i] = null;
        }

        /// <summary>
        /// <p>Set the blend state of the output-merger stage.</p>
        /// </summary>
        /// <param name = "blendStateOut"><dd>  <p>Pointer to a blend-state interface (see <strong><see cref = "SharpDX.Direct3D11.BlendState"/></strong>). Pass <strong><c>null</c></strong> for a default blend state. For more info about default blend state, see Remarks.</p> </dd></param>
        /// <param name = "blendFactor"><dd>  <p>Array of blend factors, one for each RGBA component. The blend factors modulate values for the pixel shader, render target, or both. If you created  the blend-state object with <strong>D3D11_BLEND_BLEND_FACTOR</strong> or <strong>D3D11_BLEND_INV_BLEND_FACTOR</strong>, the blending stage uses the non-<c>null</c> array of blend factors. If you didn't create the blend-state object with <strong>D3D11_BLEND_BLEND_FACTOR</strong> or <strong>D3D11_BLEND_INV_BLEND_FACTOR</strong>, the blending stage does not use the non-<c>null</c> array of blend factors; the runtime stores the blend factors, and you can later call <strong>ID3D11DeviceContext::OMGetBlendState</strong> to retrieve the blend factors. If you pass <strong><c>null</c></strong>, the runtime uses or stores a blend factor equal to { 1, 1, 1, 1 }.</p> </dd></param>
        /// <param name = "sampleMaskRef"><dd>  <p>32-bit sample coverage. The default value is 0xffffffff. See remarks.</p> </dd></param>
        /// <remarks>
        /// <p>Blend state is used by the output-merger stage to determine how to blend together two RGB pixel values and two alpha values. The two RGB pixel values and two alpha values are the RGB pixel value and alpha value that the pixel shader outputs and the RGB pixel value and alpha value already in the output render target. The <strong>blend option</strong> controls the data source that the blending stage uses to modulate values for the pixel shader, render target, or both. The <strong>blend operation</strong> controls how the blending stage mathematically combines these modulated values.</p><p>To create a blend-state interface, call <strong>ID3D11Device::CreateBlendState</strong>.</p><p>Passing in <strong><c>null</c></strong> for the blend-state interface indicates to the runtime to set a default blending state.  The following table indicates the default blending parameters.</p><table> <tr><th>State</th><th>Default Value</th></tr> <tr><td>AlphaToCoverageEnable</td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td>IndependentBlendEnable</td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td>RenderTarget[0].BlendEnable</td><td><strong><see cref = "SharpDX.Result.False"/></strong></td></tr> <tr><td>RenderTarget[0].SrcBlend</td><td>D3D11_BLEND_ONE</td></tr> <tr><td>RenderTarget[0].DestBlend</td><td>D3D11_BLEND_ZERO</td></tr> <tr><td>RenderTarget[0].BlendOp</td><td>D3D11_BLEND_OP_ADD</td></tr> <tr><td>RenderTarget[0].SrcBlendAlpha</td><td>D3D11_BLEND_ONE</td></tr> <tr><td>RenderTarget[0].DestBlendAlpha</td><td>D3D11_BLEND_ZERO</td></tr> <tr><td>RenderTarget[0].BlendOpAlpha</td><td>D3D11_BLEND_OP_ADD</td></tr> <tr><td>RenderTarget[0].RenderTargetWriteMask</td><td>D3D11_COLOR_WRITE_ENABLE_ALL</td></tr> </table><p>?</p><p>A sample mask determines which samples get updated in all the active render targets. The mapping of bits in a sample mask to samples in a multisample render target is the responsibility of an individual application. A sample mask is always applied; it is independent of whether multisampling is enabled, and does not depend on whether an application uses multisample render targets.</p><p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p>
        /// </remarks>
        /// <doc-id>ff476462</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::OMGetBlendState([Out, Optional] ID3D11BlendState** ppBlendState,[Out, Optional] SHARPDX_COLOR4* BlendFactor,[Out, Optional] unsigned int* pSampleMask)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::OMGetBlendState</unmanaged-short>
        internal unsafe void GetBlendState(out SharpDX.Direct3D11.BlendState blendStateOut, out SharpDX.Mathematics.Interop.RawColor4 blendFactor, out System.Int32 sampleMaskRef)
        {
            System.IntPtr blendStateOut_ = System.IntPtr.Zero;
            blendFactor = default (SharpDX.Mathematics.Interop.RawColor4);
            fixed (void *sampleMaskRef_ = &sampleMaskRef)
                fixed (void *blendFactor_ = &blendFactor)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, &blendStateOut_, blendFactor_, sampleMaskRef_, (*(void ***)this._nativePointer)[91]);
            if (blendStateOut_ != System.IntPtr.Zero)
                blendStateOut = new SharpDX.Direct3D11.BlendState(blendStateOut_);
            else
                blendStateOut = null;
        }

        /// <summary>
        /// <p>Gets the depth-stencil state of the output-merger stage.</p>
        /// </summary>
        /// <param name = "depthStencilStateOut"><dd>  <p> Address of a reference to a depth-stencil state interface (see <strong><see cref = "SharpDX.Direct3D11.DepthStencilState"/></strong>) to be filled with information from the device. </p> </dd></param>
        /// <param name = "stencilRefRef"><dd>  <p>Pointer to the stencil reference value used in the depth-stencil test.</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476459</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::OMGetDepthStencilState([Out, Optional] ID3D11DepthStencilState** ppDepthStencilState,[Out, Optional] unsigned int* pStencilRef)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::OMGetDepthStencilState</unmanaged-short>
        internal unsafe void GetDepthStencilState(out SharpDX.Direct3D11.DepthStencilState depthStencilStateOut, out System.Int32 stencilRefRef)
        {
            System.IntPtr depthStencilStateOut_ = System.IntPtr.Zero;
            fixed (void *stencilRefRef_ = &stencilRefRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, &depthStencilStateOut_, stencilRefRef_, (*(void ***)this._nativePointer)[92]);
            if (depthStencilStateOut_ != System.IntPtr.Zero)
                depthStencilStateOut = new SharpDX.Direct3D11.DepthStencilState(depthStencilStateOut_);
            else
                depthStencilStateOut = null;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("ea82e40d-51dc-4f33-93d4-db7c9125ae8c")]
    public partial class PixelShader : SharpDX.Direct3D11.DeviceChild
    {
        public PixelShader(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator PixelShader(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new PixelShader(nativePtr);
    }

    [System.Runtime.InteropServices.GuidAttribute("c0bfa96c-e089-44fb-8eaf-26f8796190da")]
    public partial class PixelShaderStage : CommonShaderStage<PixelShader>
    {
        public PixelShaderStage(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator PixelShaderStage(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new PixelShaderStage(nativePtr);
                ///<summary>Constant PixelCenterFractionalComponent</summary>
        ///<unmanaged>D3D11_PS_PIXEL_CENTER_FRACTIONAL_COMPONENT</unmanaged>
        public const float PixelCenterFractionalComponent = unchecked ((float)0.5F);
                ///<summary>Constant FrontfacingDefaultValue</summary>
        ///<unmanaged>D3D11_PS_FRONTFACING_DEFAULT_VALUE</unmanaged>
        public const int FrontfacingDefaultValue = unchecked ((int)4294967295U);
                ///<summary>Constant FrontfacingFalseValue</summary>
        ///<unmanaged>D3D11_PS_FRONTFACING_FALSE_VALUE</unmanaged>
        public const int FrontfacingFalseValue = unchecked ((int)0);
                ///<summary>Constant FrontfacingTrueValue</summary>
        ///<unmanaged>D3D11_PS_FRONTFACING_TRUE_VALUE</unmanaged>
        public const int FrontfacingTrueValue = unchecked ((int)4294967295U);
                ///<summary>Constant InputRegisterComponents</summary>
        ///<unmanaged>D3D11_PS_INPUT_REGISTER_COMPONENTS</unmanaged>
        public const int InputRegisterComponents = unchecked ((int)4);
                ///<summary>Constant InputRegisterComponentBitCount</summary>
        ///<unmanaged>D3D11_PS_INPUT_REGISTER_COMPONENT_BIT_COUNT</unmanaged>
        public const int InputRegisterComponentBitCount = unchecked ((int)32);
                ///<summary>Constant InputRegisterCount</summary>
        ///<unmanaged>D3D11_PS_INPUT_REGISTER_COUNT</unmanaged>
        public const int InputRegisterCount = unchecked ((int)32);
                ///<summary>Constant InputRegisterReadsPerInst</summary>
        ///<unmanaged>D3D11_PS_INPUT_REGISTER_READS_PER_INST</unmanaged>
        public const int InputRegisterReadsPerInst = unchecked ((int)2);
                ///<summary>Constant InputRegisterReadPorts</summary>
        ///<unmanaged>D3D11_PS_INPUT_REGISTER_READ_PORTS</unmanaged>
        public const int InputRegisterReadPorts = unchecked ((int)1);
                ///<summary>Constant LegacyPixelCenterFractionalComponent</summary>
        ///<unmanaged>D3D11_PS_LEGACY_PIXEL_CENTER_FRACTIONAL_COMPONENT</unmanaged>
        public const int LegacyPixelCenterFractionalComponent = unchecked ((int)0.0F);
                ///<summary>Constant OutputDepthRegisterComponents</summary>
        ///<unmanaged>D3D11_PS_OUTPUT_DEPTH_REGISTER_COMPONENTS</unmanaged>
        public const int OutputDepthRegisterComponents = unchecked ((int)1);
                ///<summary>Constant OutputDepthRegisterComponentBitCount</summary>
        ///<unmanaged>D3D11_PS_OUTPUT_DEPTH_REGISTER_COMPONENT_BIT_COUNT</unmanaged>
        public const int OutputDepthRegisterComponentBitCount = unchecked ((int)32);
                ///<summary>Constant OutputDepthRegisterCount</summary>
        ///<unmanaged>D3D11_PS_OUTPUT_DEPTH_REGISTER_COUNT</unmanaged>
        public const int OutputDepthRegisterCount = unchecked ((int)1);
                ///<summary>Constant OutputMaskRegisterComponents</summary>
        ///<unmanaged>D3D11_PS_OUTPUT_MASK_REGISTER_COMPONENTS</unmanaged>
        public const int OutputMaskRegisterComponents = unchecked ((int)1);
                ///<summary>Constant OutputMaskRegisterComponentBitCount</summary>
        ///<unmanaged>D3D11_PS_OUTPUT_MASK_REGISTER_COMPONENT_BIT_COUNT</unmanaged>
        public const int OutputMaskRegisterComponentBitCount = unchecked ((int)32);
                ///<summary>Constant OutputMaskRegisterCount</summary>
        ///<unmanaged>D3D11_PS_OUTPUT_MASK_REGISTER_COUNT</unmanaged>
        public const int OutputMaskRegisterCount = unchecked ((int)1);
                ///<summary>Constant OutputRegisterComponents</summary>
        ///<unmanaged>D3D11_PS_OUTPUT_REGISTER_COMPONENTS</unmanaged>
        public const int OutputRegisterComponents = unchecked ((int)4);
                ///<summary>Constant OutputRegisterComponentBitCount</summary>
        ///<unmanaged>D3D11_PS_OUTPUT_REGISTER_COMPONENT_BIT_COUNT</unmanaged>
        public const int OutputRegisterComponentBitCount = unchecked ((int)32);
                ///<summary>Constant OutputRegisterCount</summary>
        ///<unmanaged>D3D11_PS_OUTPUT_REGISTER_COUNT</unmanaged>
        public const int OutputRegisterCount = unchecked ((int)8);
        /// <summary>
        /// <p>Bind an array of shader resources to the pixel shader stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin setting shader resources to (ranges from 0 to <see cref = "InputResourceSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numViews"><dd>  <p>Number of shader resources to set. Up to a maximum of 128 slots are available for shader resources (ranges from 0 to <see cref = "InputResourceSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "shaderResourceViewsOut"><dd>  <p>Array of <strong>shader resource view</strong> interfaces to set to the device.</p> </dd></param>
        /// <remarks>
        /// <p>If an overlapping resource view is already bound to an output slot, such as a rendertarget, then this API will fill the destination shader resource slot with <strong><c>null</c></strong>.</p><p>For information about creating shader-resource views, see <strong>ID3D11Device::CreateShaderResourceView</strong>.</p><p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p>
        /// </remarks>
        /// <doc-id>ff476473</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::PSSetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[In, Buffer, Optional] const ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::PSSetShaderResources</unmanaged-short>
        internal override unsafe void SetShaderResources(System.Int32 startSlot, System.Int32 numViews, System.IntPtr shaderResourceViewsOut)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numViews, (void *)shaderResourceViewsOut, (*(void ***)this._nativePointer)[8]);
        }

        /// <summary>
        /// <p>Sets a pixel shader to the device.</p>
        /// </summary>
        /// <param name = "pixelShaderRef"><dd>  <p> Pointer to a pixel shader (see <strong><see cref = "SharpDX.Direct3D11.PixelShader"/></strong>). Passing in <strong><c>null</c></strong> disables the shader for this pipeline stage. </p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p> A reference to an array of class-instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <strong><c>null</c></strong> if the shader does not use any interfaces. </p> </dd></param>
        /// <param name = "numClassInstances"><dd>  <p>The number of class-instance interfaces in the array.</p> </dd></param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p>The maximum number of instances a shader can have is 256.</p><p> Set ppClassInstances to <strong><c>null</c></strong> if no interfaces are used in the shader. If it is not <strong><c>null</c></strong>, the number of class instances must match the number of interfaces used in the shader. Furthermore, each interface reference must have a corresponding class instance or the assigned shader will be disabled. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476472</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::PSSetShader([In, Optional] ID3D11PixelShader* pPixelShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[In] unsigned int NumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::PSSetShader</unmanaged-short>
        internal override unsafe void SetShader(SharpDX.Direct3D11.PixelShader pixelShaderRef, SharpDX.Direct3D11.ClassInstance[] classInstancesOut, System.Int32 numClassInstances)
        {
            System.IntPtr pixelShaderRef_ = System.IntPtr.Zero;
            System.IntPtr*classInstancesOut_;
            classInstancesOut_ = (System.IntPtr*)0;
            if (classInstancesOut != null)
            {
                System.IntPtr*_classInstancesOut = stackalloc System.IntPtr[classInstancesOut.Length];
                classInstancesOut_ = _classInstancesOut;
            }

            pixelShaderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.PixelShader>(pixelShaderRef);
            if (classInstancesOut != null)
                for (int i = 0; i < classInstancesOut.Length; ++i)
                    (classInstancesOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.ClassInstance>(classInstancesOut[i]);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)pixelShaderRef_, (void *)classInstancesOut_, numClassInstances, (*(void ***)this._nativePointer)[9]);
        }

        /// <summary>
        /// <p>Set an array of sampler states to the pixel shader pipeline stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin setting samplers to (ranges from 0 to <see cref = "SamplerSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numSamplers"><dd>  <p>Number of samplers in the array. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to <see cref = "SamplerSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "samplersOut"><dd>  <p>Pointer to an array of sampler-state interfaces (see <strong><see cref = "SharpDX.Direct3D11.SamplerState"/></strong>). See Remarks.</p> </dd></param>
        /// <remarks>
        /// <p>Any sampler may be set to <strong><c>null</c></strong>; this invokes the default state, which is defined to be the following.</p><table> <tr><th>State</th><th>Default Value</th></tr> <tr><td>Filter</td><td>D3D11_FILTER_MIN_MAG_MIP_LINEAR</td></tr> <tr><td>AddressU</td><td>D3D11_TEXTURE_ADDRESS_CLAMP</td></tr> <tr><td>AddressV</td><td>D3D11_TEXTURE_ADDRESS_CLAMP</td></tr> <tr><td>AddressW</td><td>D3D11_TEXTURE_ADDRESS_CLAMP</td></tr> <tr><td>MipLODBias</td><td>0</td></tr> <tr><td>MaxAnisotropy</td><td>1</td></tr> <tr><td>ComparisonFunc</td><td>D3D11_COMPARISON_NEVER</td></tr> <tr><td>BorderColor[0]</td><td>1.0f</td></tr> <tr><td>BorderColor[1]</td><td>1.0f</td></tr> <tr><td>BorderColor[2]</td><td>1.0f</td></tr> <tr><td>BorderColor[3]</td><td>1.0f</td></tr> <tr><td>MinLOD</td><td>-FLT_MAX</td></tr> <tr><td>MaxLOD</td><td>FLT_MAX</td></tr> </table><p>?</p><p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p>
        /// </remarks>
        /// <doc-id>ff476471</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::PSSetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[In, Buffer, Optional] const ID3D11SamplerState** ppSamplers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::PSSetSamplers</unmanaged-short>
        internal override unsafe void SetSamplers(System.Int32 startSlot, System.Int32 numSamplers, System.IntPtr samplersOut)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numSamplers, (void *)samplersOut, (*(void ***)this._nativePointer)[10]);
        }

        /// <summary>
        /// <p> Sets the constant buffers used by the pixel shader pipeline stage. </p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p> Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to <strong><see cref = "ConstantBufferApiSlotCount"/></strong> - 1). </p> </dd></param>
        /// <param name = "numBuffers"><dd>  <p> Number of buffers to set (ranges from 0 to <strong><see cref = "ConstantBufferApiSlotCount"/></strong> - <em>StartSlot</em>). </p> </dd></param>
        /// <param name = "constantBuffersOut"><dd>  <p> Array of constant buffers (see <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>) being given to the device. </p> </dd></param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p> The Direct3D 11.1 runtime, which is available on Windows?8 and later operating systems, can bind a larger number of <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong> resources to the shader than the maximum constant buffer size that is supported by shaders (4096 constants ? 4*32-bit components each). When you bind such a large buffer, the shader can access only the first 4096 4*32-bit component constants in the buffer, as if 4096 constants is the full size of the buffer. </p><p> To enable the shader to access other parts of the buffer, call <strong>PSSetConstantBuffers1</strong> instead of <strong>PSSetConstantBuffers</strong>. <strong>PSSetConstantBuffers1</strong> has additional parameters <em>pFirstConstant</em> and <em>pNumConstants</em>. </p>
        /// </remarks>
        /// <doc-id>ff476470</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::PSSetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::PSSetConstantBuffers</unmanaged-short>
        internal override unsafe void SetConstantBuffers(System.Int32 startSlot, System.Int32 numBuffers, System.IntPtr constantBuffersOut)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut, (*(void ***)this._nativePointer)[16]);
        }

        /// <summary>
        /// <p>Bind an array of shader resources to the pixel shader stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin setting shader resources to (ranges from 0 to <see cref = "InputResourceSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numViews"><dd>  <p>Number of shader resources to set. Up to a maximum of 128 slots are available for shader resources (ranges from 0 to <see cref = "InputResourceSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "shaderResourceViewsOut"><dd>  <p>Array of <strong>shader resource view</strong> interfaces to set to the device.</p> </dd></param>
        /// <remarks>
        /// <p>If an overlapping resource view is already bound to an output slot, such as a rendertarget, then this API will fill the destination shader resource slot with <strong><c>null</c></strong>.</p><p>For information about creating shader-resource views, see <strong>ID3D11Device::CreateShaderResourceView</strong>.</p><p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p>
        /// </remarks>
        /// <doc-id>ff476473</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::PSGetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[Out, Buffer, Optional] ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::PSGetShaderResources</unmanaged-short>
        internal override unsafe void GetShaderResources(System.Int32 startSlot, System.Int32 numViews, SharpDX.Direct3D11.ShaderResourceView[] shaderResourceViewsOut)
        {
            System.IntPtr*shaderResourceViewsOut_;
            shaderResourceViewsOut_ = (System.IntPtr*)0;
            if (shaderResourceViewsOut != null)
            {
                System.IntPtr*_shaderResourceViewsOut = stackalloc System.IntPtr[shaderResourceViewsOut.Length];
                shaderResourceViewsOut_ = _shaderResourceViewsOut;
            }

            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numViews, (void *)shaderResourceViewsOut_, (*(void ***)this._nativePointer)[73]);
            if (shaderResourceViewsOut != null)
                for (int i = 0; i < shaderResourceViewsOut.Length; ++i)
                    if ((shaderResourceViewsOut_)[i] != System.IntPtr.Zero)
                        shaderResourceViewsOut[i] = new SharpDX.Direct3D11.ShaderResourceView((shaderResourceViewsOut_)[i]);
                    else
                        shaderResourceViewsOut[i] = null;
        }

        /// <summary>
        /// <p> Get the pixel shader currently set on the device. </p>
        /// </summary>
        /// <param name = "pixelShaderOut"><dd>  <p> Address of a reference to a pixel shader (see <strong><see cref = "SharpDX.Direct3D11.PixelShader"/></strong>) to be returned by the method. </p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p> Pointer to an array of class instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>). </p> </dd></param>
        /// <param name = "numClassInstancesRef"><dd>  <p> The number of class-instance elements in the array. </p> </dd></param>
        /// <remarks>
        /// <p> Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed, to avoid memory leaks. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476468</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::PSGetShader([Out, Optional] ID3D11PixelShader** ppPixelShader,[Out, Buffer, Optional] ID3D11ClassInstance** ppClassInstances,[InOut] unsigned int* pNumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::PSGetShader</unmanaged-short>
        internal override unsafe void GetShader(out SharpDX.Direct3D11.PixelShader pixelShaderOut, SharpDX.Direct3D11.ClassInstance[] classInstancesOut, ref System.Int32 numClassInstancesRef)
        {
            System.IntPtr pixelShaderOut_ = System.IntPtr.Zero;
            System.IntPtr*classInstancesOut_;
            classInstancesOut_ = (System.IntPtr*)0;
            if (classInstancesOut != null)
            {
                System.IntPtr*_classInstancesOut = stackalloc System.IntPtr[classInstancesOut.Length];
                classInstancesOut_ = _classInstancesOut;
            }

            fixed (void *numClassInstancesRef_ = &numClassInstancesRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, &pixelShaderOut_, (void *)classInstancesOut_, numClassInstancesRef_, (*(void ***)this._nativePointer)[74]);
            if (pixelShaderOut_ != System.IntPtr.Zero)
                pixelShaderOut = new SharpDX.Direct3D11.PixelShader(pixelShaderOut_);
            else
                pixelShaderOut = null;
            if (classInstancesOut != null)
                for (int i = 0; i < classInstancesOut.Length; ++i)
                    if ((classInstancesOut_)[i] != System.IntPtr.Zero)
                        classInstancesOut[i] = new SharpDX.Direct3D11.ClassInstance((classInstancesOut_)[i]);
                    else
                        classInstancesOut[i] = null;
        }

        /// <summary>
        /// <p>Get an array of sampler states from the pixel shader pipeline stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into a zero-based array to begin getting samplers from (ranges from 0 to <see cref = "SamplerSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numSamplers"><dd>  <p>Number of samplers to get from a device context. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to <see cref = "SamplerSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "samplersOut"><dd>  <p>Arry of sampler-state interface references (see <strong><see cref = "SharpDX.Direct3D11.SamplerState"/></strong>) to be returned by the device.</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476467</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::PSGetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[Out, Buffer, Optional] ID3D11SamplerState** ppSamplers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::PSGetSamplers</unmanaged-short>
        internal override unsafe void GetSamplers(System.Int32 startSlot, System.Int32 numSamplers, SharpDX.Direct3D11.SamplerState[] samplersOut)
        {
            System.IntPtr*samplersOut_;
            samplersOut_ = (System.IntPtr*)0;
            if (samplersOut != null)
            {
                System.IntPtr*_samplersOut = stackalloc System.IntPtr[samplersOut.Length];
                samplersOut_ = _samplersOut;
            }

            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numSamplers, (void *)samplersOut_, (*(void ***)this._nativePointer)[75]);
            if (samplersOut != null)
                for (int i = 0; i < samplersOut.Length; ++i)
                    if ((samplersOut_)[i] != System.IntPtr.Zero)
                        samplersOut[i] = new SharpDX.Direct3D11.SamplerState((samplersOut_)[i]);
                    else
                        samplersOut[i] = null;
        }

        /// <summary>
        /// <p>Get the constant buffers used by the pixel shader pipeline stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd>  <p>Number of buffers to retrieve (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd>  <p>Array of constant buffer interface references (see <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>) to be returned by the method.</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476466</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::PSGetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[Out, Buffer, Optional] ID3D11Buffer** ppConstantBuffers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::PSGetConstantBuffers</unmanaged-short>
        internal override unsafe void GetConstantBuffers(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.Direct3D11.Buffer[] constantBuffersOut)
        {
            System.IntPtr*constantBuffersOut_;
            constantBuffersOut_ = (System.IntPtr*)0;
            if (constantBuffersOut != null)
            {
                System.IntPtr*_constantBuffersOut = stackalloc System.IntPtr[constantBuffersOut.Length];
                constantBuffersOut_ = _constantBuffersOut;
            }

            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut_, (*(void ***)this._nativePointer)[77]);
            if (constantBuffersOut != null)
                for (int i = 0; i < constantBuffersOut.Length; ++i)
                    if ((constantBuffersOut_)[i] != System.IntPtr.Zero)
                        constantBuffersOut[i] = new SharpDX.Direct3D11.Buffer((constantBuffersOut_)[i]);
                    else
                        constantBuffersOut[i] = null;
        }

        /// <summary>
        /// <p>Sets a pixel shader to the device.</p>
        /// </summary>
        /// <param name = "pixelShaderRef"><dd>  <p> Pointer to a pixel shader (see <strong><see cref = "SharpDX.Direct3D11.PixelShader"/></strong>). Passing in <strong><c>null</c></strong> disables the shader for this pipeline stage. </p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p> A reference to an array of class-instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <strong><c>null</c></strong> if the shader does not use any interfaces. </p> </dd></param>
        /// <param name = "numClassInstances"><dd>  <p>The number of class-instance interfaces in the array.</p> </dd></param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p>The maximum number of instances a shader can have is 256.</p><p> Set ppClassInstances to <strong><c>null</c></strong> if no interfaces are used in the shader. If it is not <strong><c>null</c></strong>, the number of class instances must match the number of interfaces used in the shader. Furthermore, each interface reference must have a corresponding class instance or the assigned shader will be disabled. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476472</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::PSSetShader([In, Optional] ID3D11PixelShader* pPixelShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[In] unsigned int NumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::PSSetShader</unmanaged-short>
        internal override unsafe void SetShader(SharpDX.Direct3D11.PixelShader pixelShaderRef, SharpDX.ComArray<SharpDX.Direct3D11.ClassInstance> classInstancesOut, System.Int32 numClassInstances)
        {
            System.IntPtr pixelShaderRef_ = System.IntPtr.Zero;
            pixelShaderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.PixelShader>(pixelShaderRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)pixelShaderRef_, (void *)(classInstancesOut?.NativePointer ?? System.IntPtr.Zero), numClassInstances, (*(void ***)this._nativePointer)[9]);
        }

        /// <summary>
        /// <p>Sets a pixel shader to the device.</p>
        /// </summary>
        /// <param name = "pixelShaderRef"><dd>  <p> Pointer to a pixel shader (see <strong><see cref = "SharpDX.Direct3D11.PixelShader"/></strong>). Passing in <strong><c>null</c></strong> disables the shader for this pipeline stage. </p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p> A reference to an array of class-instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <strong><c>null</c></strong> if the shader does not use any interfaces. </p> </dd></param>
        /// <param name = "numClassInstances"><dd>  <p>The number of class-instance interfaces in the array.</p> </dd></param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p>The maximum number of instances a shader can have is 256.</p><p> Set ppClassInstances to <strong><c>null</c></strong> if no interfaces are used in the shader. If it is not <strong><c>null</c></strong>, the number of class instances must match the number of interfaces used in the shader. Furthermore, each interface reference must have a corresponding class instance or the assigned shader will be disabled. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476472</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::PSSetShader([In, Optional] ID3D11PixelShader* pPixelShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[In] unsigned int NumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::PSSetShader</unmanaged-short>
        private unsafe void SetShader(System.IntPtr pixelShaderRef, System.IntPtr classInstancesOut, System.Int32 numClassInstances)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)pixelShaderRef, (void *)classInstancesOut, numClassInstances, (*(void ***)this._nativePointer)[9]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("9eb576dd-9f77-4d86-81aa-8bab5fe490e2")]
    public partial class Predicate : SharpDX.Direct3D11.Query
    {
        public Predicate(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Predicate(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Predicate(nativePtr);
    }

    [System.Runtime.InteropServices.GuidAttribute("d6c00747-87b7-425e-b84d-44d108560afd")]
    public partial class Query : SharpDX.Direct3D11.Asynchronous
    {
        public Query(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Query(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Query(nativePtr);
        /// <summary>
        /// <p>Get a query description.</p>
        /// </summary>
        /// <doc-id>ff476579</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.Direct3D11.QueryDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Get a query description.</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p>Pointer to a query description (see <strong><see cref = "SharpDX.Direct3D11.QueryDescription"/></strong>).</p> </dd></param>
        /// <doc-id>ff476579</doc-id>
        /// <unmanaged>void ID3D11Query::GetDesc([Out] D3D11_QUERY_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11Query::GetDesc</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.Direct3D11.QueryDescription descRef)
        {
            descRef = default (SharpDX.Direct3D11.QueryDescription);
            fixed (void *descRef_ = &descRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[8]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("631b4766-36dc-461d-8db6-c47e13e60916")]
    public partial class Query1 : SharpDX.Direct3D11.Query
    {
        public Query1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Query1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Query1(nativePtr);
        /// <summary>
        /// <p>Gets a query description.</p>
        /// </summary>
        /// <doc-id>dn899237</doc-id>
        /// <unmanaged>GetDesc1</unmanaged>
        /// <unmanaged-short>GetDesc1</unmanaged-short>
        public SharpDX.Direct3D11.QueryDescription1 Description1
        {
            get
            {
                GetDescription1(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets a query description.</p>
        /// </summary>
        /// <param name = "desc1Ref"><dd>  <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.QueryDescription1"/></strong> structure that receives a description of the query.</p> </dd></param>
        /// <doc-id>dn899237</doc-id>
        /// <unmanaged>void ID3D11Query1::GetDesc1([Out] D3D11_QUERY_DESC1* pDesc1)</unmanaged>
        /// <unmanaged-short>ID3D11Query1::GetDesc1</unmanaged-short>
        internal unsafe void GetDescription1(out SharpDX.Direct3D11.QueryDescription1 desc1Ref)
        {
            desc1Ref = default (SharpDX.Direct3D11.QueryDescription1);
            fixed (void *desc1Ref_ = &desc1Ref)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, desc1Ref_, (*(void ***)this._nativePointer)[9]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("c0bfa96c-e089-44fb-8eaf-26f8796190da")]
    public partial class RasterizerStage : SharpDX.CppObject
    {
        public RasterizerStage(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RasterizerStage(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RasterizerStage(nativePtr);
        /// <summary>
        /// <p>Gets or sets a reference to the data contained in a subresource, and denies the GPU access to that subresource. </p>
        /// </summary>
        /// <remarks>
        /// <p> If you call <strong>Map</strong> on a deferred context, you can only pass <strong>D3D11_MAP_WRITE_DISCARD</strong>, <strong>D3D11_MAP_WRITE_NO_OVERWRITE</strong>, or both to the <em>MapType</em> parameter. Other <strong><see cref = "SharpDX.Direct3D11.MapMode"/></strong>-typed values are not supported for a deferred context. </p><strong>Note</strong>?? The Direct3D 11.1 runtime, which is available starting with Windows?8, enables  mapping dynamic constant buffers and shader resource views (SRVs) of dynamic buffers with <strong>D3D11_MAP_WRITE_NO_OVERWRITE</strong>.  The Direct3D 11 and earlier runtimes limited mapping to vertex or index buffers. To determine if a Direct3D device supports these features, call <strong>ID3D11Device::CheckFeatureSupport</strong> with <strong>D3D11_FEATURE_D3D11_OPTIONS</strong>. <strong>CheckFeatureSupport</strong> fills members of a <strong><see cref = "SharpDX.Direct3D11.FeatureDataD3D11Options"/></strong> structure with the device's features. The relevant members here are <strong>MapNoOverwriteOnDynamicConstantBuffer</strong> and <strong>MapNoOverwriteOnDynamicBufferSRV</strong>.?<p> For info about how to use <strong>Map</strong>, see How to: Use dynamic resources. </p>
        /// </remarks>
        /// <doc-id>ff476457</doc-id>
        /// <unmanaged>RSGetState / RSSetState</unmanaged>
        /// <unmanaged-short>RSGetState</unmanaged-short>
        public SharpDX.Direct3D11.RasterizerState State
        {
            get
            {
                GetState(out var __output__);
                return __output__;
            }

            set => SetState(value);
        }

        /// <summary>
        /// <p>Set the <strong>rasterizer state</strong> for the rasterizer stage of the pipeline.</p>
        /// </summary>
        /// <param name = "rasterizerStateRef">No documentation.</param>
        /// <remarks>
        /// <p>To create a rasterizer state interface, call <strong>ID3D11Device::CreateRasterizerState</strong>.</p><p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p>
        /// </remarks>
        /// <doc-id>ff476479</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::RSSetState([In, Optional] ID3D11RasterizerState* pRasterizerState)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::RSSetState</unmanaged-short>
        internal unsafe void SetState(SharpDX.Direct3D11.RasterizerState rasterizerStateRef)
        {
            System.IntPtr rasterizerStateRef_ = System.IntPtr.Zero;
            rasterizerStateRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.RasterizerState>(rasterizerStateRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)rasterizerStateRef_, (*(void ***)this._nativePointer)[43]);
        }

        /// <summary>
        /// <p>Bind an array of viewports to the rasterizer stage of the pipeline.</p>
        /// </summary>
        /// <param name = "numViewports"><dd>  <p>Number of viewports to bind.</p> </dd></param>
        /// <param name = "viewportsRef"><dd>  <p>An array of <strong><see cref = "SharpDX.Mathematics.Interop.RawViewportF"/></strong> structures to bind to the device. See the structure page for details about how the viewport size is dependent on the device feature level which has changed between Direct3D 11 and Direct3D 10.</p> </dd></param>
        /// <remarks>
        /// <p>All viewports must be set atomically as one operation. Any viewports not defined by the call are disabled.</p><p>Which viewport to use is determined by the SV_ViewportArrayIndex semantic output by a geometry shader; if a geometry shader does not specify the semantic, Direct3D will use the first viewport in the array.</p><strong>Note</strong>??Even though you specify float values to the members of the <strong><see cref = "SharpDX.Mathematics.Interop.RawViewportF"/></strong> structure for the <em>pViewports</em> array in a call to  <strong>ID3D11DeviceContext::RSSetViewports</strong> for feature levels 9_x, <strong>RSSetViewports</strong> uses DWORDs internally. Because of this behavior, when you use a negative top left corner for the viewport, the call to  <strong>RSSetViewports</strong> for feature levels 9_x fails. This failure occurs because <strong>RSSetViewports</strong> for 9_x casts the floating point values into unsigned integers without validation, which results in integer overflow.?
        /// </remarks>
        /// <doc-id>ff476480</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::RSSetViewports([In] unsigned int NumViewports,[In, Buffer, Optional] const D3D11_VIEWPORT* pViewports)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::RSSetViewports</unmanaged-short>
        internal unsafe void SetViewports(System.Int32 numViewports, System.IntPtr viewportsRef)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, numViewports, (void *)viewportsRef, (*(void ***)this._nativePointer)[44]);
        }

        /// <summary>
        /// <p>Bind an array of scissor rectangles to the rasterizer stage.</p>
        /// </summary>
        /// <param name = "numRects"><dd>  <p>Number of scissor rectangles to bind.</p> </dd></param>
        /// <param name = "rectsRef"><dd>  <p> An array of scissor rectangles (see <strong>D3D11_RECT</strong>). </p> </dd></param>
        /// <remarks>
        /// <p>All scissor rects must be set atomically as one operation. Any scissor rects not defined by the call are disabled.</p><p> The scissor rectangles will only be used if ScissorEnable is set to true in the rasterizer state (see <strong><see cref = "SharpDX.Direct3D11.RasterizerStateDescription"/></strong>). </p><p>Which scissor rectangle to use is determined by the SV_ViewportArrayIndex semantic output by a geometry shader (see shader semantic syntax). If a geometry shader does not make use of the SV_ViewportArrayIndex semantic then Direct3D will use the first scissor rectangle in the array.</p><p> Each scissor rectangle in the array corresponds to a viewport in an array of viewports (see <strong>ID3D11DeviceContext::RSSetViewports</strong>). </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476478</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::RSSetScissorRects([In] unsigned int NumRects,[In, Buffer, Optional] const RECT* pRects)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::RSSetScissorRects</unmanaged-short>
        internal unsafe void SetScissorRects(System.Int32 numRects, System.IntPtr rectsRef)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, numRects, (void *)rectsRef, (*(void ***)this._nativePointer)[45]);
        }

        /// <summary>
        /// <p> Gets a reference to the data contained in a subresource, and denies the GPU access to that subresource. </p>
        /// </summary>
        /// <param name = "rasterizerStateOut">No documentation.</param>
        /// <remarks>
        /// <p> If you call <strong>Map</strong> on a deferred context, you can only pass <strong>D3D11_MAP_WRITE_DISCARD</strong>, <strong>D3D11_MAP_WRITE_NO_OVERWRITE</strong>, or both to the <em>MapType</em> parameter. Other <strong><see cref = "SharpDX.Direct3D11.MapMode"/></strong>-typed values are not supported for a deferred context. </p><strong>Note</strong>?? The Direct3D 11.1 runtime, which is available starting with Windows?8, enables  mapping dynamic constant buffers and shader resource views (SRVs) of dynamic buffers with <strong>D3D11_MAP_WRITE_NO_OVERWRITE</strong>.  The Direct3D 11 and earlier runtimes limited mapping to vertex or index buffers. To determine if a Direct3D device supports these features, call <strong>ID3D11Device::CheckFeatureSupport</strong> with <strong>D3D11_FEATURE_D3D11_OPTIONS</strong>. <strong>CheckFeatureSupport</strong> fills members of a <strong><see cref = "SharpDX.Direct3D11.FeatureDataD3D11Options"/></strong> structure with the device's features. The relevant members here are <strong>MapNoOverwriteOnDynamicConstantBuffer</strong> and <strong>MapNoOverwriteOnDynamicBufferSRV</strong>.?<p> For info about how to use <strong>Map</strong>, see How to: Use dynamic resources. </p>
        /// </remarks>
        /// <doc-id>ff476457</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::RSGetState([Out, Optional] ID3D11RasterizerState** ppRasterizerState)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::RSGetState</unmanaged-short>
        internal unsafe void GetState(out SharpDX.Direct3D11.RasterizerState rasterizerStateOut)
        {
            System.IntPtr rasterizerStateOut_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, &rasterizerStateOut_, (*(void ***)this._nativePointer)[94]);
            if (rasterizerStateOut_ != System.IntPtr.Zero)
                rasterizerStateOut = new SharpDX.Direct3D11.RasterizerState(rasterizerStateOut_);
            else
                rasterizerStateOut = null;
        }

        /// <summary>
        /// <p>Gets the array of viewports bound to the rasterizer stage.</p>
        /// </summary>
        /// <param name = "numViewportsRef"><dd>  <p> A reference to a variable that, on input, specifies the number of viewports (ranges from 0 to <strong>D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE</strong>) in the <em>pViewports</em> array; on output, the variable contains the actual number of viewports that are bound to the rasterizer stage. If <em>pViewports</em> is <strong><c>null</c></strong>, <strong>RSGetViewports</strong> fills the variable with the number of viewports currently bound.</p> <strong>Note</strong>?? In some versions of the Windows SDK, a debug device will raise an exception if the input value in the variable to which <em>pNumViewports</em> points is greater than <strong>D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE</strong> even if <em>pViewports</em> is <strong><c>null</c></strong>.  The regular runtime ignores the value in the variable to which <em>pNumViewports</em> points when <em>pViewports</em> is <strong><c>null</c></strong>.  This behavior of a debug device might be corrected in a future release of the Windows SDK.  ? </dd></param>
        /// <param name = "viewportsRef"><dd>  <p> An array of <strong><see cref = "SharpDX.Mathematics.Interop.RawViewportF"/></strong> structures for the viewports that are bound to the rasterizer stage. If the number of viewports (in the variable to which <em>pNumViewports</em> points) is greater than the actual number of viewports currently bound, unused elements of the array contain 0. For info about how the viewport size depends on the device feature level, which has changed between Direct3D 11 and Direct3D 10, see <strong><see cref = "SharpDX.Mathematics.Interop.RawViewportF"/></strong>. </p> </dd></param>
        /// <remarks>
        /// <p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476477</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::RSGetViewports([InOut] unsigned int* pNumViewports,[Out, Buffer, Optional] D3D11_VIEWPORT* pViewports)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::RSGetViewports</unmanaged-short>
        internal unsafe void GetViewports(ref System.Int32 numViewportsRef, System.IntPtr viewportsRef)
        {
            fixed (void *numViewportsRef_ = &numViewportsRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, numViewportsRef_, (void *)viewportsRef, (*(void ***)this._nativePointer)[95]);
        }

        /// <summary>
        /// <p>Get the array of scissor rectangles bound to the rasterizer stage.</p>
        /// </summary>
        /// <param name = "numRectsRef"><dd>  <p>The number of scissor rectangles (ranges between 0 and D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE) bound; set <em>pRects</em> to <strong><c>null</c></strong> to use <em>pNumRects</em> to see how many rectangles would be returned.</p> </dd></param>
        /// <param name = "rectsRef"><dd>  <p>An array of scissor rectangles (see <strong>D3D11_RECT</strong>). If NumRects is greater than the number of scissor rects currently bound, then unused members of the array will contain 0.</p> </dd></param>
        /// <doc-id>ff476475</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::RSGetScissorRects([InOut] unsigned int* pNumRects,[Out, Buffer, Optional] RECT* pRects)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::RSGetScissorRects</unmanaged-short>
        internal unsafe void GetScissorRects(ref System.Int32 numRectsRef, System.IntPtr rectsRef)
        {
            fixed (void *numRectsRef_ = &numRectsRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, numRectsRef_, (void *)rectsRef, (*(void ***)this._nativePointer)[96]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("9bb4ab81-ab1a-4d8f-b506-fc04200b6ee7")]
    public partial class RasterizerState : SharpDX.Direct3D11.DeviceChild
    {
        public RasterizerState(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RasterizerState(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RasterizerState(nativePtr);
        /// <summary>
        /// <p>Gets the description for rasterizer state that you used to create the rasterizer-state object.</p>
        /// </summary>
        /// <remarks>
        /// <p>You use the description for rasterizer state in a call to the <strong>ID3D11Device::CreateRasterizerState</strong> method to create the rasterizer-state object.</p>
        /// </remarks>
        /// <doc-id>ff476581</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.Direct3D11.RasterizerStateDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the description for rasterizer state that you used to create the rasterizer-state object.</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.RasterizerStateDescription"/></strong> structure that receives a description of the rasterizer state.</p> </dd></param>
        /// <remarks>
        /// <p>You use the description for rasterizer state in a call to the <strong>ID3D11Device::CreateRasterizerState</strong> method to create the rasterizer-state object.</p>
        /// </remarks>
        /// <doc-id>ff476581</doc-id>
        /// <unmanaged>void ID3D11RasterizerState::GetDesc([Out] D3D11_RASTERIZER_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11RasterizerState::GetDesc</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.Direct3D11.RasterizerStateDescription descRef)
        {
            descRef = default (SharpDX.Direct3D11.RasterizerStateDescription);
            fixed (void *descRef_ = &descRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[7]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("1217d7a6-5039-418c-b042-9cbe256afd6e")]
    public partial class RasterizerState1 : SharpDX.Direct3D11.RasterizerState
    {
        public RasterizerState1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RasterizerState1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RasterizerState1(nativePtr);
        /// <summary>
        /// <p>Gets the description for rasterizer state that you used to create the rasterizer-state object.</p>
        /// </summary>
        /// <remarks>
        /// <p>You use the description for rasterizer state in a call to the <strong>ID3D11Device1::CreateRasterizerState1</strong> method to create the rasterizer-state object.</p>
        /// </remarks>
        /// <doc-id>hh446830</doc-id>
        /// <unmanaged>GetDesc1</unmanaged>
        /// <unmanaged-short>GetDesc1</unmanaged-short>
        public SharpDX.Direct3D11.RasterizerStateDescription1 Description1
        {
            get
            {
                GetDescription1(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the description for rasterizer state that you used to create the rasterizer-state object.</p>
        /// </summary>
        /// <param name = "descRef"><dd> <p>A reference to a <strong> <see cref = "SharpDX.Direct3D11.RasterizerStateDescription1"/></strong> structure that receives a description of the rasterizer state. This rasterizer state can specify forced sample count.</p> </dd></param>
        /// <remarks>
        /// <p>You use the description for rasterizer state in a call to the <strong>ID3D11Device1::CreateRasterizerState1</strong> method to create the rasterizer-state object.</p>
        /// </remarks>
        /// <doc-id>hh446830</doc-id>
        /// <unmanaged>void ID3D11RasterizerState1::GetDesc1([Out] D3D11_RASTERIZER_DESC1* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11RasterizerState1::GetDesc1</unmanaged-short>
        internal unsafe void GetDescription1(out SharpDX.Direct3D11.RasterizerStateDescription1 descRef)
        {
            descRef = default (SharpDX.Direct3D11.RasterizerStateDescription1);
            fixed (void *descRef_ = &descRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[8]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("6fbd02fb-209f-46c4-b059-2ed15586a6ac")]
    public partial class RasterizerState2 : SharpDX.Direct3D11.RasterizerState1
    {
        public RasterizerState2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RasterizerState2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RasterizerState2(nativePtr);
        /// <summary>
        /// <p>Gets the description for rasterizer state that you used to create the rasterizer-state object.</p>
        /// </summary>
        /// <remarks>
        /// <p>You use the description for rasterizer state in a call to the <strong>ID3D11Device3::CreateRasterizerState2</strong> method to create the rasterizer-state object.</p>
        /// </remarks>
        /// <doc-id>dn899239</doc-id>
        /// <unmanaged>GetDesc2</unmanaged>
        /// <unmanaged-short>GetDesc2</unmanaged-short>
        public SharpDX.Direct3D11.RasterizerStateDescription2 Description2
        {
            get
            {
                GetDescription2(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the description for rasterizer state that you used to create the rasterizer-state object.</p>
        /// </summary>
        /// <param name = "descRef"><dd> <p> A reference to a <strong><see cref = "SharpDX.Direct3D11.RasterizerStateDescription2"/></strong> structure that receives a description of the rasterizer state. This rasterizer state can specify forced sample count and conservative rasterization mode. </p> </dd></param>
        /// <remarks>
        /// <p>You use the description for rasterizer state in a call to the <strong>ID3D11Device3::CreateRasterizerState2</strong> method to create the rasterizer-state object.</p>
        /// </remarks>
        /// <doc-id>dn899239</doc-id>
        /// <unmanaged>void ID3D11RasterizerState2::GetDesc2([Out] D3D11_RASTERIZER_DESC2* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11RasterizerState2::GetDesc2</unmanaged-short>
        internal unsafe void GetDescription2(out SharpDX.Direct3D11.RasterizerStateDescription2 descRef)
        {
            descRef = default (SharpDX.Direct3D11.RasterizerStateDescription2);
            fixed (void *descRef_ = &descRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[9]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("03916615-c644-418c-9bf4-75db5be63ca0")]
    public partial class RefDefaultTrackingOptions : SharpDX.ComObject
    {
        public RefDefaultTrackingOptions(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RefDefaultTrackingOptions(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RefDefaultTrackingOptions(nativePtr);
        /// <summary>
        /// <p> Sets graphics processing unit (GPU) debug reference default tracking options for specific resource types. </p>
        /// </summary>
        /// <param name = "resourceTypeFlags"><dd> <p> A <strong><see cref = "SharpDX.Direct3D11.ShaderTrackingResourceType"/></strong>-typed value that specifies the type of resource to track. </p> </dd></param>
        /// <param name = "options"><dd> <p>A combination of <strong>D3D11_SHADER_TRACKING_OPTIONS</strong>-typed flags that are combined by using a bitwise <strong>OR</strong> operation. The resulting value identifies tracking options. If a flag is present, the tracking option that the flag represents is set to "on"; otherwise the tracking option is set to "off."</p> </dd></param>
        /// <returns><p> This method returns one of the Direct3D 11 return codes. </p></returns>
        /// <remarks>
        /// <p> This API requires the Windows Software Development Kit (SDK) for Windows?8. </p>
        /// </remarks>
        /// <doc-id>hh446834</doc-id>
        /// <unmanaged>HRESULT ID3D11RefDefaultTrackingOptions::SetTrackingOptions([In] unsigned int ResourceTypeFlags,[In] unsigned int Options)</unmanaged>
        /// <unmanaged-short>ID3D11RefDefaultTrackingOptions::SetTrackingOptions</unmanaged-short>
        public unsafe void SetTrackingOptions(System.Int32 resourceTypeFlags, System.Int32 options)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, resourceTypeFlags, options, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("193dacdf-0db2-4c05-a55c-ef06cac56fd9")]
    public partial class RefTrackingOptions : SharpDX.ComObject
    {
        public RefTrackingOptions(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RefTrackingOptions(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RefTrackingOptions(nativePtr);
        /// <summary>
        /// <p>Sets graphics processing unit (GPU) debug reference tracking options.</p>
        /// </summary>
        /// <remarks>
        /// <p>This API requires the Windows Software Development Kit (SDK) for Windows?8.</p>
        /// </remarks>
        /// <doc-id>hh446838</doc-id>
        /// <unmanaged>SetTrackingOptions</unmanaged>
        /// <unmanaged-short>SetTrackingOptions</unmanaged-short>
        public System.Int32 TrackingOptions
        {
            set => SetTrackingOptions(value);
        }

        /// <summary>
        /// <p>Sets graphics processing unit (GPU) debug reference tracking options.</p>
        /// </summary>
        /// <param name = "uOptions"><dd> <p>A combination of <strong>D3D11_SHADER_TRACKING_OPTIONS</strong>-typed flags that are combined by using a bitwise <strong>OR</strong> operation. The resulting value identifies tracking options. If a flag is present, the tracking option that the flag represents is set to "on"; otherwise the tracking option is set to "off."</p> </dd></param>
        /// <returns><p>This method returns one of the Direct3D 11 return codes.</p></returns>
        /// <remarks>
        /// <p>This API requires the Windows Software Development Kit (SDK) for Windows?8.</p>
        /// </remarks>
        /// <doc-id>hh446838</doc-id>
        /// <unmanaged>HRESULT ID3D11RefTrackingOptions::SetTrackingOptions([In] unsigned int uOptions)</unmanaged>
        /// <unmanaged-short>ID3D11RefTrackingOptions::SetTrackingOptions</unmanaged-short>
        internal unsafe void SetTrackingOptions(System.Int32 uOptions)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, uOptions, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("dfdba067-0b8d-4865-875b-d7b4516cc164")]
    public partial class RenderTargetView : SharpDX.Direct3D11.ResourceView
    {
        public RenderTargetView(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RenderTargetView(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RenderTargetView(nativePtr);
        /// <summary>
        /// <p>Get the properties of a render target view.</p>
        /// </summary>
        /// <doc-id>ff476583</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.Direct3D11.RenderTargetViewDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Get the properties of a render target view.</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p>Pointer to the description of a render target view (see <strong><see cref = "SharpDX.Direct3D11.RenderTargetViewDescription"/></strong>).</p> </dd></param>
        /// <doc-id>ff476583</doc-id>
        /// <unmanaged>void ID3D11RenderTargetView::GetDesc([Out] D3D11_RENDER_TARGET_VIEW_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11RenderTargetView::GetDesc</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.Direct3D11.RenderTargetViewDescription descRef)
        {
            descRef = default (SharpDX.Direct3D11.RenderTargetViewDescription);
            fixed (void *descRef_ = &descRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[8]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("ffbe2e23-f011-418a-ac56-5ceed7c5b94b")]
    public partial class RenderTargetView1 : SharpDX.Direct3D11.RenderTargetView
    {
        public RenderTargetView1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RenderTargetView1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RenderTargetView1(nativePtr);
        /// <summary>
        /// <p>Gets the properties of a render-target view.</p>
        /// </summary>
        /// <doc-id>dn899241</doc-id>
        /// <unmanaged>GetDesc1</unmanaged>
        /// <unmanaged-short>GetDesc1</unmanaged-short>
        public SharpDX.Direct3D11.RenderTargetViewDescription1 Description1
        {
            get
            {
                GetDescription1(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the properties of a render-target view.</p>
        /// </summary>
        /// <param name = "desc1Ref"><dd>  <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.RenderTargetViewDescription1"/></strong> structure that receives the description of the render-target view.</p> </dd></param>
        /// <doc-id>dn899241</doc-id>
        /// <unmanaged>void ID3D11RenderTargetView1::GetDesc1([Out] D3D11_RENDER_TARGET_VIEW_DESC1* pDesc1)</unmanaged>
        /// <unmanaged-short>ID3D11RenderTargetView1::GetDesc1</unmanaged-short>
        internal unsafe void GetDescription1(out SharpDX.Direct3D11.RenderTargetViewDescription1 desc1Ref)
        {
            desc1Ref = default (SharpDX.Direct3D11.RenderTargetViewDescription1);
            fixed (void *desc1Ref_ = &desc1Ref)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, desc1Ref_, (*(void ***)this._nativePointer)[9]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("dc8e63f3-d12b-4952-b47b-5e45026a862d")]
    public partial class Resource : SharpDX.Direct3D11.DeviceChild
    {
        public Resource(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Resource(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Resource(nativePtr);
                ///<summary>Constant MaximumMipLevels</summary>
        ///<unmanaged>D3D11_REQ_MIP_LEVELS</unmanaged>
        public const int MaximumMipLevels = unchecked ((int)15);
                ///<summary>Constant ResourceSizeInMegabytes</summary>
        ///<unmanaged>D3D11_REQ_RESOURCE_SIZE_IN_MEGABYTES_EXPRESSION_A_TERM</unmanaged>
        public const int ResourceSizeInMegabytes = unchecked ((int)128);
                ///<summary>Constant MaximumTexture1DArraySize</summary>
        ///<unmanaged>D3D11_REQ_TEXTURE1D_ARRAY_AXIS_DIMENSION</unmanaged>
        public const int MaximumTexture1DArraySize = unchecked ((int)2048);
                ///<summary>Constant MaximumTexture2DArraySize</summary>
        ///<unmanaged>D3D11_REQ_TEXTURE2D_ARRAY_AXIS_DIMENSION</unmanaged>
        public const int MaximumTexture2DArraySize = unchecked ((int)2048);
                ///<summary>Constant MaximumTexture1DSize</summary>
        ///<unmanaged>D3D11_REQ_TEXTURE1D_U_DIMENSION</unmanaged>
        public const int MaximumTexture1DSize = unchecked ((int)16384);
                ///<summary>Constant MaximumTexture2DSize</summary>
        ///<unmanaged>D3D11_REQ_TEXTURE2D_U_OR_V_DIMENSION</unmanaged>
        public const int MaximumTexture2DSize = unchecked ((int)16384);
                ///<summary>Constant MaximumTexture3DSize</summary>
        ///<unmanaged>D3D11_REQ_TEXTURE3D_U_V_OR_W_DIMENSION</unmanaged>
        public const int MaximumTexture3DSize = unchecked ((int)2048);
                ///<summary>Constant MaximumTextureCubeSize</summary>
        ///<unmanaged>D3D11_REQ_TEXTURECUBE_DIMENSION</unmanaged>
        public const int MaximumTextureCubeSize = unchecked ((int)16384);
        /// <summary>
        /// <p>Get the type of the resource.</p>
        /// </summary>
        /// <remarks>
        /// <p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476586</doc-id>
        /// <unmanaged>GetType</unmanaged>
        /// <unmanaged-short>GetType</unmanaged-short>
        public SharpDX.Direct3D11.ResourceDimension Dimension
        {
            get
            {
                GetDimension(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Get or sets the eviction priority of a resource.</p>
        /// </summary>
        /// <doc-id>ff476585</doc-id>
        /// <unmanaged>GetEvictionPriority / SetEvictionPriority</unmanaged>
        /// <unmanaged-short>GetEvictionPriority</unmanaged-short>
        public System.Int32 EvictionPriority
        {
            get => GetEvictionPriority();
            set => SetEvictionPriority(value);
        }

        /// <summary>
        /// <p>Get the type of the resource.</p>
        /// </summary>
        /// <param name = "resourceDimensionRef"><dd>  <p> Pointer to the resource type (see <strong><see cref = "SharpDX.Direct3D11.ResourceDimension"/></strong>). </p> </dd></param>
        /// <remarks>
        /// <p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476586</doc-id>
        /// <unmanaged>void ID3D11Resource::GetType([Out] D3D11_RESOURCE_DIMENSION* pResourceDimension)</unmanaged>
        /// <unmanaged-short>ID3D11Resource::GetType</unmanaged-short>
        internal unsafe void GetDimension(out SharpDX.Direct3D11.ResourceDimension resourceDimensionRef)
        {
            fixed (void *resourceDimensionRef_ = &resourceDimensionRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, resourceDimensionRef_, (*(void ***)this._nativePointer)[7]);
        }

        /// <summary>
        /// <p>Set the eviction priority of a resource.</p>
        /// </summary>
        /// <param name = "evictionPriority"><dd>  <p>Eviction priority for the resource, which is one of the following values:</p> <ul> <li>DXGI_RESOURCE_PRIORITY_MINIMUM</li> <li>DXGI_RESOURCE_PRIORITY_LOW</li> <li>DXGI_RESOURCE_PRIORITY_NORMAL</li> <li>DXGI_RESOURCE_PRIORITY_HIGH</li> <li>DXGI_RESOURCE_PRIORITY_MAXIMUM</li> </ul> </dd></param>
        /// <remarks>
        /// <p>Resource priorities determine which resource to evict from video memory when the system has run out of video memory. The resource will not be lost; it will be removed from video memory and placed into system memory, or possibly placed onto the hard drive. The resource will be loaded back into video memory when it is required.</p><p>A resource that is set to the maximum priority, DXGI_RESOURCE_PRIORITY_MAXIMUM, is only evicted if there is no other way of resolving the incoming memory request. The Windows Display Driver Model (WDDM) tries to split an incoming memory request to its minimum size and evict lower-priority resources before evicting a resource with maximum priority.</p><p>Changing the priorities of resources should be done carefully. The wrong eviction priorities could be a detriment to performance rather than an improvement. </p>
        /// </remarks>
        /// <doc-id>ff476587</doc-id>
        /// <unmanaged>void ID3D11Resource::SetEvictionPriority([In] unsigned int EvictionPriority)</unmanaged>
        /// <unmanaged-short>ID3D11Resource::SetEvictionPriority</unmanaged-short>
        internal unsafe void SetEvictionPriority(System.Int32 evictionPriority)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, evictionPriority, (*(void ***)this._nativePointer)[8]);
        }

        /// <summary>
        /// <p>Get the eviction priority of a resource.</p>
        /// </summary>
        /// <returns><p>One of the following values, which specifies the eviction priority for the resource:</p><ul> <li>DXGI_RESOURCE_PRIORITY_MINIMUM</li> <li>DXGI_RESOURCE_PRIORITY_LOW</li> <li>DXGI_RESOURCE_PRIORITY_NORMAL</li> <li>DXGI_RESOURCE_PRIORITY_HIGH</li> <li>DXGI_RESOURCE_PRIORITY_MAXIMUM</li> </ul></returns>
        /// <doc-id>ff476585</doc-id>
        /// <unmanaged>unsigned int ID3D11Resource::GetEvictionPriority()</unmanaged>
        /// <unmanaged-short>ID3D11Resource::GetEvictionPriority</unmanaged-short>
        internal unsafe System.Int32 GetEvictionPriority()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[9]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("839d1216-bb2e-412b-b7f4-a9dbebe08ed1")]
    public partial class ResourceView : SharpDX.Direct3D11.DeviceChild
    {
        public ResourceView(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ResourceView(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ResourceView(nativePtr);
        /// <summary>
        /// <p>Get the resource that is accessed through this view.</p>
        /// </summary>
        /// <param name = "resourceOut"><dd>  <p>Address of a reference to the resource that is accessed through this view. (See <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong>.)</p> </dd></param>
        /// <remarks>
        /// <p>This function increments the reference count of the resource by one, so it is necessary to call <strong>Release</strong> on the returned reference when the application is done with it. Destroying (or losing) the returned reference before <strong>Release</strong> is called will result in a memory leak.</p>
        /// </remarks>
        /// <doc-id>ff476643</doc-id>
        /// <unmanaged>void ID3D11View::GetResource([Out] ID3D11Resource** ppResource)</unmanaged>
        /// <unmanaged-short>ID3D11View::GetResource</unmanaged-short>
        internal unsafe void GetResource(out System.IntPtr resourceOut)
        {
            fixed (void *resourceOut_ = &resourceOut)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, resourceOut_, (*(void ***)this._nativePointer)[7]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("da6fea51-564c-4487-9810-f0d0f9b4e3a5")]
    public partial class SamplerState : SharpDX.Direct3D11.DeviceChild
    {
        public SamplerState(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SamplerState(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SamplerState(nativePtr);
        /// <summary>
        /// <p>Gets the description for sampler state that you used to create the sampler-state object.</p>
        /// </summary>
        /// <remarks>
        /// <p>You use the description for sampler state in a call to the <strong>ID3D11Device::CreateSamplerState</strong> method to create the sampler-state object.</p>
        /// </remarks>
        /// <doc-id>ff476589</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.Direct3D11.SamplerStateDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the description for sampler state that you used to create the sampler-state object.</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.SamplerStateDescription"/></strong> structure that receives a description of the sampler state.</p> </dd></param>
        /// <remarks>
        /// <p>You use the description for sampler state in a call to the <strong>ID3D11Device::CreateSamplerState</strong> method to create the sampler-state object.</p>
        /// </remarks>
        /// <doc-id>ff476589</doc-id>
        /// <unmanaged>void ID3D11SamplerState::GetDesc([Out] D3D11_SAMPLER_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11SamplerState::GetDesc</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.Direct3D11.SamplerStateDescription descRef)
        {
            descRef = default (SharpDX.Direct3D11.SamplerStateDescription);
            fixed (void *descRef_ = &descRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[7]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("b0e06fe0-8192-4e1a-b1ca-36d7414710b2")]
    public partial class ShaderResourceView : SharpDX.Direct3D11.ResourceView
    {
        public ShaderResourceView(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ShaderResourceView(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ShaderResourceView(nativePtr);
        /// <summary>
        /// <p>Get the shader resource view's description.</p>
        /// </summary>
        /// <doc-id>ff476629</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.Direct3D11.ShaderResourceViewDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Get the shader resource view's description.</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.ShaderResourceViewDescription"/></strong> structure to be filled with data about the shader resource view.</p> </dd></param>
        /// <doc-id>ff476629</doc-id>
        /// <unmanaged>void ID3D11ShaderResourceView::GetDesc([Out] D3D11_SHADER_RESOURCE_VIEW_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11ShaderResourceView::GetDesc</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.Direct3D11.ShaderResourceViewDescription descRef)
        {
            descRef = default (SharpDX.Direct3D11.ShaderResourceViewDescription);
            fixed (void *descRef_ = &descRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[8]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("91308b87-9040-411d-8c67-c39253ce3802")]
    public partial class ShaderResourceView1 : SharpDX.Direct3D11.ShaderResourceView
    {
        public ShaderResourceView1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ShaderResourceView1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ShaderResourceView1(nativePtr);
        /// <summary>
        /// <p>Gets the shader-resource view's description.</p>
        /// </summary>
        /// <doc-id>dn899243</doc-id>
        /// <unmanaged>GetDesc1</unmanaged>
        /// <unmanaged-short>GetDesc1</unmanaged-short>
        public SharpDX.Direct3D11.ShaderResourceViewDescription1 Description1
        {
            get
            {
                GetDescription1(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the shader-resource view's description.</p>
        /// </summary>
        /// <param name = "desc1Ref"><dd>  <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.ShaderResourceViewDescription1"/></strong> structure that receives the description of the shader-resource view.</p> </dd></param>
        /// <doc-id>dn899243</doc-id>
        /// <unmanaged>void ID3D11ShaderResourceView1::GetDesc1([Out] D3D11_SHADER_RESOURCE_VIEW_DESC1* pDesc1)</unmanaged>
        /// <unmanaged-short>ID3D11ShaderResourceView1::GetDesc1</unmanaged-short>
        internal unsafe void GetDescription1(out SharpDX.Direct3D11.ShaderResourceViewDescription1 desc1Ref)
        {
            desc1Ref = default (SharpDX.Direct3D11.ShaderResourceViewDescription1);
            fixed (void *desc1Ref_ = &desc1Ref)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, desc1Ref_, (*(void ***)this._nativePointer)[9]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("c0bfa96c-e089-44fb-8eaf-26f8796190da")]
    public partial class StreamOutputStage : SharpDX.CppObject
    {
        public StreamOutputStage(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator StreamOutputStage(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new StreamOutputStage(nativePtr);
        /// <summary>
        /// <p>Set the target output buffers for the stream-output stage of the pipeline.</p>
        /// </summary>
        /// <param name = "numBuffers"><dd>  <p> The number of buffer to bind to the device. A maximum of four output buffers can be set. If less than four are defined by the call, the remaining buffer slots are set to <strong><c>null</c></strong>. See Remarks. </p> </dd></param>
        /// <param name = "sOTargetsOut"><dd>  <p> The array of output buffers (see <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>) to bind to the device. The buffers must have been created with the <strong>D3D11_BIND_STREAM_OUTPUT</strong> flag. </p> </dd></param>
        /// <param name = "offsetsRef"><dd>  <p> Array of offsets to the output buffers from <em>ppSOTargets</em>, one offset for each buffer. The offset values must be in bytes. </p> </dd></param>
        /// <remarks>
        /// <p>An offset of -1 will cause the stream output buffer to be appended, continuing after the last location written to the buffer in a previous stream output pass.</p><p> Calling this method using a buffer that is currently bound for writing will effectively bind <strong><c>null</c></strong> instead because a buffer cannot be bound as both an input and an output at the same time. </p><p>The debug layer will generate a warning whenever a resource is prevented from being bound simultaneously as an input and an output, but this will not prevent invalid data from being used by the runtime.</p><p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476484</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::SOSetTargets([In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppSOTargets,[In, Buffer, Optional] const unsigned int* pOffsets)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::SOSetTargets</unmanaged-short>
        internal unsafe void SetTargets(System.Int32 numBuffers, System.IntPtr sOTargetsOut, System.IntPtr offsetsRef)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, numBuffers, (void *)sOTargetsOut, (void *)offsetsRef, (*(void ***)this._nativePointer)[37]);
        }

        /// <summary>
        /// <p>Get the target output buffers for the stream-output stage of the pipeline.</p>
        /// </summary>
        /// <param name = "numBuffers"><dd>  <p>Number of buffers to get.</p> </dd></param>
        /// <param name = "sOTargetsOut"><dd>  <p> An array of output buffers (see <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>) to be retrieved from the device. </p> </dd></param>
        /// <remarks>
        /// <p>A maximum of four output buffers can be retrieved.</p><p> The offsets to the output buffers pointed to in the returned <em>ppSOTargets</em> array may be assumed to be -1 (append), as defined for use in <strong>ID3D11DeviceContext::SOSetTargets</strong>. </p><p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476483</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::SOGetTargets([In] unsigned int NumBuffers,[Out, Buffer, Optional] ID3D11Buffer** ppSOTargets)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::SOGetTargets</unmanaged-short>
        internal unsafe void GetTargets(System.Int32 numBuffers, SharpDX.Direct3D11.Buffer[] sOTargetsOut)
        {
            System.IntPtr*sOTargetsOut_;
            sOTargetsOut_ = (System.IntPtr*)0;
            if (sOTargetsOut != null)
            {
                System.IntPtr*_sOTargetsOut = stackalloc System.IntPtr[sOTargetsOut.Length];
                sOTargetsOut_ = _sOTargetsOut;
            }

            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, numBuffers, (void *)sOTargetsOut_, (*(void ***)this._nativePointer)[93]);
            if (sOTargetsOut != null)
                for (int i = 0; i < sOTargetsOut.Length; ++i)
                    if ((sOTargetsOut_)[i] != System.IntPtr.Zero)
                        sOTargetsOut[i] = new SharpDX.Direct3D11.Buffer((sOTargetsOut_)[i]);
                    else
                        sOTargetsOut[i] = null;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("f8fb5c27-c6b3-4f75-a4c8-439af2ef564c")]
    public partial class Texture1D : SharpDX.Direct3D11.Resource
    {
        public Texture1D(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Texture1D(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Texture1D(nativePtr);
        /// <summary>
        /// <p>Get the properties of the texture resource.</p>
        /// </summary>
        /// <doc-id>ff476634</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.Direct3D11.Texture1DDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Get the properties of the texture resource.</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p>Pointer to a resource description (see <strong><see cref = "SharpDX.Direct3D11.Texture1DDescription"/></strong>).</p> </dd></param>
        /// <doc-id>ff476634</doc-id>
        /// <unmanaged>void ID3D11Texture1D::GetDesc([Out] D3D11_TEXTURE1D_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11Texture1D::GetDesc</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.Direct3D11.Texture1DDescription descRef)
        {
            descRef = default (SharpDX.Direct3D11.Texture1DDescription);
            fixed (void *descRef_ = &descRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[10]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("6f15aaf2-d208-4e89-9ab4-489535d34f9c")]
    public partial class Texture2D : SharpDX.Direct3D11.Resource
    {
        public Texture2D(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Texture2D(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Texture2D(nativePtr);
        /// <summary>
        /// <p>Get the properties of the texture resource.</p>
        /// </summary>
        /// <doc-id>ff476636</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.Direct3D11.Texture2DDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Get the properties of the texture resource.</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p>Pointer to a resource description (see <strong><see cref = "SharpDX.Direct3D11.Texture2DDescription"/></strong>).</p> </dd></param>
        /// <doc-id>ff476636</doc-id>
        /// <unmanaged>void ID3D11Texture2D::GetDesc([Out] D3D11_TEXTURE2D_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11Texture2D::GetDesc</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.Direct3D11.Texture2DDescription descRef)
        {
            descRef = default (SharpDX.Direct3D11.Texture2DDescription);
            fixed (void *descRef_ = &descRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[10]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("51218251-1E33-4617-9CCB-4D3A4367E7BB")]
    public partial class Texture2D1 : SharpDX.Direct3D11.Texture2D
    {
        public Texture2D1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Texture2D1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Texture2D1(nativePtr);
        /// <summary>
        /// <p>Gets the properties of the texture resource.</p>
        /// </summary>
        /// <doc-id>dn899245</doc-id>
        /// <unmanaged>GetDesc1</unmanaged>
        /// <unmanaged-short>GetDesc1</unmanaged-short>
        public SharpDX.Direct3D11.Texture2DDescription1 Description1
        {
            get
            {
                GetDescription1(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the properties of the texture resource.</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.Texture2DDescription1"/></strong> structure that receives the description of the 2D texture.</p> </dd></param>
        /// <doc-id>dn899245</doc-id>
        /// <unmanaged>void ID3D11Texture2D1::GetDesc1([Out] D3D11_TEXTURE2D_DESC1* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11Texture2D1::GetDesc1</unmanaged-short>
        internal unsafe void GetDescription1(out SharpDX.Direct3D11.Texture2DDescription1 descRef)
        {
            descRef = default (SharpDX.Direct3D11.Texture2DDescription1);
            fixed (void *descRef_ = &descRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[11]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("037e866e-f56d-4357-a8af-9dabbe6e250e")]
    public partial class Texture3D : SharpDX.Direct3D11.Resource
    {
        public Texture3D(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Texture3D(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Texture3D(nativePtr);
        /// <summary>
        /// <p>Get the properties of the texture resource.</p>
        /// </summary>
        /// <doc-id>ff476638</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.Direct3D11.Texture3DDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Get the properties of the texture resource.</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p>Pointer to a resource description (see <strong><see cref = "SharpDX.Direct3D11.Texture3DDescription"/></strong>).</p> </dd></param>
        /// <doc-id>ff476638</doc-id>
        /// <unmanaged>void ID3D11Texture3D::GetDesc([Out] D3D11_TEXTURE3D_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11Texture3D::GetDesc</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.Direct3D11.Texture3DDescription descRef)
        {
            descRef = default (SharpDX.Direct3D11.Texture3DDescription);
            fixed (void *descRef_ = &descRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[10]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("0C711683-2853-4846-9BB0-F3E60639E46A")]
    public partial class Texture3D1 : SharpDX.Direct3D11.Texture3D
    {
        public Texture3D1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Texture3D1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Texture3D1(nativePtr);
        /// <summary>
        /// <p>Gets the properties of the texture resource.</p>
        /// </summary>
        /// <doc-id>dn899247</doc-id>
        /// <unmanaged>GetDesc1</unmanaged>
        /// <unmanaged-short>GetDesc1</unmanaged-short>
        public SharpDX.Direct3D11.Texture3DDescription1 Description1
        {
            get
            {
                GetDescription1(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the properties of the texture resource.</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.Texture3DDescription1"/></strong> structure that receives the description of the 3D texture.</p> </dd></param>
        /// <doc-id>dn899247</doc-id>
        /// <unmanaged>void ID3D11Texture3D1::GetDesc1([Out] D3D11_TEXTURE3D_DESC1* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11Texture3D1::GetDesc1</unmanaged-short>
        internal unsafe void GetDescription1(out SharpDX.Direct3D11.Texture3DDescription1 descRef)
        {
            descRef = default (SharpDX.Direct3D11.Texture3DDescription1);
            fixed (void *descRef_ = &descRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[11]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("1911c771-1587-413e-a7e0-fb26c3de0268")]
    public partial class TracingDevice : SharpDX.ComObject
    {
        public TracingDevice(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TracingDevice(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TracingDevice(nativePtr);
        /// <summary>
        /// <p>Sets the reference rasterizer's default race-condition tracking options for the specified resource types.</p>
        /// </summary>
        /// <param name = "resourceTypeFlags"><dd> <p>A <strong><see cref = "SharpDX.Direct3D11.ShaderTrackingResourceType"/></strong>-typed value that specifies the type of resource to track. </p> </dd></param>
        /// <param name = "options"><dd> <p>A combination of <strong>D3D11_SHADER_TRACKING_OPTIONS</strong>-typed flags that are combined by using a bitwise <strong>OR</strong> operation. The resulting value identifies tracking options. If a flag is present, the tracking option that the flag represents is set to "on," otherwise the tracking option is set to "off."</p> </dd></param>
        /// <returns><p>This method returns one of the Direct3D 11 return codes.</p></returns>
        /// <remarks>
        /// <p>This API requires the Windows Software Development Kit (SDK) for Windows?8.</p>
        /// </remarks>
        /// <doc-id>hh446874</doc-id>
        /// <unmanaged>HRESULT ID3D11TracingDevice::SetShaderTrackingOptionsByType([In] unsigned int ResourceTypeFlags,[In] unsigned int Options)</unmanaged>
        /// <unmanaged-short>ID3D11TracingDevice::SetShaderTrackingOptionsByType</unmanaged-short>
        public unsafe void SetShaderTrackingOptionsByType(System.Int32 resourceTypeFlags, System.Int32 options)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, resourceTypeFlags, options, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the reference rasterizer's race-condition tracking options for a specific shader.</p>
        /// </summary>
        /// <param name = "shaderRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.IUnknown"/></strong> interface of a shader.</p> </dd></param>
        /// <param name = "options"><dd> <p>A combination of <strong>D3D11_SHADER_TRACKING_OPTIONS</strong>-typed flags that are combined by using a bitwise <strong>OR</strong> operation. The resulting value identifies tracking options. If a flag is present, the tracking option that the flag represents is set to "on"; otherwise the tracking option is set to "off."</p> </dd></param>
        /// <returns><p>This method returns one of the Direct3D 11 return codes.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??After a call to <strong>SetShaderTrackingOptions</strong>, the tracking options that the  <em>Options</em> parameter specifies are set for all calls by the shader that the  <em>pShader</em> parameter specifies, until the next call to <strong>SetShaderTrackingOptions</strong>. If you set a flag that is specific to unordered access views (UAV) (for example, <strong>D3D11_SHADER_TRACKING_OPTION_UAV_SPECIFIC_FLAGS</strong>) in the <em>Options</em> parameter for a compute shader, <strong>SetShaderTrackingOptions</strong> ignores it.?<strong>Note</strong>??This API requires the Windows Software Development Kit (SDK) for Windows?8.?
        /// </remarks>
        /// <doc-id>hh446871</doc-id>
        /// <unmanaged>HRESULT ID3D11TracingDevice::SetShaderTrackingOptions([In] IUnknown* pShader,[In] unsigned int Options)</unmanaged>
        /// <unmanaged-short>ID3D11TracingDevice::SetShaderTrackingOptions</unmanaged-short>
        public unsafe void SetShaderTrackingOptions(SharpDX.IUnknown shaderRef, System.Int32 options)
        {
            System.IntPtr shaderRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            shaderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(shaderRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)shaderRef_, options, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("28acf509-7f5c-48f6-8611-f316010a6380")]
    public partial class UnorderedAccessView : SharpDX.Direct3D11.ResourceView
    {
        public UnorderedAccessView(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator UnorderedAccessView(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new UnorderedAccessView(nativePtr);
        /// <summary>
        /// <p>Get a description of the resource.</p>
        /// </summary>
        /// <doc-id>ff476640</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.Direct3D11.UnorderedAccessViewDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Get a description of the resource.</p>
        /// </summary>
        /// <param name = "descRef"><dd>  <p>Pointer to a resource description (see <strong><see cref = "SharpDX.Direct3D11.UnorderedAccessViewDescription"/></strong>.)</p> </dd></param>
        /// <doc-id>ff476640</doc-id>
        /// <unmanaged>void ID3D11UnorderedAccessView::GetDesc([Out] D3D11_UNORDERED_ACCESS_VIEW_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11UnorderedAccessView::GetDesc</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.Direct3D11.UnorderedAccessViewDescription descRef)
        {
            descRef = default (SharpDX.Direct3D11.UnorderedAccessViewDescription);
            fixed (void *descRef_ = &descRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[8]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("7b3b6153-a886-4544-ab37-6537c8500403")]
    public partial class UnorderedAccessView1 : SharpDX.Direct3D11.UnorderedAccessView
    {
        public UnorderedAccessView1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator UnorderedAccessView1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new UnorderedAccessView1(nativePtr);
        /// <summary>
        /// <p>Gets a description of the resource.</p>
        /// </summary>
        /// <doc-id>dn899249</doc-id>
        /// <unmanaged>GetDesc1</unmanaged>
        /// <unmanaged-short>GetDesc1</unmanaged-short>
        public SharpDX.Direct3D11.UnorderedAccessViewDescription1 Description1
        {
            get
            {
                GetDescription1(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets a description of the resource.</p>
        /// </summary>
        /// <param name = "desc1Ref"><dd>  <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.UnorderedAccessViewDescription1"/></strong> structure that receives the description of the unordered-access resource.</p> </dd></param>
        /// <doc-id>dn899249</doc-id>
        /// <unmanaged>void ID3D11UnorderedAccessView1::GetDesc1([Out] D3D11_UNORDERED_ACCESS_VIEW_DESC1* pDesc1)</unmanaged>
        /// <unmanaged-short>ID3D11UnorderedAccessView1::GetDesc1</unmanaged-short>
        internal unsafe void GetDescription1(out SharpDX.Direct3D11.UnorderedAccessViewDescription1 desc1Ref)
        {
            desc1Ref = default (SharpDX.Direct3D11.UnorderedAccessViewDescription1);
            fixed (void *desc1Ref_ = &desc1Ref)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, desc1Ref_, (*(void ***)this._nativePointer)[9]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("b2daad8b-03d4-4dbf-95eb-32ab4b63d0ab")]
    public partial class UserDefinedAnnotation : SharpDX.ComObject
    {
        public UserDefinedAnnotation(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator UserDefinedAnnotation(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new UserDefinedAnnotation(nativePtr);
        /// <summary>
        /// <p>Determines whether the calling application is running under a Microsoft Direct3D profiling tool.</p>
        /// </summary>
        /// <remarks>
        /// <p>You can call <strong>GetStatus</strong> to determine whether your application is running under a Direct3D profiling tool before you make further calls to other methods of the <strong><see cref = "SharpDX.Direct3D11.UserDefinedAnnotation"/></strong> interface. For example, the <strong>ID3DUserDefinedAnnotation::BeginEvent</strong> and <strong>ID3DUserDefinedAnnotation::EndEvent</strong> methods have no effect if the calling application is not running under an enabled Direct3D profiling tool. Therefore, you do not need to call these methods unless your application is running under a Direct3D profiling tool.</p>
        /// </remarks>
        /// <doc-id>hh446889</doc-id>
        /// <unmanaged>GetStatus</unmanaged>
        /// <unmanaged-short>GetStatus</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool Status
        {
            get => GetStatus();
        }

        /// <summary>
        /// <p>Marks the beginning of a section of event code.</p>
        /// </summary>
        /// <param name = "name"><dd> <p>A <strong><c>null</c></strong>-terminated <strong>UNICODE</strong> string that contains the name of the event. The name is not relevant to the operating system. You can choose a name that is meaningful when the calling application is running under the Direct3D profiling tool.A <strong><c>null</c></strong> reference produces undefined results.</p> </dd></param>
        /// <returns><p>Returns the number of previous calls to <strong>BeginEvent</strong> that have not yet been finalized by calls to the <strong>ID3DUserDefinedAnnotation::EndEvent</strong> method.</p><p>The return value is ?1 if the calling application is not running under a Direct3D profiling tool.</p></returns>
        /// <remarks>
        /// <p>You call the <strong>EndEvent</strong> method to mark the end of the section of event code.</p><p>A user can visualize the event when the calling application is running under an enabled Direct3D profiling tool such as Microsoft Visual Studio Ultimate?2012.</p><p><strong>BeginEvent</strong> has no effect if the calling application is not running under an enabled Direct3D profiling tool.</p>
        /// </remarks>
        /// <doc-id>hh446884</doc-id>
        /// <unmanaged>int ID3DUserDefinedAnnotation::BeginEvent([In] const wchar_t* Name)</unmanaged>
        /// <unmanaged-short>ID3DUserDefinedAnnotation::BeginEvent</unmanaged-short>
        public unsafe System.Int32 BeginEvent(System.String name)
        {
            System.Int32 __result__;
            fixed (char *name_ = name)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)name_, (*(void ***)this._nativePointer)[3]);
            return __result__;
        }

        /// <summary>
        /// <p>Marks the end of a section of event code.</p>
        /// </summary>
        /// <returns><p>Returns the number of previous calls to the <strong>ID3DUserDefinedAnnotation::BeginEvent</strong> method that have not yet been finalized by calls to <strong>EndEvent</strong>.</p><p>The return value is ?1 if the calling application is not running under a Direct3D profiling tool.</p></returns>
        /// <remarks>
        /// <p>You call the <strong>BeginEvent</strong> method to mark the beginning of the section of event code.</p><p>A user can visualize the event when the calling application is running under an enabled Direct3D profiling tool such as Microsoft Visual Studio Ultimate?2012.</p><p><strong>EndEvent</strong> has no effect if the calling application is not running under an enabled Direct3D profiling tool.</p>
        /// </remarks>
        /// <doc-id>hh446886</doc-id>
        /// <unmanaged>int ID3DUserDefinedAnnotation::EndEvent()</unmanaged>
        /// <unmanaged-short>ID3DUserDefinedAnnotation::EndEvent</unmanaged-short>
        public unsafe System.Int32 EndEvent()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            return __result__;
        }

        /// <summary>
        /// <p>Marks a single point of execution in code.</p>
        /// </summary>
        /// <param name = "name"><dd> <p>A <strong><c>null</c></strong>-terminated <strong>UNICODE</strong> string that contains the name of the marker. The name is not relevant to the operating system. You can choose a name that is meaningful when the calling application is running under the Direct3D profiling tool.A <strong><c>null</c></strong> reference produces undefined results.</p> </dd></param>
        /// <remarks>
        /// <p>A user can visualize the marker when the calling application is running under an enabled Direct3D profiling tool such as Microsoft Visual Studio Ultimate?2012.</p><p><strong>SetMarker</strong> has no effect if the calling application is not running under an enabled Direct3D profiling tool.</p>
        /// </remarks>
        /// <doc-id>hh446898</doc-id>
        /// <unmanaged>void ID3DUserDefinedAnnotation::SetMarker([In] const wchar_t* Name)</unmanaged>
        /// <unmanaged-short>ID3DUserDefinedAnnotation::SetMarker</unmanaged-short>
        public unsafe void SetMarker(System.String name)
        {
            fixed (char *name_ = name)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)name_, (*(void ***)this._nativePointer)[5]);
        }

        /// <summary>
        /// <p>Determines whether the calling application is running under a Microsoft Direct3D profiling tool.</p>
        /// </summary>
        /// <returns><p>The return value is nonzero if the calling application is running under a Direct3D profiling tool such as Visual Studio Ultimate?2012, and zero otherwise.</p></returns>
        /// <remarks>
        /// <p>You can call <strong>GetStatus</strong> to determine whether your application is running under a Direct3D profiling tool before you make further calls to other methods of the <strong><see cref = "SharpDX.Direct3D11.UserDefinedAnnotation"/></strong> interface. For example, the <strong>ID3DUserDefinedAnnotation::BeginEvent</strong> and <strong>ID3DUserDefinedAnnotation::EndEvent</strong> methods have no effect if the calling application is not running under an enabled Direct3D profiling tool. Therefore, you do not need to call these methods unless your application is running under a Direct3D profiling tool.</p>
        /// </remarks>
        /// <doc-id>hh446889</doc-id>
        /// <unmanaged>BOOL ID3DUserDefinedAnnotation::GetStatus()</unmanaged>
        /// <unmanaged-short>ID3DUserDefinedAnnotation::GetStatus</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawBool GetStatus()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[6]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("3b301d64-d678-4289-8897-22f8928b72f3")]
    public partial class VertexShader : SharpDX.Direct3D11.DeviceChild
    {
        public VertexShader(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator VertexShader(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new VertexShader(nativePtr);
    }

    [System.Runtime.InteropServices.GuidAttribute("c0bfa96c-e089-44fb-8eaf-26f8796190da")]
    public partial class VertexShaderStage : CommonShaderStage<VertexShader>
    {
        public VertexShaderStage(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator VertexShaderStage(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new VertexShaderStage(nativePtr);
        /// <summary>
        /// <p>Sets the constant buffers used by the vertex shader pipeline stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p> Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to <strong><see cref = "ConstantBufferApiSlotCount"/></strong> - 1). </p> </dd></param>
        /// <param name = "numBuffers"><dd>  <p> Number of buffers to set (ranges from 0 to <strong><see cref = "ConstantBufferApiSlotCount"/></strong> - <em>StartSlot</em>). </p> </dd></param>
        /// <param name = "constantBuffersOut"><dd>  <p> Array of constant buffers (see <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>) being given to the device. </p> </dd></param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p> The Direct3D 11.1 runtime, which is available starting with Windows?8, can bind a larger number of <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong> resources to the shader than the maximum constant buffer size that is supported by shaders (4096 constants ? 4*32-bit components each).  When you bind such a large buffer, the shader can access only the first 4096 4*32-bit component constants in the buffer, as if 4096 constants is the full size of the buffer. </p><p> If the application wants the shader to access other parts of the buffer, it must call the <strong>VSSetConstantBuffers1</strong> method instead. </p><p><strong>Windows?Phone?8: </strong> This API is supported. </p>
        /// </remarks>
        /// <doc-id>ff476491</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::VSSetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D11Buffer** ppConstantBuffers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::VSSetConstantBuffers</unmanaged-short>
        internal override unsafe void SetConstantBuffers(System.Int32 startSlot, System.Int32 numBuffers, System.IntPtr constantBuffersOut)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut, (*(void ***)this._nativePointer)[7]);
        }

        /// <summary>
        /// <p>Set a vertex shader to the device.</p>
        /// </summary>
        /// <param name = "vertexShaderRef"><dd>  <p>Pointer to a vertex shader (see <strong><see cref = "SharpDX.Direct3D11.VertexShader"/></strong>). Passing in <strong><c>null</c></strong> disables the shader for this pipeline stage.</p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p>A reference to an array of class-instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <strong><c>null</c></strong> if the shader does not use any interfaces.</p> </dd></param>
        /// <param name = "numClassInstances"><dd>  <p>The number of class-instance interfaces in the array.</p> </dd></param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p>The maximum number of instances a shader can have is 256.</p>
        /// </remarks>
        /// <doc-id>ff476493</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::VSSetShader([In, Optional] ID3D11VertexShader* pVertexShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[In] unsigned int NumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::VSSetShader</unmanaged-short>
        internal override unsafe void SetShader(SharpDX.Direct3D11.VertexShader vertexShaderRef, SharpDX.Direct3D11.ClassInstance[] classInstancesOut, System.Int32 numClassInstances)
        {
            System.IntPtr vertexShaderRef_ = System.IntPtr.Zero;
            System.IntPtr*classInstancesOut_;
            classInstancesOut_ = (System.IntPtr*)0;
            if (classInstancesOut != null)
            {
                System.IntPtr*_classInstancesOut = stackalloc System.IntPtr[classInstancesOut.Length];
                classInstancesOut_ = _classInstancesOut;
            }

            vertexShaderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VertexShader>(vertexShaderRef);
            if (classInstancesOut != null)
                for (int i = 0; i < classInstancesOut.Length; ++i)
                    (classInstancesOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.ClassInstance>(classInstancesOut[i]);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)vertexShaderRef_, (void *)classInstancesOut_, numClassInstances, (*(void ***)this._nativePointer)[11]);
        }

        /// <summary>
        /// <p>Bind an array of shader resources to the vertex-shader stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin setting shader resources to (range is from 0 to <see cref = "InputResourceSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numViews"><dd>  <p>Number of shader resources to set. Up to a maximum of 128 slots are available for shader resources (range is from 0 to <see cref = "InputResourceSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "shaderResourceViewsOut"><dd>  <p>Array of <strong>shader resource view</strong> interfaces to set to the device.</p> </dd></param>
        /// <remarks>
        /// <p>If an overlapping resource view is already bound to an output slot, such as a rendertarget, then this API will fill the destination shader resource slot with <strong><c>null</c></strong>.</p><p>For information about creating shader-resource views, see <strong>ID3D11Device::CreateShaderResourceView</strong>.</p><p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p>
        /// </remarks>
        /// <doc-id>ff476494</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::VSSetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[In, Buffer, Optional] const ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::VSSetShaderResources</unmanaged-short>
        internal override unsafe void SetShaderResources(System.Int32 startSlot, System.Int32 numViews, System.IntPtr shaderResourceViewsOut)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numViews, (void *)shaderResourceViewsOut, (*(void ***)this._nativePointer)[25]);
        }

        /// <summary>
        /// <p>Set an array of sampler states to the vertex shader pipeline stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin setting samplers to (ranges from 0 to <see cref = "SamplerSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numSamplers"><dd>  <p>Number of samplers in the array. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to <see cref = "SamplerSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "samplersOut"><dd>  <p>Pointer to an array of sampler-state interfaces (see <strong><see cref = "SharpDX.Direct3D11.SamplerState"/></strong>). See Remarks.</p> </dd></param>
        /// <remarks>
        /// <p>Any sampler may be set to <strong><c>null</c></strong>; this invokes the default state, which is defined to be the following.</p><pre> //Default sampler state:
        /// <see cref = "SharpDX.Direct3D11.SamplerStateDescription"/> SamplerDesc;
        /// SamplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
        /// SamplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
        /// SamplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
        /// SamplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
        /// SamplerDesc.MipLODBias = 0;
        /// SamplerDesc.MaxAnisotropy = 1;
        /// SamplerDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;
        /// SamplerDesc.BorderColor[0] = 1.0f;
        /// SamplerDesc.BorderColor[1] = 1.0f;
        /// SamplerDesc.BorderColor[2] = 1.0f;
        /// SamplerDesc.BorderColor[3] = 1.0f;
        /// SamplerDesc.MinLOD = -FLT_MAX;
        /// SamplerDesc.MaxLOD = FLT_MAX; </pre><p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p>
        /// </remarks>
        /// <doc-id>ff476492</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::VSSetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[In, Buffer, Optional] const ID3D11SamplerState** ppSamplers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::VSSetSamplers</unmanaged-short>
        internal override unsafe void SetSamplers(System.Int32 startSlot, System.Int32 numSamplers, System.IntPtr samplersOut)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numSamplers, (void *)samplersOut, (*(void ***)this._nativePointer)[26]);
        }

        /// <summary>
        /// <p>Get the constant buffers used by the vertex shader pipeline stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numBuffers"><dd>  <p>Number of buffers to retrieve (ranges from 0 to <see cref = "ConstantBufferApiSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "constantBuffersOut"><dd>  <p>Array of constant buffer interface references (see <strong><see cref = "SharpDX.Direct3D11.Buffer"/></strong>) to be returned by the method.</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476487</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::VSGetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[Out, Buffer, Optional] ID3D11Buffer** ppConstantBuffers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::VSGetConstantBuffers</unmanaged-short>
        internal override unsafe void GetConstantBuffers(System.Int32 startSlot, System.Int32 numBuffers, SharpDX.Direct3D11.Buffer[] constantBuffersOut)
        {
            System.IntPtr*constantBuffersOut_;
            constantBuffersOut_ = (System.IntPtr*)0;
            if (constantBuffersOut != null)
            {
                System.IntPtr*_constantBuffersOut = stackalloc System.IntPtr[constantBuffersOut.Length];
                constantBuffersOut_ = _constantBuffersOut;
            }

            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numBuffers, (void *)constantBuffersOut_, (*(void ***)this._nativePointer)[72]);
            if (constantBuffersOut != null)
                for (int i = 0; i < constantBuffersOut.Length; ++i)
                    if ((constantBuffersOut_)[i] != System.IntPtr.Zero)
                        constantBuffersOut[i] = new SharpDX.Direct3D11.Buffer((constantBuffersOut_)[i]);
                    else
                        constantBuffersOut[i] = null;
        }

        /// <summary>
        /// <p>Get the vertex shader currently set on the device.</p>
        /// </summary>
        /// <param name = "vertexShaderOut"><dd>  <p>Address of a reference to a vertex shader (see <strong><see cref = "SharpDX.Direct3D11.VertexShader"/></strong>) to be returned by the method.</p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p>Pointer to an array of class instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>).</p> </dd></param>
        /// <param name = "numClassInstancesRef"><dd>  <p>The number of class-instance elements in the array.</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476489</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::VSGetShader([Out, Optional] ID3D11VertexShader** ppVertexShader,[Out, Buffer, Optional] ID3D11ClassInstance** ppClassInstances,[InOut] unsigned int* pNumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::VSGetShader</unmanaged-short>
        internal override unsafe void GetShader(out SharpDX.Direct3D11.VertexShader vertexShaderOut, SharpDX.Direct3D11.ClassInstance[] classInstancesOut, ref System.Int32 numClassInstancesRef)
        {
            System.IntPtr vertexShaderOut_ = System.IntPtr.Zero;
            System.IntPtr*classInstancesOut_;
            classInstancesOut_ = (System.IntPtr*)0;
            if (classInstancesOut != null)
            {
                System.IntPtr*_classInstancesOut = stackalloc System.IntPtr[classInstancesOut.Length];
                classInstancesOut_ = _classInstancesOut;
            }

            fixed (void *numClassInstancesRef_ = &numClassInstancesRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, &vertexShaderOut_, (void *)classInstancesOut_, numClassInstancesRef_, (*(void ***)this._nativePointer)[76]);
            if (vertexShaderOut_ != System.IntPtr.Zero)
                vertexShaderOut = new SharpDX.Direct3D11.VertexShader(vertexShaderOut_);
            else
                vertexShaderOut = null;
            if (classInstancesOut != null)
                for (int i = 0; i < classInstancesOut.Length; ++i)
                    if ((classInstancesOut_)[i] != System.IntPtr.Zero)
                        classInstancesOut[i] = new SharpDX.Direct3D11.ClassInstance((classInstancesOut_)[i]);
                    else
                        classInstancesOut[i] = null;
        }

        /// <summary>
        /// <p>Get the vertex shader resources.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into the device's zero-based array to begin getting shader resources from (ranges from 0 to <see cref = "InputResourceSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numViews"><dd>  <p>The number of resources to get from the device. Up to a maximum of 128 slots are available for shader resources (ranges from 0 to <see cref = "InputResourceSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "shaderResourceViewsOut"><dd>  <p>Array of <strong>shader resource view</strong> interfaces to be returned by the device.</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476490</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::VSGetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[Out, Buffer, Optional] ID3D11ShaderResourceView** ppShaderResourceViews)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::VSGetShaderResources</unmanaged-short>
        internal override unsafe void GetShaderResources(System.Int32 startSlot, System.Int32 numViews, SharpDX.Direct3D11.ShaderResourceView[] shaderResourceViewsOut)
        {
            System.IntPtr*shaderResourceViewsOut_;
            shaderResourceViewsOut_ = (System.IntPtr*)0;
            if (shaderResourceViewsOut != null)
            {
                System.IntPtr*_shaderResourceViewsOut = stackalloc System.IntPtr[shaderResourceViewsOut.Length];
                shaderResourceViewsOut_ = _shaderResourceViewsOut;
            }

            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numViews, (void *)shaderResourceViewsOut_, (*(void ***)this._nativePointer)[84]);
            if (shaderResourceViewsOut != null)
                for (int i = 0; i < shaderResourceViewsOut.Length; ++i)
                    if ((shaderResourceViewsOut_)[i] != System.IntPtr.Zero)
                        shaderResourceViewsOut[i] = new SharpDX.Direct3D11.ShaderResourceView((shaderResourceViewsOut_)[i]);
                    else
                        shaderResourceViewsOut[i] = null;
        }

        /// <summary>
        /// <p>Get an array of sampler states from the vertex shader pipeline stage.</p>
        /// </summary>
        /// <param name = "startSlot"><dd>  <p>Index into a zero-based array to begin getting samplers from (ranges from 0 to <see cref = "SamplerSlotCount"/> - 1).</p> </dd></param>
        /// <param name = "numSamplers"><dd>  <p>Number of samplers to get from a device context. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to <see cref = "SamplerSlotCount"/> - StartSlot).</p> </dd></param>
        /// <param name = "samplersOut"><dd>  <p>Arry of sampler-state interface references (see <strong><see cref = "SharpDX.Direct3D11.SamplerState"/></strong>) to be returned by the device.</p> </dd></param>
        /// <remarks>
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>
        /// </remarks>
        /// <doc-id>ff476488</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::VSGetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[Out, Buffer, Optional] ID3D11SamplerState** ppSamplers)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::VSGetSamplers</unmanaged-short>
        internal override unsafe void GetSamplers(System.Int32 startSlot, System.Int32 numSamplers, SharpDX.Direct3D11.SamplerState[] samplersOut)
        {
            System.IntPtr*samplersOut_;
            samplersOut_ = (System.IntPtr*)0;
            if (samplersOut != null)
            {
                System.IntPtr*_samplersOut = stackalloc System.IntPtr[samplersOut.Length];
                samplersOut_ = _samplersOut;
            }

            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, startSlot, numSamplers, (void *)samplersOut_, (*(void ***)this._nativePointer)[85]);
            if (samplersOut != null)
                for (int i = 0; i < samplersOut.Length; ++i)
                    if ((samplersOut_)[i] != System.IntPtr.Zero)
                        samplersOut[i] = new SharpDX.Direct3D11.SamplerState((samplersOut_)[i]);
                    else
                        samplersOut[i] = null;
        }

        /// <summary>
        /// <p>Set a vertex shader to the device.</p>
        /// </summary>
        /// <param name = "vertexShaderRef"><dd>  <p>Pointer to a vertex shader (see <strong><see cref = "SharpDX.Direct3D11.VertexShader"/></strong>). Passing in <strong><c>null</c></strong> disables the shader for this pipeline stage.</p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p>A reference to an array of class-instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <strong><c>null</c></strong> if the shader does not use any interfaces.</p> </dd></param>
        /// <param name = "numClassInstances"><dd>  <p>The number of class-instance interfaces in the array.</p> </dd></param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p>The maximum number of instances a shader can have is 256.</p>
        /// </remarks>
        /// <doc-id>ff476493</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::VSSetShader([In, Optional] ID3D11VertexShader* pVertexShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[In] unsigned int NumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::VSSetShader</unmanaged-short>
        internal override unsafe void SetShader(SharpDX.Direct3D11.VertexShader vertexShaderRef, SharpDX.ComArray<SharpDX.Direct3D11.ClassInstance> classInstancesOut, System.Int32 numClassInstances)
        {
            System.IntPtr vertexShaderRef_ = System.IntPtr.Zero;
            vertexShaderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VertexShader>(vertexShaderRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)vertexShaderRef_, (void *)(classInstancesOut?.NativePointer ?? System.IntPtr.Zero), numClassInstances, (*(void ***)this._nativePointer)[11]);
        }

        /// <summary>
        /// <p>Set a vertex shader to the device.</p>
        /// </summary>
        /// <param name = "vertexShaderRef"><dd>  <p>Pointer to a vertex shader (see <strong><see cref = "SharpDX.Direct3D11.VertexShader"/></strong>). Passing in <strong><c>null</c></strong> disables the shader for this pipeline stage.</p> </dd></param>
        /// <param name = "classInstancesOut"><dd>  <p>A reference to an array of class-instance interfaces (see <strong><see cref = "SharpDX.Direct3D11.ClassInstance"/></strong>). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <strong><c>null</c></strong> if the shader does not use any interfaces.</p> </dd></param>
        /// <param name = "numClassInstances"><dd>  <p>The number of class-instance interfaces in the array.</p> </dd></param>
        /// <remarks>
        /// <p> The method will hold a reference to the interfaces passed in. This differs from the device state behavior in Direct3D 10. </p><p>The maximum number of instances a shader can have is 256.</p>
        /// </remarks>
        /// <doc-id>ff476493</doc-id>
        /// <unmanaged>void ID3D11DeviceContext::VSSetShader([In, Optional] ID3D11VertexShader* pVertexShader,[In, Buffer, Optional] const ID3D11ClassInstance** ppClassInstances,[In] unsigned int NumClassInstances)</unmanaged>
        /// <unmanaged-short>ID3D11DeviceContext::VSSetShader</unmanaged-short>
        private unsafe void SetShader(System.IntPtr vertexShaderRef, System.IntPtr classInstancesOut, System.Int32 numClassInstances)
        {
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)vertexShaderRef, (void *)classInstancesOut, numClassInstances, (*(void ***)this._nativePointer)[11]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("61F21C45-3C0E-4a74-9CEA-67100D9AD5E4")]
    public partial class VideoContext : SharpDX.Direct3D11.DeviceChild
    {
        public VideoContext(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator VideoContext(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new VideoContext(nativePtr);
        /// <summary>
        /// <p>Gets a reference to a decoder buffer.</p>
        /// </summary>
        /// <param name = "decoderRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoDecoder"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoDecoder</strong>.</p> </dd></param>
        /// <param name = "type"><dd> <p>The type of buffer to retrieve, specified as a member of the <strong><see cref = "SharpDX.Direct3D11.VideoDecoderBufferType"/></strong> enumeration.</p> </dd></param>
        /// <param name = "bufferSizeRef"><dd> <p>Receives the size of the buffer, in bytes. </p> </dd></param>
        /// <param name = "bufferOut"><dd> <p>Receives a reference to the start of the memory buffer. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The graphics driver allocates the buffers that are used for decoding. This method locks the Microsoft Direct3D surface that contains the buffer. When you are done using the buffer, call <strong>ID3D11VideoContext::ReleaseDecoderBuffer</strong> to unlock the surface. </p>
        /// </remarks>
        /// <doc-id>hh447711</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoContext::GetDecoderBuffer([In] ID3D11VideoDecoder* pDecoder,[In] D3D11_VIDEO_DECODER_BUFFER_TYPE Type,[Out] unsigned int* pBufferSize,[Out] void** ppBuffer)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::GetDecoderBuffer</unmanaged-short>
        internal unsafe void GetDecoderBuffer(SharpDX.Direct3D11.VideoDecoder decoderRef, SharpDX.Direct3D11.VideoDecoderBufferType type, out System.Int32 bufferSizeRef, out System.IntPtr bufferOut)
        {
            System.IntPtr decoderRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            decoderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoDecoder>(decoderRef);
            fixed (void *bufferOut_ = &bufferOut)
                fixed (void *bufferSizeRef_ = &bufferSizeRef)
                    __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)decoderRef_, unchecked ((System.Int32)type), bufferSizeRef_, bufferOut_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Releases a buffer that was obtained by calling the <strong>ID3D11VideoContext::GetDecoderBuffer</strong> method.</p>
        /// </summary>
        /// <param name = "decoderRef">No documentation.</param>
        /// <param name = "type">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447716</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoContext::ReleaseDecoderBuffer([In] ID3D11VideoDecoder* pDecoder,[In] D3D11_VIDEO_DECODER_BUFFER_TYPE Type)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::ReleaseDecoderBuffer</unmanaged-short>
        public unsafe void ReleaseDecoderBuffer(SharpDX.Direct3D11.VideoDecoder decoderRef, SharpDX.Direct3D11.VideoDecoderBufferType type)
        {
            System.IntPtr decoderRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            decoderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoDecoder>(decoderRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)decoderRef_, unchecked ((System.Int32)type), (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Starts a decoding operation to decode a video frame.</p>
        /// </summary>
        /// <param name = "decoderRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoDecoder"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoDecoder</strong>.</p> </dd></param>
        /// <param name = "viewRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoDecoderOutputView"/></strong> interface. This interface describes the resource that will receive the decoded frame. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoDecoderOutputView</strong>.</p> </dd></param>
        /// <param name = "contentKeySize"><dd> <p>The size of the content key that is specified in <em>pContentKey</em>. If <em>pContentKey</em> is <c>null</c>, set <em>ContentKeySize</em> to zero.</p> </dd></param>
        /// <param name = "contentKeyRef"><dd> <p>An optional reference to a content key that was used to encrypt the frame data. If no content key was used, set this parameter to <strong><c>null</c></strong>. If the caller provides a content key, the caller must use the session key to encrypt the content key.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.  <strong>D3DERR_WASSTILLDRAWING</strong> or <strong>E_PENDING</strong> is returned if the harware is busy, in which case the decoder should try to make the call again.</p></returns>
        /// <remarks>
        /// <p>After this method is called, call <strong>ID3D11VideoContext::SubmitDecoderBuffers</strong> to perform decoding operations. When all decoding operations have been executed, call <strong>ID3D11VideoContext::DecoderEndFrame</strong>. </p><p>Each call to <strong>DecoderBeginFrame</strong> must have a matching call to <strong>DecoderEndFrame</strong>. In most cases you cannot nest <strong>DecoderBeginFrame</strong> calls, but some codecs, such as  like VC-1, can have nested <strong>DecoderBeginFrame</strong> calls for special operations like post processing.</p><p>The following encryption scenarios are supported through the content key:</p><ul> <li>The decoder can choose to not encrypt every frame, for example  it may only encrypt the I frames and not encrypt the P/B frames.  In these scenario, the decoder will specify pContentKey = <c>null</c> and ContentKeySize = 0 for those frames that it does not encrypt.</li> <li>The decoder can choose to encrypt the compressed buffers using the session key.  In this scenario, the decoder will specify a content key containing all zeros.</li> <li>The decoder can choose to encrypt the compressed buffers using a separate content key.  In this scenario, the decoder will ECB encrypt the content key using the session key and pass the encrypted content key.</li> </ul>
        /// </remarks>
        /// <doc-id>hh447705</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoContext::DecoderBeginFrame([In] ID3D11VideoDecoder* pDecoder,[In] ID3D11VideoDecoderOutputView* pView,[In] unsigned int ContentKeySize,[In, Buffer, Optional] const void* pContentKey)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::DecoderBeginFrame</unmanaged-short>
        public unsafe void DecoderBeginFrame(SharpDX.Direct3D11.VideoDecoder decoderRef, SharpDX.Direct3D11.VideoDecoderOutputView viewRef, System.Int32 contentKeySize, System.IntPtr contentKeyRef)
        {
            System.IntPtr decoderRef_ = System.IntPtr.Zero;
            System.IntPtr viewRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            decoderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoDecoder>(decoderRef);
            viewRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoDecoderOutputView>(viewRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)decoderRef_, (void *)viewRef_, contentKeySize, (void *)contentKeyRef, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Signals the end of a decoding operation.</p>
        /// </summary>
        /// <param name = "decoderRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoDecoder"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoDecoder</strong>.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447706</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoContext::DecoderEndFrame([In] ID3D11VideoDecoder* pDecoder)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::DecoderEndFrame</unmanaged-short>
        public unsafe void DecoderEndFrame(SharpDX.Direct3D11.VideoDecoder decoderRef)
        {
            System.IntPtr decoderRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            decoderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoDecoder>(decoderRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)decoderRef_, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Submits one or more buffers for decoding.</p>
        /// </summary>
        /// <param name = "decoderRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoDecoder"/></strong> interface. To get this reference, call the <strong>ID3D11VideoDevice::CreateVideoDecoder</strong> method.</p> </dd></param>
        /// <param name = "numBuffers"><dd> <p>The number of buffers submitted for decoding.</p> </dd></param>
        /// <param name = "bufferDescRef"><dd> <p>A reference to an array of <strong><see cref = "SharpDX.Direct3D11.VideoDecoderBufferDescription"/></strong> structures. The <em>NumBuffers</em> parameter specifies the number of elements in the array. Each element in the array describes a compressed buffer for decoding.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This function does not honor a D3D11 predicate that may have been set.</p><p>If the application uses <strong>D3D11 quries</strong>, this function may not be accounted for with <strong>D3D11_QUERY_EVENT</strong> and <strong>D3D11_QUERY_TIMESTAMP</strong> when using feature levels lower than 11.  <strong>D3D11_QUERY_PIPELINE_STATISTICS</strong> will not include this function for any feature level.</p><p>When using feature levels 9_x, all partially encrypted buffers must use the same EncryptedBlockInfo, and partial encryption cannot be turned off on a per frame basis.</p>
        /// </remarks>
        /// <doc-id>hh447718</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoContext::SubmitDecoderBuffers([In] ID3D11VideoDecoder* pDecoder,[In] unsigned int NumBuffers,[In, Buffer] const D3D11_VIDEO_DECODER_BUFFER_DESC* pBufferDesc)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::SubmitDecoderBuffers</unmanaged-short>
        public unsafe void SubmitDecoderBuffers(SharpDX.Direct3D11.VideoDecoder decoderRef, System.Int32 numBuffers, SharpDX.Direct3D11.VideoDecoderBufferDescription[] bufferDescRef)
        {
            System.IntPtr decoderRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            decoderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoDecoder>(decoderRef);
            fixed (void *bufferDescRef_ = bufferDescRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)decoderRef_, numBuffers, bufferDescRef_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Performs an extended function for decoding. This method enables extensions to the basic decoder functionality.</p>
        /// </summary>
        /// <param name = "decoderRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoDecoder"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoDecoder</strong>.</p> </dd></param>
        /// <param name = "extensionDataRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoDecoderExtension"/></strong> structure that contains data for the function.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447707</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoContext::DecoderExtension([In] ID3D11VideoDecoder* pDecoder,[In] const D3D11_VIDEO_DECODER_EXTENSION* pExtensionData)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::DecoderExtension</unmanaged-short>
        public unsafe void DecoderExtension(SharpDX.Direct3D11.VideoDecoder decoderRef, ref SharpDX.Direct3D11.VideoDecoderExtension extensionDataRef)
        {
            System.IntPtr decoderRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.VideoDecoderExtension.__Native extensionDataRef_ = default (SharpDX.Direct3D11.VideoDecoderExtension.__Native);
            SharpDX.Result __result__;
            decoderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoDecoder>(decoderRef);
            extensionDataRef.__MarshalTo(ref extensionDataRef_);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)decoderRef_, &extensionDataRef_, (*(void ***)this._nativePointer)[12]);
            extensionDataRef.__MarshalFree(ref extensionDataRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the target rectangle for the video processor.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "enable"><dd> <p>Specifies whether to apply the target rectangle.</p> </dd></param>
        /// <param name = "rectRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure that specifies the target rectangle.  If <em>Enable</em> is <strong><see cref = "SharpDX.Result.False"/></strong>, this parameter is ignored.</p> </dd></param>
        /// <remarks>
        /// <p>The target rectangle is the area within the destination surface where the output will be drawn. The target rectangle is given in pixel coordinates, relative to the destination surface.</p><p>If this method is never called, or if the <em>Enable</em> parameter is <strong><see cref = "SharpDX.Result.False"/></strong>, the video processor writes to the entire destination surface.</p>
        /// </remarks>
        /// <doc-id>hh447752</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorSetOutputTargetRect([In] ID3D11VideoProcessor* pVideoProcessor,[In] BOOL Enable,[In, Optional] const RECT* pRect)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorSetOutputTargetRect</unmanaged-short>
        public unsafe void VideoProcessorSetOutputTargetRect(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, SharpDX.Mathematics.Interop.RawBool enable, SharpDX.Mathematics.Interop.RawRectangle? rectRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawRectangle rectRef_;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            if (rectRef != null)
                rectRef_ = rectRef.Value;
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid0(this._nativePointer, (void *)videoProcessorRef_, enable, rectRef == null ? (void *)0 : &rectRef_, (*(void ***)this._nativePointer)[13]);
        }

        /// <summary>
        /// <p>Sets the background color for the video processor.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "yCbCr"><dd> <p>If <strong>TRUE</strong>, the color is specified as a YCbCr value. Otherwise, the color is specified as an RGB value.</p> </dd></param>
        /// <param name = "colorRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoColor"/></strong> structure that specifies the background color.</p> </dd></param>
        /// <remarks>
        /// <p>The video processor uses the background color to fill areas of the target rectangle that do not contain a video image. Areas outside the target rectangle are not affected.</p>
        /// </remarks>
        /// <doc-id>hh447747</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorSetOutputBackgroundColor([In] ID3D11VideoProcessor* pVideoProcessor,[In] BOOL YCbCr,[In] const D3D11_VIDEO_COLOR* pColor)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorSetOutputBackgroundColor</unmanaged-short>
        public unsafe void VideoProcessorSetOutputBackgroundColor(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, SharpDX.Mathematics.Interop.RawBool yCbCr, SharpDX.Direct3D11.VideoColor colorRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid0(this._nativePointer, (void *)videoProcessorRef_, yCbCr, &colorRef, (*(void ***)this._nativePointer)[14]);
        }

        /// <summary>
        /// <p>Sets the output color space for the video processor.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "colorSpaceRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorColorSpace"/></strong> structure that specifies the color space.</p> </dd></param>
        /// <doc-id>hh447748</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorSetOutputColorSpace([In] ID3D11VideoProcessor* pVideoProcessor,[In] const D3D11_VIDEO_PROCESSOR_COLOR_SPACE* pColorSpace)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorSetOutputColorSpace</unmanaged-short>
        public unsafe void VideoProcessorSetOutputColorSpace(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, SharpDX.Direct3D11.VideoProcessorColorSpace colorSpaceRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, &colorSpaceRef, (*(void ***)this._nativePointer)[15]);
        }

        /// <summary>
        /// <p>Sets the alpha fill mode for data that the video processor writes to the render target.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "alphaFillMode"><dd> <p>The alpha fill mode, specified as a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorAlphaFillMode"/></strong> value.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of an input stream. This parameter is used if <em>AlphaFillMode</em> is <strong>D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE_SOURCE_STREAM</strong>. Otherwise, the parameter is ignored.</p> </dd></param>
        /// <remarks>
        /// <p>To find out which fill modes the device supports, call the <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> method. If the driver reports the <strong>D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_ALPHA_FILL</strong> capability, the driver supports all of the fill modes. Otherwise, the <em>AlphaFillMode</em> parameter must be <strong>D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE_OPAQUE</strong>. </p><p>The default fill mode is <strong>D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE_OPAQUE</strong>.</p>
        /// </remarks>
        /// <doc-id>hh447746</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorSetOutputAlphaFillMode([In] ID3D11VideoProcessor* pVideoProcessor,[In] D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE AlphaFillMode,[In] unsigned int StreamIndex)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorSetOutputAlphaFillMode</unmanaged-short>
        public unsafe void VideoProcessorSetOutputAlphaFillMode(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, SharpDX.Direct3D11.VideoProcessorAlphaFillMode alphaFillMode, System.Int32 streamIndex)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, unchecked ((System.Int32)alphaFillMode), streamIndex, (*(void ***)this._nativePointer)[16]);
        }

        /// <summary>
        /// <p>Sets the amount of downsampling to perform on the output.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "enable"><dd> <p>If <strong>TRUE</strong>, downsampling is enabled. Otherwise, downsampling is disabled and the <strong>Size</strong> member is ignored. </p> </dd></param>
        /// <param name = "size"><dd> <p>The sampling size.</p> </dd></param>
        /// <remarks>
        /// <p>Downsampling is sometimes used to reduce the quality of premium content when other forms of content protection are not available. By default, downsampling is disabled.</p><p>If the <em>Enable</em> parameter is <strong>TRUE</strong>, the driver downsamples the composed image  to the specified size, and then scales it back to the size of the target rectangle.</p><p>The width and height of <em>Size</em> must be greater than zero. If the size is larger than the target rectangle, downsampling does not occur.</p><p>To use this feature, the driver must support downsampling, indicated by the <strong>D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_CONSTRICTION</strong> capability flag. To query for this capability, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong>.</p>
        /// </remarks>
        /// <doc-id>hh447749</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorSetOutputConstriction([In] ID3D11VideoProcessor* pVideoProcessor,[In] BOOL Enable,[In] SIZE Size)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorSetOutputConstriction</unmanaged-short>
        public unsafe void VideoProcessorSetOutputConstriction(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, SharpDX.Mathematics.Interop.RawBool enable, SharpDX.Size2 size)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid0(this._nativePointer, (void *)videoProcessorRef_, enable, size, (*(void ***)this._nativePointer)[17]);
        }

        /// <summary>
        /// <p>Specifies whether the video processor produces stereo video frames.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "enable"><dd> <p>If <strong>TRUE</strong>, stereo output is enabled. Otherwise, the video processor produces mono video frames.</p> </dd></param>
        /// <remarks>
        /// <p>By default, the video processor produces mono video frames.</p><p>To use this feature, the driver must support stereo video, indicated by the <strong>D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_STEREO</strong> capability flag. To query for this capability, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong>.</p>
        /// </remarks>
        /// <doc-id>hh447751</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorSetOutputStereoMode([In] ID3D11VideoProcessor* pVideoProcessor,[In] BOOL Enable)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorSetOutputStereoMode</unmanaged-short>
        public unsafe void VideoProcessorSetOutputStereoMode(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, SharpDX.Mathematics.Interop.RawBool enable)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid0(this._nativePointer, (void *)videoProcessorRef_, enable, (*(void ***)this._nativePointer)[18]);
        }

        /// <summary>
        /// <p>Sets a driver-specific video processing state.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "extensionGuidRef"><dd> <p>A reference to a <see cref = "System.Guid"/> that identifies the operation. The meaning of this <see cref = "System.Guid"/> is defined by the graphics driver.</p> </dd></param>
        /// <param name = "dataSize"><dd> <p>The size of the <em>pData</em> buffer, in bytes.</p> </dd></param>
        /// <param name = "dataRef"><dd> <p>A reference to a buffer that contains private state data. The method passes this buffer directly to the driver without validation. It is the responsibility of the driver to validate the data.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447750</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoContext::VideoProcessorSetOutputExtension([In] ID3D11VideoProcessor* pVideoProcessor,[In] const GUID* pExtensionGuid,[In] unsigned int DataSize,[In] void* pData)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorSetOutputExtension</unmanaged-short>
        public unsafe void VideoProcessorSetOutputExtension(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Guid extensionGuidRef, System.Int32 dataSize, System.IntPtr dataRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)videoProcessorRef_, &extensionGuidRef, dataSize, (void *)dataRef, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the current target rectangle for the video processor.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "enabled"><dd> <p>Receives the value <strong>TRUE</strong> if the target rectangle was explicitly set using the <strong>ID3D11VideoContext::VideoProcessorSetOutputTargetRect</strong> method. Receives the value <see cref = "SharpDX.Result.False"/> if the target rectangle was disabled or was never set.</p> </dd></param>
        /// <param name = "rectRef"><dd> <p>If <em>Enabled</em> receives the value <strong>TRUE</strong>, this parameter receives the target rectangle. Otherwise, this parameter is ignored.  </p> </dd></param>
        /// <doc-id>hh447726</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorGetOutputTargetRect([In] ID3D11VideoProcessor* pVideoProcessor,[Out] BOOL* Enabled,[Out] RECT* pRect)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorGetOutputTargetRect</unmanaged-short>
        public unsafe void VideoProcessorGetOutputTargetRect(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, out SharpDX.Mathematics.Interop.RawBool enabled, out SharpDX.Mathematics.Interop.RawRectangle rectRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            enabled = default (SharpDX.Mathematics.Interop.RawBool);
            rectRef = default (SharpDX.Mathematics.Interop.RawRectangle);
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *rectRef_ = &rectRef)
                fixed (void *enabled_ = &enabled)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, enabled_, rectRef_, (*(void ***)this._nativePointer)[20]);
        }

        /// <summary>
        /// <p>Gets the current background color for the video processor.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "yCbCrRef"><dd> <p>Receives the value <strong>TRUE</strong> if the background color is a YCbCr color, or <strong><see cref = "SharpDX.Result.False"/></strong> if the background color is an RGB color.</p> </dd></param>
        /// <param name = "colorRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoColor"/></strong> structure. The method fills in the structure with the background color.</p> </dd></param>
        /// <doc-id>hh447721</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorGetOutputBackgroundColor([In] ID3D11VideoProcessor* pVideoProcessor,[Out] BOOL* pYCbCr,[Out] D3D11_VIDEO_COLOR* pColor)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorGetOutputBackgroundColor</unmanaged-short>
        public unsafe void VideoProcessorGetOutputBackgroundColor(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, out SharpDX.Mathematics.Interop.RawBool yCbCrRef, out SharpDX.Direct3D11.VideoColor colorRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            yCbCrRef = default (SharpDX.Mathematics.Interop.RawBool);
            colorRef = default (SharpDX.Direct3D11.VideoColor);
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *colorRef_ = &colorRef)
                fixed (void *yCbCrRef_ = &yCbCrRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, yCbCrRef_, colorRef_, (*(void ***)this._nativePointer)[21]);
        }

        /// <summary>
        /// <p>Gets the current output color space for the video processor.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "colorSpaceRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorColorSpace"/></strong> structure. The method fills in the structure with the output color space.</p> </dd></param>
        /// <doc-id>hh447722</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorGetOutputColorSpace([In] ID3D11VideoProcessor* pVideoProcessor,[Out] D3D11_VIDEO_PROCESSOR_COLOR_SPACE* pColorSpace)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorGetOutputColorSpace</unmanaged-short>
        public unsafe void VideoProcessorGetOutputColorSpace(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, out SharpDX.Direct3D11.VideoProcessorColorSpace colorSpaceRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            colorSpaceRef = default (SharpDX.Direct3D11.VideoProcessorColorSpace);
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *colorSpaceRef_ = &colorSpaceRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, colorSpaceRef_, (*(void ***)this._nativePointer)[22]);
        }

        /// <summary>
        /// <p>Gets the current alpha fill mode for the video processor.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "alphaFillModeRef"><dd> <p>Receives the alpha fill mode, as a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorAlphaFillMode"/></strong> value.</p> </dd></param>
        /// <param name = "streamIndexRef"><dd> <p>If the alpha fill mode is <strong>D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE_SOURCE_STREAM</strong>, this parameter receives the zero-based index of an input stream. The input stream provides the alpha values for the alpha fill.</p> </dd></param>
        /// <doc-id>hh447720</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorGetOutputAlphaFillMode([In] ID3D11VideoProcessor* pVideoProcessor,[Out] D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE* pAlphaFillMode,[Out] unsigned int* pStreamIndex)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorGetOutputAlphaFillMode</unmanaged-short>
        public unsafe void VideoProcessorGetOutputAlphaFillMode(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, out SharpDX.Direct3D11.VideoProcessorAlphaFillMode alphaFillModeRef, out System.Int32 streamIndexRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *streamIndexRef_ = &streamIndexRef)
                fixed (void *alphaFillModeRef_ = &alphaFillModeRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, alphaFillModeRef_, streamIndexRef_, (*(void ***)this._nativePointer)[23]);
        }

        /// <summary>
        /// <p>Gets the current level of downsampling that is performed by the video processor.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "enabledRef"><dd> <p>Receives the value <strong>TRUE</strong> if downsampling was explicitly enabled using the <strong>ID3D11VideoContext::VideoProcessorSetOutputConstriction</strong> method. Receives the value <strong><see cref = "SharpDX.Result.False"/></strong> if the downsampling was disabled or was never set.</p> </dd></param>
        /// <param name = "sizeRef"><dd> <p>If <em>Enabled</em> receives the value <strong>TRUE</strong>, this parameter receives the downsampling size. Otherwise, this parameter is ignored.</p> </dd></param>
        /// <doc-id>hh447723</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorGetOutputConstriction([In] ID3D11VideoProcessor* pVideoProcessor,[Out] BOOL* pEnabled,[Out] SIZE* pSize)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorGetOutputConstriction</unmanaged-short>
        public unsafe void VideoProcessorGetOutputConstriction(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, out SharpDX.Mathematics.Interop.RawBool enabledRef, out SharpDX.Size2 sizeRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            enabledRef = default (SharpDX.Mathematics.Interop.RawBool);
            sizeRef = default (SharpDX.Size2);
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *sizeRef_ = &sizeRef)
                fixed (void *enabledRef_ = &enabledRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, enabledRef_, sizeRef_, (*(void ***)this._nativePointer)[24]);
        }

        /// <summary>
        /// <p>Queries whether the video processor produces stereo video frames.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "enabledRef"><dd> <p>Receives the value <strong>TRUE</strong> if stereo output is enabled, or <strong><see cref = "SharpDX.Result.False"/></strong> otherwise.</p> </dd></param>
        /// <doc-id>hh447725</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorGetOutputStereoMode([In] ID3D11VideoProcessor* pVideoProcessor,[Out] BOOL* pEnabled)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorGetOutputStereoMode</unmanaged-short>
        public unsafe void VideoProcessorGetOutputStereoMode(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, out SharpDX.Mathematics.Interop.RawBool enabledRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            enabledRef = default (SharpDX.Mathematics.Interop.RawBool);
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *enabledRef_ = &enabledRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, enabledRef_, (*(void ***)this._nativePointer)[25]);
        }

        /// <summary>
        /// <p>Gets private state data from the video processor.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "extensionGuidRef"><dd> <p>A reference to a <see cref = "System.Guid"/> that identifies the state. The meaning of this <see cref = "System.Guid"/> is defined by the graphics driver.</p> </dd></param>
        /// <param name = "dataSize"><dd> <p>The size of the <em>pData</em> buffer, in bytes.</p> </dd></param>
        /// <param name = "dataRef"><dd> <p>A reference to a buffer that receives the private state data. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447724</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoContext::VideoProcessorGetOutputExtension([In] ID3D11VideoProcessor* pVideoProcessor,[In] const GUID* pExtensionGuid,[In] unsigned int DataSize,[Out, Buffer] void* pData)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorGetOutputExtension</unmanaged-short>
        public unsafe void VideoProcessorGetOutputExtension(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Guid extensionGuidRef, System.Int32 dataSize, System.IntPtr dataRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)videoProcessorRef_, &extensionGuidRef, dataSize, (void *)dataRef, (*(void ***)this._nativePointer)[26]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies whether an input stream on the video processor contains interlaced or progressive frames.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "frameFormat"><dd> <p>A <strong><see cref = "SharpDX.Direct3D11.VideoFrameFormat"/></strong> value that specifies the interlacing.</p> </dd></param>
        /// <doc-id>hh447759</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorSetStreamFrameFormat([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[In] D3D11_VIDEO_FRAME_FORMAT FrameFormat)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorSetStreamFrameFormat</unmanaged-short>
        public unsafe void VideoProcessorSetStreamFrameFormat(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, SharpDX.Direct3D11.VideoFrameFormat frameFormat)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, streamIndex, unchecked ((System.Int32)frameFormat), (*(void ***)this._nativePointer)[27]);
        }

        /// <summary>
        /// <p>Sets the color space for an input stream on the video processor.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "colorSpaceRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorColorSpace"/></strong> structure that specifies the color space.</p> </dd></param>
        /// <doc-id>hh447755</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorSetStreamColorSpace([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[In] const D3D11_VIDEO_PROCESSOR_COLOR_SPACE* pColorSpace)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorSetStreamColorSpace</unmanaged-short>
        public unsafe void VideoProcessorSetStreamColorSpace(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, SharpDX.Direct3D11.VideoProcessorColorSpace colorSpaceRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, streamIndex, &colorSpaceRef, (*(void ***)this._nativePointer)[28]);
        }

        /// <summary>
        /// <p>Sets the rate at which the video processor produces output frames for an input stream.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "outputRate"><dd> <p>The output rate, specified as a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorOutputRate"/></strong> value.</p> </dd></param>
        /// <param name = "repeatFrame"><dd> <p>Specifies how the driver performs frame-rate conversion, if required.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>TRUE</strong></dt> </dl> </td><td> <p>Repeat frames.</p> </td></tr> <tr><td><dl> <dt><strong><see cref = "SharpDX.Result.False"/></strong></dt> </dl> </td><td> <p>Interpolate frames.</p> </td></tr> </table> <p>?</p> </dd></param>
        /// <param name = "customRateRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.DXGI.Rational"/></strong> structure. If <em>OutputRate</em> is <strong>D3D11_VIDEO_PROCESSOR_OUTPUT_RATE_CUSTOM</strong>,  this parameter specifies the exact output rate. Otherwise, this parameter is ignored and can be <strong><c>null</c></strong>.</p> </dd></param>
        /// <remarks>
        /// <p>The standard output rates are normal frame-rate (<strong>D3D11_VIDEO_PROCESSOR_OUTPUT_RATE_NORMAL</strong>) and half frame-rate (<strong>D3D11_VIDEO_PROCESSOR_OUTPUT_RATE_HALF</strong>). In addition, the driver might support custom rates  for rate conversion or inverse telecine. To get the list of custom rates, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCustomRate</strong>.</p><p>Depending on the output rate, the driver might need to convert the frame rate. If so, the value of <em>RepeatFrame</em> controls whether the driver creates interpolated frames or simply repeats input frames.</p>
        /// </remarks>
        /// <doc-id>hh447761</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorSetStreamOutputRate([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[In] D3D11_VIDEO_PROCESSOR_OUTPUT_RATE OutputRate,[In] BOOL RepeatFrame,[In, Optional] const DXGI_RATIONAL* pCustomRate)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorSetStreamOutputRate</unmanaged-short>
        public unsafe void VideoProcessorSetStreamOutputRate(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, SharpDX.Direct3D11.VideoProcessorOutputRate outputRate, SharpDX.Mathematics.Interop.RawBool repeatFrame, SharpDX.DXGI.Rational? customRateRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            SharpDX.DXGI.Rational customRateRef_;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            if (customRateRef != null)
                customRateRef_ = customRateRef.Value;
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid0(this._nativePointer, (void *)videoProcessorRef_, streamIndex, unchecked ((System.Int32)outputRate), repeatFrame, customRateRef == null ? (void *)0 : &customRateRef_, (*(void ***)this._nativePointer)[29]);
        }

        /// <summary>
        /// <p>Sets the source rectangle for an input stream on the video processor.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "enable"><dd> <p>Specifies whether to apply the source rectangle.</p> </dd></param>
        /// <param name = "rectRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure that specifies the source rectangle. If <em>Enable</em> is <strong><see cref = "SharpDX.Result.False"/></strong>, this parameter is ignored.</p> </dd></param>
        /// <remarks>
        /// <p>The source rectangle is the portion of the input surface that is  blitted to the destination surface. The source rectangle is given in pixel coordinates, relative to the input surface.</p><p>If this method is never called, or if the <em>Enable</em> parameter is <strong><see cref = "SharpDX.Result.False"/></strong>, the video processor reads from the entire input surface.</p>
        /// </remarks>
        /// <doc-id>hh447764</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorSetStreamSourceRect([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[In] BOOL Enable,[In, Optional] const RECT* pRect)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorSetStreamSourceRect</unmanaged-short>
        public unsafe void VideoProcessorSetStreamSourceRect(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, SharpDX.Mathematics.Interop.RawBool enable, SharpDX.Mathematics.Interop.RawRectangle? rectRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawRectangle rectRef_;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            if (rectRef != null)
                rectRef_ = rectRef.Value;
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid0(this._nativePointer, (void *)videoProcessorRef_, streamIndex, enable, rectRef == null ? (void *)0 : &rectRef_, (*(void ***)this._nativePointer)[30]);
        }

        /// <summary>
        /// <p>Sets the destination rectangle for an input stream on the video processor.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "enable"><dd> <p>Specifies whether to apply the destination rectangle.</p> </dd></param>
        /// <param name = "rectRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure that specifies the destination rectangle. If <em>Enable</em> is <strong><see cref = "SharpDX.Result.False"/></strong>, this parameter is ignored.</p> </dd></param>
        /// <remarks>
        /// <p>The destination rectangle is the portion of the output surface that receives the blit for this stream. The destination rectangle is given in pixel coordinates, relative to the output surface.</p><p>The default destination rectangle is an empty rectangle (0, 0, 0, 0). If this method is never called, or if the <em>Enable</em> parameter is <strong><see cref = "SharpDX.Result.False"/></strong>, no data is written from this stream. </p>
        /// </remarks>
        /// <doc-id>hh447756</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorSetStreamDestRect([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[In] BOOL Enable,[In, Optional] const RECT* pRect)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorSetStreamDestRect</unmanaged-short>
        public unsafe void VideoProcessorSetStreamDestRect(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, SharpDX.Mathematics.Interop.RawBool enable, SharpDX.Mathematics.Interop.RawRectangle? rectRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawRectangle rectRef_;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            if (rectRef != null)
                rectRef_ = rectRef.Value;
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid0(this._nativePointer, (void *)videoProcessorRef_, streamIndex, enable, rectRef == null ? (void *)0 : &rectRef_, (*(void ***)this._nativePointer)[31]);
        }

        /// <summary>
        /// <p>Sets the planar alpha for an input stream on the video processor.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "enable"><dd> <p>Specifies whether alpha blending is enabled.</p> </dd></param>
        /// <param name = "alpha"><dd> <p>The planar alpha value. The value can range from 0.0 (transparent) to 1.0 (opaque).  If <em>Enable</em> is <strong><see cref = "SharpDX.Result.False"/></strong>, this parameter is ignored.</p> </dd></param>
        /// <remarks>
        /// <p>To use this feature, the driver must support stereo video, indicated by the  <strong>D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_ALHPA_STREAM</strong> capability flag. To query for this  capability, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong>.</p><p>Alpha blending is disabled by default.  </p><p>For each pixel, the destination color value is computed as follows:</p><p><code>Cd = Cs * (As * Ap * Ae) + Cd * (1.0 - As * Ap * Ae)</code></p><p>where:</p><ul> <li><code>Cd</code> = The color value of the destination pixel</li> <li><code>Cs</code> = The color value of the source pixel</li> <li><code>As</code> = The per-pixel source alpha</li> <li><code>Ap</code> = The planar alpha value</li> <li><code>Ae</code> = The palette-entry alpha value, or 1.0 (see Note)</li> </ul><strong>Note</strong>??Palette-entry alpha values apply only to palettized color formats, and only when the device supports the <strong>D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_ALPHA_PALETTE</strong> capability. Otherwise, this factor equals 1.0.?<p>The destination alpha value is computed according to the alpha fill mode. For more information, see <strong>ID3D11VideoContext::VideoProcessorSetOutputAlphaFillMode</strong>.</p>
        /// </remarks>
        /// <doc-id>hh447753</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorSetStreamAlpha([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[In] BOOL Enable,[In] float Alpha)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorSetStreamAlpha</unmanaged-short>
        public unsafe void VideoProcessorSetStreamAlpha(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, SharpDX.Mathematics.Interop.RawBool enable, System.Single alpha)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid0(this._nativePointer, (void *)videoProcessorRef_, streamIndex, enable, alpha, (*(void ***)this._nativePointer)[32]);
        }

        /// <summary>
        /// <p>Sets the color-palette entries for an input stream on the video processor.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "count"><dd> <p>The number of elements in the <em>pEntries</em> array.</p> </dd></param>
        /// <param name = "entriesRef"><dd> <p>A reference to an array of palette entries. For RGB streams, the palette entries use the <strong>DXGI_FORMAT_B8G8R8A8</strong> representation. For YCbCr streams, the palette entries use the <strong>DXGI_FORMAT_AYUV</strong> representation. The caller allocates the array.</p> </dd></param>
        /// <remarks>
        /// <p>This method applies only to  input streams that have a palettized color format. Palettized formats with 4 bits per pixel (bpp) use the first 16 entries in the list. Formats with 8 bpp use the first 256 entries.</p><p>If a pixel has a palette index greater than the number of entries, the device treats the pixel as white with opaque alpha. For full-range RGB, this value is (255, 255, 255, 255); for YCbCr the value is (255, 235, 128, 128).</p><p>If the driver does not report the <strong>D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_ALPHA_PALETTE</strong> capability flag, every palette entry must have an alpha value of 0xFF (opaque). To query for this capability, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong>.</p>
        /// </remarks>
        /// <doc-id>hh447762</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorSetStreamPalette([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[In] unsigned int Count,[In, Buffer, Optional] const unsigned int* pEntries)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorSetStreamPalette</unmanaged-short>
        public unsafe void VideoProcessorSetStreamPalette(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, System.Int32 count, System.Int32[] entriesRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *entriesRef_ = entriesRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, streamIndex, count, entriesRef_, (*(void ***)this._nativePointer)[33]);
        }

        /// <summary>
        /// <p>Sets the pixel aspect ratio for an input stream on the video processor.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "enable"><dd> <p>Specifies whether the <em>pSourceAspectRatio</em> and <em>pDestinationAspectRatio</em> parameters contain valid values. Otherwise, the pixel aspect ratios are unspecified.</p> </dd></param>
        /// <param name = "sourceAspectRatioRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.DXGI.Rational"/></strong> structure that contains the pixel aspect ratio of the source rectangle. If <em>Enable</em> is <strong><see cref = "SharpDX.Result.False"/></strong>, this parameter can be <strong><c>null</c></strong>.</p> </dd></param>
        /// <param name = "destinationAspectRatioRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.DXGI.Rational"/></strong> structure that contains the pixel aspect ratio of the destination rectangle. If <em>Enable</em> is <strong><see cref = "SharpDX.Result.False"/></strong>, this parameter can be <strong><c>null</c></strong>.</p> </dd></param>
        /// <remarks>
        /// <p>This function can only be called if the driver reports the     <strong>D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_PIXEL_ASPECT_RATIO</strong> capability. If this capability is not set, this function will have no effect.</p><p>Pixel aspect ratios of the form 0/n and n/0 are not valid.</p><p>The default pixel aspect ratio is 1:1 (square pixels).</p>
        /// </remarks>
        /// <doc-id>hh447763</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorSetStreamPixelAspectRatio([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[In] BOOL Enable,[In, Optional] const DXGI_RATIONAL* pSourceAspectRatio,[In, Optional] const DXGI_RATIONAL* pDestinationAspectRatio)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorSetStreamPixelAspectRatio</unmanaged-short>
        public unsafe void VideoProcessorSetStreamPixelAspectRatio(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, SharpDX.Mathematics.Interop.RawBool enable, SharpDX.DXGI.Rational? sourceAspectRatioRef, SharpDX.DXGI.Rational? destinationAspectRatioRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            SharpDX.DXGI.Rational sourceAspectRatioRef_;
            SharpDX.DXGI.Rational destinationAspectRatioRef_;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            if (sourceAspectRatioRef != null)
                sourceAspectRatioRef_ = sourceAspectRatioRef.Value;
            if (destinationAspectRatioRef != null)
                destinationAspectRatioRef_ = destinationAspectRatioRef.Value;
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid0(this._nativePointer, (void *)videoProcessorRef_, streamIndex, enable, sourceAspectRatioRef == null ? (void *)0 : &sourceAspectRatioRef_, destinationAspectRatioRef == null ? (void *)0 : &destinationAspectRatioRef_, (*(void ***)this._nativePointer)[34]);
        }

        /// <summary>
        /// <p>Sets the luma key for an input stream on the video processor.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "enable"><dd> <p>Specifies whether luma keying is enabled.</p> </dd></param>
        /// <param name = "lower"><dd> <p>The lower bound for the luma key. The valid range is [0?1]. If <em>Enable</em> is <strong><see cref = "SharpDX.Result.False"/></strong>, this parameter is ignored.</p> </dd></param>
        /// <param name = "upper"><dd> <p>The upper bound for the luma key. The valid range is [0?1]. If <em>Enable</em> is <strong><see cref = "SharpDX.Result.False"/></strong>, this parameter is ignored.</p> </dd></param>
        /// <remarks>
        /// <p>To use this feature, the driver must support luma keying, indicated by the <strong>D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_LUMA_KEY</strong> capability flag. To query for this capability, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong>. In addition, if the input format is RGB, the device must support the <strong>D3D11_VIDEO_PROCESSOR_FORMAT_CAPS_RGB_LUMA_KEY</strong> capability.</p><p>The values of <em>Lower</em> and <em>Upper</em> give the lower and upper bounds of the luma key, using a nominal range of [0...1]. Given a format with <em>n</em> bits per channel, these values are converted to luma values as follows:</p><p><code>val = f * ((1 &lt; &lt; n)-1)</code></p><p>Any pixel whose luma value falls within the upper and lower bounds (inclusive) is treated as transparent.</p><p>For example, if the pixel format uses 8-bit luma, the upper bound is calculated as follows:</p><p><code>BYTE Y = BYTE(max(min(1.0, Upper), 0.0) * 255.0)</code></p><p>Note that the value is clamped to the range [0...1] before multiplying by 255.</p>
        /// </remarks>
        /// <doc-id>hh447760</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorSetStreamLumaKey([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[In] BOOL Enable,[In] float Lower,[In] float Upper)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorSetStreamLumaKey</unmanaged-short>
        public unsafe void VideoProcessorSetStreamLumaKey(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, SharpDX.Mathematics.Interop.RawBool enable, System.Single lower, System.Single upper)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid0(this._nativePointer, (void *)videoProcessorRef_, streamIndex, enable, lower, upper, (*(void ***)this._nativePointer)[35]);
        }

        /// <summary>
        /// <p>Enables or disables stereo 3D video for an input stream on the video processor. In addition, this method specifies the layout of the video frames in memory.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "enable"><dd> <p>Specifies whether stereo 3D is enabled for this stream. If the value is <strong><see cref = "SharpDX.Result.False"/></strong>, the remaining parameters of this method are ignored.</p> </dd></param>
        /// <param name = "format"><dd> <p>Specifies the layout of the two stereo views in memory, as a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorStereoFormat"/></strong> value.</p> </dd></param>
        /// <param name = "leftViewFrame0"><dd> <p>If <strong>TRUE</strong>, frame 0 contains the left view. Otherwise, frame 0 contains the right view. </p> <p>This parameter is ignored for the following stereo formats:</p> <ul> <li><strong>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_MONO </strong></li> <li><strong>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_MONO_OFFSET</strong></li> </ul> </dd></param>
        /// <param name = "baseViewFrame0"><dd> <p>If <strong>TRUE</strong>, frame 0 contains the base view. Otherwise, frame 1 contains the base view.</p> <p>This parameter is ignored for the following stereo formats:</p> <ul> <li><strong>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_MONO </strong></li> <li><strong>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_MONO_OFFSET</strong></li> <li>When <strong>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_SEPARATE</strong> is used and the application wants to convert the stereo data to mono, it can either:<ul> <li>Specify the base view as a mono input.</li> <li>Specify both resources and allow the driver to do the conversion from the base view.  In this case, <strong><see cref = "SharpDX.Direct3D11.VideoProcessorStream"/>.hInputSurface</strong> is considered frame 0 and <strong><see cref = "SharpDX.Direct3D11.VideoProcessorStream"/>.hInputSurfaceRight</strong> is considered frame 1.</li> </ul> </li> </ul> </dd></param>
        /// <param name = "flipMode"><dd> <p>A flag from the  <strong><see cref = "SharpDX.Direct3D11.VideoProcessorStereoFlipMode"/></strong> enumeration, specifying whether one of the views is flipped.</p> </dd></param>
        /// <param name = "monoOffset"><dd> <p>For <strong>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_MONO_OFFSET</strong> format, this parameter specifies how to generate the left and right views:  </p> <ul> <li>If <em>MonoOffset</em> is positive, the right view is shifted to the right by that many pixels, and the left view is shifted to the left by the same amount. </li> <li>If <em>MonoOffset</em> is negative, the right view is shifted to the left by that many pixels, and the left view is shifted to right by the same amount.</li> </ul> <p>If <em>Format</em> is not <strong>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_MONO_OFFSET</strong>, this parameter must be zero.</p> </dd></param>
        /// <doc-id>hh447765</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorSetStreamStereoFormat([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[In] BOOL Enable,[In] D3D11_VIDEO_PROCESSOR_STEREO_FORMAT Format,[In] BOOL LeftViewFrame0,[In] BOOL BaseViewFrame0,[In] D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE FlipMode,[In] int MonoOffset)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorSetStreamStereoFormat</unmanaged-short>
        public unsafe void VideoProcessorSetStreamStereoFormat(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, SharpDX.Mathematics.Interop.RawBool enable, SharpDX.Direct3D11.VideoProcessorStereoFormat format, SharpDX.Mathematics.Interop.RawBool leftViewFrame0, SharpDX.Mathematics.Interop.RawBool baseViewFrame0, SharpDX.Direct3D11.VideoProcessorStereoFlipMode flipMode, System.Int32 monoOffset)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid0(this._nativePointer, (void *)videoProcessorRef_, streamIndex, enable, unchecked ((System.Int32)format), leftViewFrame0, baseViewFrame0, unchecked ((System.Int32)flipMode), monoOffset, (*(void ***)this._nativePointer)[36]);
        }

        /// <summary>
        /// <p>Enables or disables automatic processing features on the video processor.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "enable"><dd> <p>If <strong>TRUE</strong>, automatic processing features are enabled. If <strong><see cref = "SharpDX.Result.False"/></strong>, the driver disables any  extra video processing that it might be performing.</p> </dd></param>
        /// <remarks>
        /// <p>By default, the driver might perform certain processing tasks automatically during the video processor blit. This method enables the application to disable these extra video processing features. For example, if you provide your own pixel  shader for the video processor, you might want to disable the driver's automatic processing.</p>
        /// </remarks>
        /// <doc-id>hh447754</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorSetStreamAutoProcessingMode([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[In] BOOL Enable)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorSetStreamAutoProcessingMode</unmanaged-short>
        public unsafe void VideoProcessorSetStreamAutoProcessingMode(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, SharpDX.Mathematics.Interop.RawBool enable)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid0(this._nativePointer, (void *)videoProcessorRef_, streamIndex, enable, (*(void ***)this._nativePointer)[37]);
        }

        /// <summary>
        /// <p>Enables or disables an image filter for an input stream on the video processor.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "filter"><dd> <p>The filter, specified as a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorFilter"/></strong> value.</p> <p>To query which filters the driver supports, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong>.</p> </dd></param>
        /// <param name = "enable"><dd> <p>Specifies whether to enable the filter.</p> </dd></param>
        /// <param name = "level"><dd> <p>The filter level. If <em>Enable</em> is <strong><see cref = "SharpDX.Result.False"/></strong>, this parameter is ignored. </p> <p>To find the valid range of levels for a specified filter, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorFilterRange</strong>.</p> </dd></param>
        /// <doc-id>hh447758</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorSetStreamFilter([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[In] D3D11_VIDEO_PROCESSOR_FILTER Filter,[In] BOOL Enable,[In] int Level)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorSetStreamFilter</unmanaged-short>
        public unsafe void VideoProcessorSetStreamFilter(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, SharpDX.Direct3D11.VideoProcessorFilter filter, SharpDX.Mathematics.Interop.RawBool enable, System.Int32 level)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid0(this._nativePointer, (void *)videoProcessorRef_, streamIndex, unchecked ((System.Int32)filter), enable, level, (*(void ***)this._nativePointer)[38]);
        }

        /// <summary>
        /// <p>Sets a driver-specific state on a video processing stream.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "extensionGuidRef"><dd> <p>A reference to a <see cref = "System.Guid"/> that identifies the operation. The meaning of this <see cref = "System.Guid"/> is defined by the graphics driver.</p> </dd></param>
        /// <param name = "dataSize"><dd> <p>The size of the <em>pData</em> buffer, in bytes.</p> </dd></param>
        /// <param name = "dataRef"><dd> <p>A reference to a buffer that contains private state data. The method passes this buffer directly to the driver without validation. It is the responsibility of the driver to validate the data.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447757</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoContext::VideoProcessorSetStreamExtension([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[In] const GUID* pExtensionGuid,[In] unsigned int DataSize,[In] void* pData)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorSetStreamExtension</unmanaged-short>
        public unsafe void VideoProcessorSetStreamExtension(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, System.Guid extensionGuidRef, System.Int32 dataSize, System.IntPtr dataRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)videoProcessorRef_, streamIndex, &extensionGuidRef, dataSize, (void *)dataRef, (*(void ***)this._nativePointer)[39]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the format of an input stream on the video processor.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "frameFormatRef"><dd> <p>Receives a <strong><see cref = "SharpDX.Direct3D11.VideoFrameFormat"/></strong> value that specifies whether the stream contains interlaced or progressive frames.</p> </dd></param>
        /// <doc-id>hh447739</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorGetStreamFrameFormat([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[Out] D3D11_VIDEO_FRAME_FORMAT* pFrameFormat)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorGetStreamFrameFormat</unmanaged-short>
        public unsafe void VideoProcessorGetStreamFrameFormat(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, out SharpDX.Direct3D11.VideoFrameFormat frameFormatRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *frameFormatRef_ = &frameFormatRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, streamIndex, frameFormatRef_, (*(void ***)this._nativePointer)[40]);
        }

        /// <summary>
        /// <p>Gets the color space for an input stream of the video processor. </p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "colorSpaceRef"><dd> <p>Receives a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorColorSpace"/></strong> value that specifies the color space.</p> </dd></param>
        /// <doc-id>hh447731</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorGetStreamColorSpace([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[Out] D3D11_VIDEO_PROCESSOR_COLOR_SPACE* pColorSpace)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorGetStreamColorSpace</unmanaged-short>
        public unsafe void VideoProcessorGetStreamColorSpace(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, out SharpDX.Direct3D11.VideoProcessorColorSpace colorSpaceRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            colorSpaceRef = default (SharpDX.Direct3D11.VideoProcessorColorSpace);
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *colorSpaceRef_ = &colorSpaceRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, streamIndex, colorSpaceRef_, (*(void ***)this._nativePointer)[41]);
        }

        /// <summary>
        /// <p>Gets the rate at which the video processor produces output frames for an input stream. </p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "outputRateRef"><dd> <p>Receives a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorOutputRate"/></strong> value that specifies the output rate.</p> </dd></param>
        /// <param name = "repeatFrameRef"><dd> <p>Receives a Boolean value that specifies how the driver performs frame-rate conversion, if required. </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>TRUE</strong></dt> </dl> </td><td> <p>Repeat frames.</p> </td></tr> <tr><td><dl> <dt><strong><see cref = "SharpDX.Result.False"/></strong></dt> </dl> </td><td> <p>Interpolate frames.</p> </td></tr> </table> <p>?</p> </dd></param>
        /// <param name = "customRateRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.DXGI.Rational"/></strong> structure. If the output rate is <strong>D3D11_VIDEO_PROCESSOR_OUTPUT_RATE_CUSTOM</strong>, the method fills in this structure with the exact output rate. Otherwise, this parameter is ignored. </p> </dd></param>
        /// <doc-id>hh447741</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorGetStreamOutputRate([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[Out] D3D11_VIDEO_PROCESSOR_OUTPUT_RATE* pOutputRate,[Out] BOOL* pRepeatFrame,[Out] DXGI_RATIONAL* pCustomRate)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorGetStreamOutputRate</unmanaged-short>
        public unsafe void VideoProcessorGetStreamOutputRate(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, out SharpDX.Direct3D11.VideoProcessorOutputRate outputRateRef, out SharpDX.Mathematics.Interop.RawBool repeatFrameRef, out SharpDX.DXGI.Rational customRateRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            repeatFrameRef = default (SharpDX.Mathematics.Interop.RawBool);
            customRateRef = default (SharpDX.DXGI.Rational);
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *customRateRef_ = &customRateRef)
                fixed (void *repeatFrameRef_ = &repeatFrameRef)
                    fixed (void *outputRateRef_ = &outputRateRef)
                        SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, streamIndex, outputRateRef_, repeatFrameRef_, customRateRef_, (*(void ***)this._nativePointer)[42]);
        }

        /// <summary>
        /// <p>Gets the source rectangle for an input stream on the video processor. </p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "enabledRef"><dd> <p>Receives the value <strong>TRUE</strong> if the source rectangle is enabled, or <strong><see cref = "SharpDX.Result.False"/></strong> otherwise.</p> </dd></param>
        /// <param name = "rectRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure that receives the source rectangle.</p> </dd></param>
        /// <doc-id>hh447744</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorGetStreamSourceRect([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[Out] BOOL* pEnabled,[Out] RECT* pRect)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorGetStreamSourceRect</unmanaged-short>
        public unsafe void VideoProcessorGetStreamSourceRect(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, out SharpDX.Mathematics.Interop.RawBool enabledRef, out SharpDX.Mathematics.Interop.RawRectangle rectRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            enabledRef = default (SharpDX.Mathematics.Interop.RawBool);
            rectRef = default (SharpDX.Mathematics.Interop.RawRectangle);
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *rectRef_ = &rectRef)
                fixed (void *enabledRef_ = &enabledRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, streamIndex, enabledRef_, rectRef_, (*(void ***)this._nativePointer)[43]);
        }

        /// <summary>
        /// <p>Gets the destination rectangle for an input stream on the video processor. </p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "enabledRef"><dd> <p>Receives the value <strong>TRUE</strong> if the destination rectangle is enabled, or <strong><see cref = "SharpDX.Result.False"/></strong> otherwise.</p> </dd></param>
        /// <param name = "rectRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure that receives the destination rectangle.</p> </dd></param>
        /// <doc-id>hh447733</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorGetStreamDestRect([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[Out] BOOL* pEnabled,[Out] RECT* pRect)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorGetStreamDestRect</unmanaged-short>
        public unsafe void VideoProcessorGetStreamDestRect(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, out SharpDX.Mathematics.Interop.RawBool enabledRef, out SharpDX.Mathematics.Interop.RawRectangle rectRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            enabledRef = default (SharpDX.Mathematics.Interop.RawBool);
            rectRef = default (SharpDX.Mathematics.Interop.RawRectangle);
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *rectRef_ = &rectRef)
                fixed (void *enabledRef_ = &enabledRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, streamIndex, enabledRef_, rectRef_, (*(void ***)this._nativePointer)[44]);
        }

        /// <summary>
        /// <p>Gets the planar alpha for an input stream on the video processor. </p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "enabledRef"><dd> <p>Receives the value <strong>TRUE</strong> if planar alpha is enabled, or <strong><see cref = "SharpDX.Result.False"/></strong> otherwise.</p> </dd></param>
        /// <param name = "alphaRef"><dd> <p>Receives the planar alpha value. The value can range from 0.0 (transparent) to 1.0 (opaque).</p> </dd></param>
        /// <doc-id>hh447727</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorGetStreamAlpha([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[Out] BOOL* pEnabled,[Out] float* pAlpha)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorGetStreamAlpha</unmanaged-short>
        public unsafe void VideoProcessorGetStreamAlpha(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, out SharpDX.Mathematics.Interop.RawBool enabledRef, out System.Single alphaRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            enabledRef = default (SharpDX.Mathematics.Interop.RawBool);
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *alphaRef_ = &alphaRef)
                fixed (void *enabledRef_ = &enabledRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, streamIndex, enabledRef_, alphaRef_, (*(void ***)this._nativePointer)[45]);
        }

        /// <summary>
        /// <p>Gets the color-palette entries for an input stream on the video processor.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "count"><dd> <p>The number of entries in the <em>pEntries</em> array.</p> </dd></param>
        /// <param name = "entriesRef"><dd> <p>A reference to a <strong>UINT</strong> array allocated by the caller. The method fills the array with the palette entries. For RGB streams, the palette entries use the <strong>DXGI_FORMAT_B8G8R8A8</strong> representation. For YCbCr streams, the palette entries use the <strong>DXGI_FORMAT_AYUV</strong> representation.</p> </dd></param>
        /// <remarks>
        /// <p>This method applies only to input streams that have a palettized color format. Palettized formats with 4 bits per pixel (bpp) use 16 palette entries. Formats with 8 bpp use 256 entries.</p>
        /// </remarks>
        /// <doc-id>hh447742</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorGetStreamPalette([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[In] unsigned int Count,[Out, Buffer] unsigned int* pEntries)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorGetStreamPalette</unmanaged-short>
        public unsafe void VideoProcessorGetStreamPalette(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, System.Int32 count, System.Int32[] entriesRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *entriesRef_ = entriesRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, streamIndex, count, entriesRef_, (*(void ***)this._nativePointer)[46]);
        }

        /// <summary>
        /// <p>Gets the pixel aspect ratio for an input stream on the video processor. </p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "enabledRef"><dd> <p>Receives the value <strong>TRUE</strong> if the pixel aspect ratio is specified. Otherwise, receives the value <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd></param>
        /// <param name = "sourceAspectRatioRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.DXGI.Rational"/></strong> structure. If *<em>pEnabled</em> is <strong>TRUE</strong>, this parameter receives the pixel aspect ratio of the source rectangle.</p> </dd></param>
        /// <param name = "destinationAspectRatioRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.DXGI.Rational"/></strong> structure. If *<em>pEnabled</em> is <strong>TRUE</strong>, this parameter receives the pixel aspect ratio of the destination rectangle.</p> </dd></param>
        /// <remarks>
        /// <p>When the method returns, if <em>*pEnabled</em> is <strong>TRUE</strong>, the <em>pSourceAspectRatio</em> and <em>pDestinationAspectRatio</em> parameters contain the pixel aspect ratios. Otherwise, the default pixel aspect ratio is 1:1 (square pixels).</p>
        /// </remarks>
        /// <doc-id>hh447743</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorGetStreamPixelAspectRatio([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[Out] BOOL* pEnabled,[Out] DXGI_RATIONAL* pSourceAspectRatio,[Out] DXGI_RATIONAL* pDestinationAspectRatio)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorGetStreamPixelAspectRatio</unmanaged-short>
        public unsafe void VideoProcessorGetStreamPixelAspectRatio(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, out SharpDX.Mathematics.Interop.RawBool enabledRef, out SharpDX.DXGI.Rational sourceAspectRatioRef, out SharpDX.DXGI.Rational destinationAspectRatioRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            enabledRef = default (SharpDX.Mathematics.Interop.RawBool);
            sourceAspectRatioRef = default (SharpDX.DXGI.Rational);
            destinationAspectRatioRef = default (SharpDX.DXGI.Rational);
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *destinationAspectRatioRef_ = &destinationAspectRatioRef)
                fixed (void *sourceAspectRatioRef_ = &sourceAspectRatioRef)
                    fixed (void *enabledRef_ = &enabledRef)
                        SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, streamIndex, enabledRef_, sourceAspectRatioRef_, destinationAspectRatioRef_, (*(void ***)this._nativePointer)[47]);
        }

        /// <summary>
        /// <p>Gets the luma key for an input stream of the video processor. </p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "enabledRef"><dd> <p>Receives the value <strong>TRUE</strong> if luma keying is enabled, or <strong><see cref = "SharpDX.Result.False"/></strong> otherwise.</p> </dd></param>
        /// <param name = "lowerRef"><dd> <p>Receives the lower bound for the luma key. The valid range is [0?1]. </p> </dd></param>
        /// <param name = "upperRef"><dd> <p>Receives the upper bound for the luma key. The valid range is [0?1]. </p> </dd></param>
        /// <doc-id>hh447740</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorGetStreamLumaKey([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[Out] BOOL* pEnabled,[Out] float* pLower,[Out] float* pUpper)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorGetStreamLumaKey</unmanaged-short>
        public unsafe void VideoProcessorGetStreamLumaKey(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, out SharpDX.Mathematics.Interop.RawBool enabledRef, out System.Single lowerRef, out System.Single upperRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            enabledRef = default (SharpDX.Mathematics.Interop.RawBool);
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *upperRef_ = &upperRef)
                fixed (void *lowerRef_ = &lowerRef)
                    fixed (void *enabledRef_ = &enabledRef)
                        SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, streamIndex, enabledRef_, lowerRef_, upperRef_, (*(void ***)this._nativePointer)[48]);
        }

        /// <summary>
        /// <p>Gets the stereo 3D format for an input stream on the video processor</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "enableRef"><dd> <p>Receives the value <strong>TRUE</strong> if stereo 3D is enabled for this stream, or <strong><see cref = "SharpDX.Result.False"/></strong> otherwise. If the value is <strong><see cref = "SharpDX.Result.False"/></strong>, ignore the remaining parameters.</p> </dd></param>
        /// <param name = "formatRef"><dd> <p>Receives a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorStereoFormat"/></strong> value that specifies the layout of the two stereo views in memory.</p> </dd></param>
        /// <param name = "leftViewFrame0Ref"><dd> <p>Receives a Boolean value.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>TRUE</strong></dt> </dl> </td><td> <p>Frame 0 contains the left view.</p> </td></tr> <tr><td><dl> <dt><strong><see cref = "SharpDX.Result.False"/></strong></dt> </dl> </td><td> <p>Frame 0 contains the right view.</p> </td></tr> </table> <p>?</p> </dd></param>
        /// <param name = "baseViewFrame0Ref"><dd> <p>Receives a Boolean value.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>TRUE</strong></dt> </dl> </td><td> <p>Frame 0 contains the base view.</p> </td></tr> <tr><td><dl> <dt><strong><see cref = "SharpDX.Result.False"/></strong></dt> </dl> </td><td> <p>Frame 1 contains the base view.</p> </td></tr> </table> <p>?</p> </dd></param>
        /// <param name = "flipModeRef"><dd> <p>Receives a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorStereoFlipMode"/></strong> value. This value specifies whether one of the views is flipped.</p> </dd></param>
        /// <param name = "monoOffset"><dd> <p>Receives the pixel offset used for <strong>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_MONO_OFFSET</strong> format. This parameter is ignored for other stereo formats.</p> </dd></param>
        /// <doc-id>hh447745</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorGetStreamStereoFormat([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[Out] BOOL* pEnable,[Out] D3D11_VIDEO_PROCESSOR_STEREO_FORMAT* pFormat,[Out] BOOL* pLeftViewFrame0,[Out] BOOL* pBaseViewFrame0,[Out] D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE* pFlipMode,[Out] int* MonoOffset)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorGetStreamStereoFormat</unmanaged-short>
        public unsafe void VideoProcessorGetStreamStereoFormat(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, out SharpDX.Mathematics.Interop.RawBool enableRef, out SharpDX.Direct3D11.VideoProcessorStereoFormat formatRef, out SharpDX.Mathematics.Interop.RawBool leftViewFrame0Ref, out SharpDX.Mathematics.Interop.RawBool baseViewFrame0Ref, out SharpDX.Direct3D11.VideoProcessorStereoFlipMode flipModeRef, out System.Int32 monoOffset)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            enableRef = default (SharpDX.Mathematics.Interop.RawBool);
            leftViewFrame0Ref = default (SharpDX.Mathematics.Interop.RawBool);
            baseViewFrame0Ref = default (SharpDX.Mathematics.Interop.RawBool);
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *monoOffset_ = &monoOffset)
                fixed (void *flipModeRef_ = &flipModeRef)
                    fixed (void *baseViewFrame0Ref_ = &baseViewFrame0Ref)
                        fixed (void *leftViewFrame0Ref_ = &leftViewFrame0Ref)
                            fixed (void *formatRef_ = &formatRef)
                                fixed (void *enableRef_ = &enableRef)
                                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, streamIndex, enableRef_, formatRef_, leftViewFrame0Ref_, baseViewFrame0Ref_, flipModeRef_, monoOffset_, (*(void ***)this._nativePointer)[49]);
        }

        /// <summary>
        /// <p>Queries whether automatic processing features of the video processor are enabled.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "enabledRef"><dd> <p>Receives the value <strong>TRUE</strong> if automatic processing features are enabled, or <strong><see cref = "SharpDX.Result.False"/></strong> otherwise.</p> </dd></param>
        /// <remarks>
        /// <p>Automatic processing  refers to additional image processing that drivers might have performed on the image data prior to the application receiving the data.   </p>
        /// </remarks>
        /// <doc-id>hh447729</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorGetStreamAutoProcessingMode([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[Out] BOOL* pEnabled)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorGetStreamAutoProcessingMode</unmanaged-short>
        public unsafe void VideoProcessorGetStreamAutoProcessingMode(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, out SharpDX.Mathematics.Interop.RawBool enabledRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            enabledRef = default (SharpDX.Mathematics.Interop.RawBool);
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *enabledRef_ = &enabledRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, streamIndex, enabledRef_, (*(void ***)this._nativePointer)[50]);
        }

        /// <summary>
        /// <p>Gets the image filter settings for an input stream on the video processor.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "filter"><dd> <p>The filter to query, specified as a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorFilter"/></strong> value. </p> </dd></param>
        /// <param name = "enabledRef"><dd> <p>Receives the value <strong>TRUE</strong> if the image filter is enabled, or <strong><see cref = "SharpDX.Result.False"/></strong> otherwise.</p> </dd></param>
        /// <param name = "levelRef"><dd> <p>Receives the filter level.</p> </dd></param>
        /// <doc-id>hh447737</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorGetStreamFilter([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[In] D3D11_VIDEO_PROCESSOR_FILTER Filter,[Out] BOOL* pEnabled,[Out] int* pLevel)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorGetStreamFilter</unmanaged-short>
        public unsafe void VideoProcessorGetStreamFilter(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, SharpDX.Direct3D11.VideoProcessorFilter filter, out SharpDX.Mathematics.Interop.RawBool enabledRef, out System.Int32 levelRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            enabledRef = default (SharpDX.Mathematics.Interop.RawBool);
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *levelRef_ = &levelRef)
                fixed (void *enabledRef_ = &enabledRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, streamIndex, unchecked ((System.Int32)filter), enabledRef_, levelRef_, (*(void ***)this._nativePointer)[51]);
        }

        /// <summary>
        /// <p>Gets a driver-specific state for a video processing stream. </p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "extensionGuidRef"><dd> <p>A reference to a <see cref = "System.Guid"/> that identifies the state. The meaning of this <see cref = "System.Guid"/> is defined by the graphics driver.</p> </dd></param>
        /// <param name = "dataSize"><dd> <p>The size of the <em>pData</em> buffer, in bytes.</p> </dd></param>
        /// <param name = "dataRef"><dd> <p>A reference to a buffer that receives the private state data. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447735</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoContext::VideoProcessorGetStreamExtension([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[In] const GUID* pExtensionGuid,[In] unsigned int DataSize,[Out, Buffer] void* pData)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorGetStreamExtension</unmanaged-short>
        public unsafe void VideoProcessorGetStreamExtension(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, System.Guid extensionGuidRef, System.Int32 dataSize, System.IntPtr dataRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)videoProcessorRef_, streamIndex, &extensionGuidRef, dataSize, (void *)dataRef, (*(void ***)this._nativePointer)[52]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Performs a video processing operation on one or more input samples and writes the result to a Direct3D surface.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call the <strong>ID3D11VideoDevice::CreateVideoProcessor</strong> method.</p> </dd></param>
        /// <param name = "viewRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessorOutputView"/></strong> interface for the output surface. The output of the video processing operation will be written to this surface.</p> </dd></param>
        /// <param name = "outputFrame"><dd> <p>The frame number of the output video frame, indexed from zero. </p> </dd></param>
        /// <param name = "streamCount"><dd> <p>The number of input streams to process.</p> </dd></param>
        /// <param name = "streamsRef"><dd> <p>A reference to an array of <strong><see cref = "SharpDX.Direct3D11.VideoProcessorStream"/></strong> structures that contain information about the input streams. The caller allocates the array and fills in each structure. The number of elements in the array is given in the <em>StreamCount</em> parameter. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The maximum value of <em>StreamCount</em> is given in the <strong>MaxStreamStates</strong> member of the <strong><see cref = "SharpDX.Direct3D11.VideoProcessorCaps"/></strong> structure. The maximum number of streams that can be enabled at one time is given in the <strong>MaxInputStreams</strong> member of that structure. </p><p>If the output stereo mode is <strong>TRUE</strong>:</p><ul> <li>The output view must contain a texture array of two elements.</li> <li>At least one stereo stream must be specified.</li> <li>If multiple input streams are enabled, it is possible that one or more of the input streams may contain mono data.</li> </ul><p>Otherwise:</p><ul> <li>The output view must contain a single element.</li> <li>The stereo format cannot be <strong>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_MONO</strong> .</li> </ul><p>This function does not honor a D3D11 predicate that may have been set.</p><p>If the application uses <strong>D3D11 quries</strong>, this function may not be accounted for with <strong>D3D11_QUERY_EVENT</strong> and <strong>D3D11_QUERY_TIMESTAMP</strong> when using feature levels lower than 11.  <strong>D3D11_QUERY_PIPELINE_STATISTICS</strong> will not include this function for any feature level.</p>
        /// </remarks>
        /// <doc-id>hh447719</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoContext::VideoProcessorBlt([In] ID3D11VideoProcessor* pVideoProcessor,[In] ID3D11VideoProcessorOutputView* pView,[In] unsigned int OutputFrame,[In] unsigned int StreamCount,[In, Buffer] const D3D11_VIDEO_PROCESSOR_STREAM* pStreams)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorBlt</unmanaged-short>
        public unsafe void VideoProcessorBlt(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, SharpDX.Direct3D11.VideoProcessorOutputView viewRef, System.Int32 outputFrame, System.Int32 streamCount, SharpDX.Direct3D11.VideoProcessorStream[] streamsRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            System.IntPtr viewRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.VideoProcessorStream.__Native[] streamsRef_ = new SharpDX.Direct3D11.VideoProcessorStream.__Native[streamsRef.Length];
            SharpDX.Result __result__;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            viewRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessorOutputView>(viewRef);
            for (int i = 0; i < streamsRef.Length; ++i)
                streamsRef[i].__MarshalTo(ref (streamsRef_)[i]);
            fixed (void *_streamsRef = streamsRef_)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)videoProcessorRef_, (void *)viewRef_, outputFrame, streamCount, _streamsRef, (*(void ***)this._nativePointer)[53]);
            for (int i = 0; i < streamsRef.Length; ++i)
                streamsRef[i].__MarshalFree(ref (streamsRef_)[i]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Establishes the session key for a cryptographic session. </p>
        /// </summary>
        /// <param name = "cryptoSessionRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.CryptoSession"/></strong> interface of the cryptographic session.</p> </dd></param>
        /// <param name = "dataSize"><dd> <p>The size of the <em>pData</em> byte array, in bytes. </p> </dd></param>
        /// <param name = "dataRef"><dd> <p>A reference to a byte array that contains the encrypted session key. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The key exchange mechanism depends on the type of cryptographic session.</p><p>For RSA Encryption Scheme - Optimal Asymmetric Encryption Padding (RSAES-OAEP), the software decoder generates the secret key, encrypts the secret key by using the public key with RSAES-OAEP, and places the cipher text in the <em>pData</em> parameter. The actual size of the buffer for RSAES-OAEP is 256 bytes.</p>
        /// </remarks>
        /// <doc-id>hh447714</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoContext::NegotiateCryptoSessionKeyExchange([In] ID3D11CryptoSession* pCryptoSession,[In] unsigned int DataSize,[Out, Buffer] void* pData)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::NegotiateCryptoSessionKeyExchange</unmanaged-short>
        public unsafe void NegotiateCryptoSessionKeyExchange(SharpDX.Direct3D11.CryptoSession cryptoSessionRef, System.Int32 dataSize, System.IntPtr dataRef)
        {
            System.IntPtr cryptoSessionRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            cryptoSessionRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.CryptoSession>(cryptoSessionRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)cryptoSessionRef_, dataSize, (void *)dataRef, (*(void ***)this._nativePointer)[54]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Reads encrypted data from a protected surface. </p>
        /// </summary>
        /// <param name = "cryptoSessionRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.CryptoSession"/></strong> interface of the cryptographic session.</p> </dd></param>
        /// <param name = "srcSurfaceRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.Texture2D"/></strong> interface of the protected surface.</p> </dd></param>
        /// <param name = "dstSurfaceRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.Texture2D"/></strong> interface of the surface that receives the encrypted data.</p> </dd></param>
        /// <param name = "iVSize"><dd> <p>The size of the <em>pIV</em> buffer, in bytes.</p> </dd></param>
        /// <param name = "iVRef"><dd> <p>A reference to a buffer that receives the initialization vector (IV). The caller allocates this buffer, but the driver generates the IV. </p> <p>For 128-bit AES-CTR encryption, <em>pIV</em> points to a <strong><see cref = "SharpDX.Direct3D11.AesCtrIv"/></strong> structure. When the driver generates the first IV, it initializes the structure to a random number. For each subsequent IV, the driver simply increments the <strong>IV</strong> member of the structure, ensuring that the value always increases. The application can validate that the same IV is never used more than once with the same key pair.</p> </dd></param>
        /// <remarks>
        /// <p>Not all drivers support this method. To query the driver capabilities, call <strong>ID3D11VideoDevice::GetContentProtectionCaps</strong> and check for the <strong>D3D11_CONTENT_PROTECTION_CAPS_ENCRYPTED_READ_BACK</strong> flag in the <strong>Caps</strong> member of the <strong><see cref = "SharpDX.Direct3D11.VideoContentProtectionCaps"/></strong> structure.</p><p>Some drivers might require a separate key to decrypt the data that is read back. To check for this requirement, call <strong>GetContentProtectionCaps</strong> and check for the <strong>D3D11_CONTENT_PROTECTION_CAPS_ENCRYPTED_READ_BACK_KEY</strong> flag. If this flag is present, call <strong>ID3D11VideoContext::GetEncryptionBltKey</strong> to get the decryption key.</p><p>This method has the following limitations:</p><ul> <li>Reading back  sub-rectangles is not supported.</li> <li>Reading back  partially encrypted surfaces is not supported.</li> <li>The protected surface must be either an off-screen plain surface or a render target.</li> <li>The destination surface must be a D3D11_USAGE_STAGING resource.</li> <li>The protected surface cannot be multisampled.</li> <li>Stretching and colorspace conversion are not supported.</li> </ul><p> This function does not honor a D3D11 predicate that may have been set.</p><p> If the application uses <strong>D3D11 quries</strong>, this function may not be accounted for with <strong>D3D11_QUERY_EVENT</strong> and <strong>D3D11_QUERY_TIMESTAMP</strong> when using feature levels lower than 11.  <strong>D3D11_QUERY_PIPELINE_STATISTICS</strong> will not include this function for any feature level.</p>
        /// </remarks>
        /// <doc-id>hh447709</doc-id>
        /// <unmanaged>void ID3D11VideoContext::EncryptionBlt([In] ID3D11CryptoSession* pCryptoSession,[In] ID3D11Texture2D* pSrcSurface,[In] ID3D11Texture2D* pDstSurface,[In] unsigned int IVSize,[InOut, Buffer, Optional] void* pIV)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::EncryptionBlt</unmanaged-short>
        public unsafe void EncryptionBlt(SharpDX.Direct3D11.CryptoSession cryptoSessionRef, SharpDX.Direct3D11.Texture2D srcSurfaceRef, SharpDX.Direct3D11.Texture2D dstSurfaceRef, System.Int32 iVSize, System.IntPtr iVRef)
        {
            System.IntPtr cryptoSessionRef_ = System.IntPtr.Zero;
            System.IntPtr srcSurfaceRef_ = System.IntPtr.Zero;
            System.IntPtr dstSurfaceRef_ = System.IntPtr.Zero;
            cryptoSessionRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.CryptoSession>(cryptoSessionRef);
            srcSurfaceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Texture2D>(srcSurfaceRef);
            dstSurfaceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Texture2D>(dstSurfaceRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)cryptoSessionRef_, (void *)srcSurfaceRef_, (void *)dstSurfaceRef_, iVSize, (void *)iVRef, (*(void ***)this._nativePointer)[55]);
        }

        /// <summary>
        /// <p>Writes encrypted data to a protected surface.</p>
        /// </summary>
        /// <param name = "cryptoSessionRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.CryptoSession"/></strong> interface.</p> </dd></param>
        /// <param name = "srcSurfaceRef"><dd> <p>A reference to the surface that contains the source data.</p> </dd></param>
        /// <param name = "dstSurfaceRef"><dd> <p>A reference to the protected surface where the encrypted data is written.</p> </dd></param>
        /// <param name = "encryptedBlockInfoRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.EncryptedBlockInformation"/></strong> structure, or <strong><c>null</c></strong>.</p> <p>If the driver supports partially encrypted buffers,  <em>pEncryptedBlockInfo</em> indicates which portions of the buffer are encrypted.  If the entire surface is encrypted, set this parameter to <strong><c>null</c></strong>. </p> <p>To check whether the driver supports partially encrypted buffers, call <strong>ID3D11VideoDevice::GetContentProtectionCaps</strong> and check for the <strong>D3D11_CONTENT_PROTECTION_CAPS_PARTIAL_DECRYPTION </strong> capabilities flag. If the driver does not support partially encrypted buffers, set this parameter to <strong><c>null</c></strong>.</p> </dd></param>
        /// <param name = "contentKeySize"><dd> <p>The size of the encrypted content key, in bytes.</p> </dd></param>
        /// <param name = "contentKeyRef"><dd> <p>A reference to a buffer that contains a content encryption key, or <strong><c>null</c></strong>. To query whether the driver supports the use of content keys, call <strong>ID3D11VideoDevice::GetContentProtectionCaps</strong> and check for the <strong>D3D11_CONTENT_PROTECTION_CAPS_CONTENT_KEY</strong> capabilities flag. </p> <p>If the driver supports content keys, use the content key to encrypt the surface. Encrypt the content key using the session key, and place the  resulting cipher text in <em>pContentKey</em>. If the driver does not support content keys, use the session key to encrypt the surface and set <em>pContentKey</em> to <strong><c>null</c></strong>.</p> </dd></param>
        /// <param name = "iVSize"><dd> <p>The size of the <em>pIV</em> buffer, in bytes.</p> </dd></param>
        /// <param name = "iVRef"><dd> <p>A reference to a buffer that contains the initialization vector (IV). </p> <p>For 128-bit AES-CTR encryption, <em>pIV</em> points to a <strong><see cref = "SharpDX.Direct3D11.AesCtrIv"/></strong> structure. The caller allocates the structure and generates the IV. When you generate the first IV, initialize the structure to a random number. For each subsequent IV, simply increment the <strong>IV</strong> member of the structure, ensuring that the value always increases.  This procedure enables the driver to validate that the same IV is never used more than once with the same key pair.</p> <p>For other encryption types, a different structure might be used, or the encryption might not use an IV.</p> </dd></param>
        /// <remarks>
        /// <p>Not all hardware or drivers support this functionality for all cryptographic types. This function can only be called when the <strong>D3D11_CONTENT_PROTECTION_CAPS_DECRYPTION_BLT</strong> cap is reported.</p><p>This method does not support writing to sub-rectangles of the surface.</p><p>If the hardware and driver support a content key:</p><ul> <li>The data is encrypted by the caller using the content key.</li> <li>The content key is encrypted by the caller using the session key.</li> <li>The encrypted content key is passed to the driver.</li> </ul><p> Otherwise, the data is encrypted by the caller using the session key and <c>null</c> is passed as the content key.</p><p>If the driver and hardware support partially encrypted buffers, <em>pEncryptedBlockInfo</em> indicates which portions of the buffer are encrypted and which is not.  If the entire buffer is encrypted, <em>pEncryptedBlockinfo</em> should be <strong><c>null</c></strong>.</p><p>The <strong><see cref = "SharpDX.Direct3D11.EncryptedBlockInformation"/></strong> allows the application to indicate which bytes in the buffer are encrypted.  This is specified in bytes, so the application must ensure that the encrypted blocks match the GPU?s crypto block alignment.</p><p>This function does not honor a D3D11 predicate that may have been set.</p><p>If the application uses <strong>D3D11 quries</strong>, this function may not be accounted for with <strong>D3D11_QUERY_EVENT</strong> and <strong>D3D11_QUERY_TIMESTAMP</strong> when using feature levels lower than 11.  <strong>D3D11_QUERY_PIPELINE_STATISTICS</strong> will not include this function for any feature level.</p>
        /// </remarks>
        /// <doc-id>hh447708</doc-id>
        /// <unmanaged>void ID3D11VideoContext::DecryptionBlt([In] ID3D11CryptoSession* pCryptoSession,[In] ID3D11Texture2D* pSrcSurface,[In] ID3D11Texture2D* pDstSurface,[In, Optional] D3D11_ENCRYPTED_BLOCK_INFO* pEncryptedBlockInfo,[In] unsigned int ContentKeySize,[In, Buffer, Optional] const void* pContentKey,[In] unsigned int IVSize,[InOut, Buffer, Optional] void* pIV)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::DecryptionBlt</unmanaged-short>
        public unsafe void DecryptionBlt(SharpDX.Direct3D11.CryptoSession cryptoSessionRef, SharpDX.Direct3D11.Texture2D srcSurfaceRef, SharpDX.Direct3D11.Texture2D dstSurfaceRef, SharpDX.Direct3D11.EncryptedBlockInformation? encryptedBlockInfoRef, System.Int32 contentKeySize, System.IntPtr contentKeyRef, System.Int32 iVSize, System.IntPtr iVRef)
        {
            System.IntPtr cryptoSessionRef_ = System.IntPtr.Zero;
            System.IntPtr srcSurfaceRef_ = System.IntPtr.Zero;
            System.IntPtr dstSurfaceRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.EncryptedBlockInformation encryptedBlockInfoRef_;
            cryptoSessionRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.CryptoSession>(cryptoSessionRef);
            srcSurfaceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Texture2D>(srcSurfaceRef);
            dstSurfaceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Texture2D>(dstSurfaceRef);
            if (encryptedBlockInfoRef != null)
                encryptedBlockInfoRef_ = encryptedBlockInfoRef.Value;
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)cryptoSessionRef_, (void *)srcSurfaceRef_, (void *)dstSurfaceRef_, encryptedBlockInfoRef == null ? (void *)0 : &encryptedBlockInfoRef_, contentKeySize, (void *)contentKeyRef, iVSize, (void *)iVRef, (*(void ***)this._nativePointer)[56]);
        }

        /// <summary>
        /// <p>Gets a random number that can be used to refresh the session key. </p>
        /// </summary>
        /// <param name = "cryptoSessionRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.CryptoSession"/></strong> interface.</p> </dd></param>
        /// <param name = "randomNumberSize"><dd> <p>The size of the <em>pRandomNumber</em> array, in bytes. The size should match the size of the session key.</p> </dd></param>
        /// <param name = "randomNumberRef"><dd> <p>A reference to a byte array that receives a random number.</p> </dd></param>
        /// <remarks>
        /// <p>To generate a new session key, perform a bitwise <strong>XOR</strong> between the previous session key and the random number. The new session key does not take affect until the application calls <strong>ID3D11VideoContext::FinishSessionKeyRefresh</strong>.</p><p>To query whether the driver supports this method, call <strong>ID3D11VideoDevice::GetContentProtectionCaps</strong> and check for the <strong>D3D11_CONTENT_PROTECTION_CAPS_FRESHEN_SESSION_KEY</strong> capabilities flag.</p>
        /// </remarks>
        /// <doc-id>hh447717</doc-id>
        /// <unmanaged>void ID3D11VideoContext::StartSessionKeyRefresh([In] ID3D11CryptoSession* pCryptoSession,[In] unsigned int RandomNumberSize,[Out, Buffer] void* pRandomNumber)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::StartSessionKeyRefresh</unmanaged-short>
        public unsafe void StartSessionKeyRefresh(SharpDX.Direct3D11.CryptoSession cryptoSessionRef, System.Int32 randomNumberSize, System.IntPtr randomNumberRef)
        {
            System.IntPtr cryptoSessionRef_ = System.IntPtr.Zero;
            cryptoSessionRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.CryptoSession>(cryptoSessionRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)cryptoSessionRef_, randomNumberSize, (void *)randomNumberRef, (*(void ***)this._nativePointer)[57]);
        }

        /// <summary>
        /// <p>Switches to a new session key. </p>
        /// </summary>
        /// <param name = "cryptoSessionRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.CryptoSession"/></strong> interface.</p> </dd></param>
        /// <remarks>
        /// <p>This function can only be called when the <strong>D3D11_CONTENT_PROTECTION_CAPS_FRESHEN_SESSION_KEY</strong> cap is reported.</p><p>Before calling this method, call <strong>ID3D11VideoContext::StartSessionKeyRefresh</strong>. The <strong>StartSessionKeyRefresh</strong> method gets a random number from the driver, which is used to create a new session key. The new session key does not become active until the application calls <strong>FinishSessionKeyRefresh</strong>. After the application calls <strong>FinishSessionKeyRefresh</strong>, all protected surfaces are encrypted using the new session key. </p>
        /// </remarks>
        /// <doc-id>hh447710</doc-id>
        /// <unmanaged>void ID3D11VideoContext::FinishSessionKeyRefresh([In] ID3D11CryptoSession* pCryptoSession)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::FinishSessionKeyRefresh</unmanaged-short>
        public unsafe void FinishSessionKeyRefresh(SharpDX.Direct3D11.CryptoSession cryptoSessionRef)
        {
            System.IntPtr cryptoSessionRef_ = System.IntPtr.Zero;
            cryptoSessionRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.CryptoSession>(cryptoSessionRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)cryptoSessionRef_, (*(void ***)this._nativePointer)[58]);
        }

        /// <summary>
        /// <p>Gets the cryptographic key to decrypt the data returned by the <strong>ID3D11VideoContext::EncryptionBlt</strong> method.</p>
        /// </summary>
        /// <param name = "cryptoSessionRef">No documentation.</param>
        /// <param name = "keySize">No documentation.</param>
        /// <param name = "readbackKeyRef">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method applies only when the driver requires a separate content key for the <strong>EncryptionBlt</strong> method. For more information, see the Remarks for <strong>EncryptionBlt</strong>.</p><p>Each time this method is called, the driver generates a new key.</p><p>The <em>KeySize</em> should match the size of the session key.</p><p>The read back key is encrypted by the driver/hardware using the session key. </p>
        /// </remarks>
        /// <doc-id>hh447712</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoContext::GetEncryptionBltKey([In] ID3D11CryptoSession* pCryptoSession,[In] unsigned int KeySize,[Out, Buffer] void* pReadbackKey)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::GetEncryptionBltKey</unmanaged-short>
        public unsafe void GetEncryptionBltKey(SharpDX.Direct3D11.CryptoSession cryptoSessionRef, System.Int32 keySize, System.IntPtr readbackKeyRef)
        {
            System.IntPtr cryptoSessionRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            cryptoSessionRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.CryptoSession>(cryptoSessionRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)cryptoSessionRef_, keySize, (void *)readbackKeyRef, (*(void ***)this._nativePointer)[59]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Establishes a session key for an authenticated channel. </p>
        /// </summary>
        /// <param name = "channelRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.AuthenticatedChannel"/></strong> interface.  This method will fail if the channel type is    <strong>D3D11_AUTHENTICATED_CHANNEL_D3D11</strong>, because the Direct3D11 channel does not support authentication.</p> </dd></param>
        /// <param name = "dataSize"><dd> <p>The size of the data in the <em>pData</em> array, in bytes.</p> </dd></param>
        /// <param name = "dataRef"><dd> <p>A reference to a byte array that contains the encrypted session key. The buffer must contain 256 bytes of data, encrypted using RSA Encryption Scheme - Optimal Asymmetric Encryption Padding (RSAES-OAEP).</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method will fail if the channel type is    <strong>D3D11_AUTHENTICATED_CHANNEL_D3D11</strong>, because the Direct3D11 channel does not support authentication.</p>
        /// </remarks>
        /// <doc-id>hh447713</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoContext::NegotiateAuthenticatedChannelKeyExchange([In] ID3D11AuthenticatedChannel* pChannel,[In] unsigned int DataSize,[Out, Buffer] void* pData)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::NegotiateAuthenticatedChannelKeyExchange</unmanaged-short>
        public unsafe void NegotiateAuthenticatedChannelKeyExchange(SharpDX.Direct3D11.AuthenticatedChannel channelRef, System.Int32 dataSize, System.IntPtr dataRef)
        {
            System.IntPtr channelRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            channelRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.AuthenticatedChannel>(channelRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)channelRef_, dataSize, (void *)dataRef, (*(void ***)this._nativePointer)[60]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sends a query to an authenticated channel. </p>
        /// </summary>
        /// <param name = "channelRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.AuthenticatedChannel"/></strong> interface.</p> </dd></param>
        /// <param name = "inputSize"><dd> <p>The size of the <em>pInput</em> array, in bytes.</p> </dd></param>
        /// <param name = "inputRef"><dd> <p>A reference to a byte array that contains input data for the query. This array always starts with a <strong><see cref = "SharpDX.Direct3D11.AuthenticatedQueryInput"/></strong> structure. The <strong>QueryType</strong> member of the structure specifies the query and defines the meaning of the rest of the array.</p> </dd></param>
        /// <param name = "outputSize"><dd> <p>The size of the <em>pOutput</em> array, in bytes.</p> </dd></param>
        /// <param name = "outputRef"><dd> <p>A reference to a byte array that receives the result of the query. This array always starts with a <strong><see cref = "SharpDX.Direct3D11.AuthenticatedQueryOutput"/></strong> structure. The meaning of the rest of the array depends on the query.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447715</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoContext::QueryAuthenticatedChannel([In] ID3D11AuthenticatedChannel* pChannel,[In] unsigned int InputSize,[In, Buffer] const void* pInput,[In] unsigned int OutputSize,[Out, Buffer] void* pOutput)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::QueryAuthenticatedChannel</unmanaged-short>
        public unsafe void QueryAuthenticatedChannel(SharpDX.Direct3D11.AuthenticatedChannel channelRef, System.Int32 inputSize, System.IntPtr inputRef, System.Int32 outputSize, System.IntPtr outputRef)
        {
            System.IntPtr channelRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            channelRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.AuthenticatedChannel>(channelRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)channelRef_, inputSize, (void *)inputRef, outputSize, (void *)outputRef, (*(void ***)this._nativePointer)[61]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sends a configuration command to an authenticated channel.</p>
        /// </summary>
        /// <param name = "channelRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.AuthenticatedChannel"/></strong> interface.</p> </dd></param>
        /// <param name = "inputSize"><dd> <p>The size of the <em>pInput</em> array, in bytes.</p> </dd></param>
        /// <param name = "inputRef"><dd> <p>A reference to a byte array that contains input data for the command. This buffer always starts with a <strong><see cref = "SharpDX.Direct3D11.AuthenticatedConfigureInput"/></strong> structure. The <strong>ConfigureType</strong> member of the structure specifies the command and defines the meaning of the rest of the buffer.</p> </dd></param>
        /// <param name = "outputRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.AuthenticatedConfigureOutput"/></strong> structure that receives the response to the command.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447704</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoContext::ConfigureAuthenticatedChannel([In] ID3D11AuthenticatedChannel* pChannel,[In] unsigned int InputSize,[In, Buffer] const void* pInput,[Out] D3D11_AUTHENTICATED_CONFIGURE_OUTPUT* pOutput)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::ConfigureAuthenticatedChannel</unmanaged-short>
        public unsafe void ConfigureAuthenticatedChannel(SharpDX.Direct3D11.AuthenticatedChannel channelRef, System.Int32 inputSize, System.IntPtr inputRef, out SharpDX.Direct3D11.AuthenticatedConfigureOutput outputRef)
        {
            System.IntPtr channelRef_ = System.IntPtr.Zero;
            SharpDX.Direct3D11.AuthenticatedConfigureOutput.__Native outputRef_ = default (SharpDX.Direct3D11.AuthenticatedConfigureOutput.__Native);
            outputRef = default (SharpDX.Direct3D11.AuthenticatedConfigureOutput);
            SharpDX.Result __result__;
            channelRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.AuthenticatedChannel>(channelRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)channelRef_, inputSize, (void *)inputRef, &outputRef_, (*(void ***)this._nativePointer)[62]);
            outputRef.__MarshalFrom(ref outputRef_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the stream rotation for an input stream on the video processor.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "enable"><dd> <p>Specifies if the stream is to be rotated in a clockwise orientation. </p> </dd></param>
        /// <param name = "rotation"><dd> <p>Specifies the rotation of the stream.</p> </dd></param>
        /// <remarks>
        /// <p>This is an optional state and the application should only use it if    <strong>D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_ROTATION</strong> is reported in  <strong><see cref = "SharpDX.Direct3D11.VideoProcessorCaps"/>.FeatureCaps</strong>.</p><p>The stream source rectangle will be specified in the pre-rotation coordinates (typically landscape) and the stream destination rectangle will be specified in the post-rotation coordinates (typically portrait).   The application must update the stream destination rectangle correctly when using a rotation value other than 0? and 180?.</p>
        /// </remarks>
        /// <doc-id>jj160517</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorSetStreamRotation([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[In] BOOL Enable,[In] D3D11_VIDEO_PROCESSOR_ROTATION Rotation)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorSetStreamRotation</unmanaged-short>
        public unsafe void VideoProcessorSetStreamRotation(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, SharpDX.Mathematics.Interop.RawBool enable, SharpDX.Direct3D11.VideoProcessorRotation rotation)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid0(this._nativePointer, (void *)videoProcessorRef_, streamIndex, enable, unchecked ((System.Int32)rotation), (*(void ***)this._nativePointer)[63]);
        }

        /// <summary>
        /// <p>Gets the stream rotation  for an input stream on the video processor.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessor</strong>.</p> </dd></param>
        /// <param name = "streamIndex"><dd> <p>The zero-based index of the input stream. To get the maximum number of streams, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>MaxStreamStates</strong> structure member.</p> </dd></param>
        /// <param name = "enableRef"><dd> <p>Specifies if the stream is rotated. </p> </dd></param>
        /// <param name = "rotationRef"><dd> <p>Specifies the rotation of the stream in a clockwise orientation.</p> </dd></param>
        /// <doc-id>jj160516</doc-id>
        /// <unmanaged>void ID3D11VideoContext::VideoProcessorGetStreamRotation([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[Out] BOOL* pEnable,[Out] D3D11_VIDEO_PROCESSOR_ROTATION* pRotation)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext::VideoProcessorGetStreamRotation</unmanaged-short>
        public unsafe void VideoProcessorGetStreamRotation(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, out SharpDX.Mathematics.Interop.RawBool enableRef, out SharpDX.Direct3D11.VideoProcessorRotation rotationRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            enableRef = default (SharpDX.Mathematics.Interop.RawBool);
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *rotationRef_ = &rotationRef)
                fixed (void *enableRef_ = &enableRef)
                    SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, streamIndex, enableRef_, rotationRef_, (*(void ***)this._nativePointer)[64]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("A7F026DA-A5F8-4487-A564-15E34357651E")]
    public partial class VideoContext1 : SharpDX.Direct3D11.VideoContext
    {
        public VideoContext1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator VideoContext1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new VideoContext1(nativePtr);
        /// <summary>
        /// <p>Submits one or more buffers for decoding.</p>
        /// </summary>
        /// <param name = "decoderRef"><dd>  <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoDecoder"/></strong> interface. To get this reference, call the <strong>ID3D11VideoDevice::CreateVideoDecoder</strong> method.</p> </dd></param>
        /// <param name = "numBuffers"><dd>  <p>The number of buffers submitted for decoding.</p> </dd></param>
        /// <param name = "bufferDescRef"><dd>  <p>A reference to an array of <strong><see cref = "SharpDX.Direct3D11.VideoDecoderBufferDescription1"/></strong> structures. The <em>NumBuffers</em> parameter specifies the number of elements in the array. Each element in the array describes a compressed buffer for decoding.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <see cref = "SharpDX.Result"/> error code.</p></returns>
        /// <remarks>
        /// <p>This function does not honor any D3D11 predicate that may have been set. <strong><see cref = "SharpDX.Direct3D11.QueryDataPipelineStatistics"/></strong> will not include this function for any feature level.
        /// </p>
        /// </remarks>
        /// <doc-id>dn894131</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoContext1::SubmitDecoderBuffers1([In] ID3D11VideoDecoder* pDecoder,[In] unsigned int NumBuffers,[In, Buffer] const D3D11_VIDEO_DECODER_BUFFER_DESC1* pBufferDesc)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext1::SubmitDecoderBuffers1</unmanaged-short>
        public unsafe void SubmitDecoderBuffers1(SharpDX.Direct3D11.VideoDecoder decoderRef, System.Int32 numBuffers, SharpDX.Direct3D11.VideoDecoderBufferDescription1[] bufferDescRef)
        {
            System.IntPtr decoderRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            decoderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoDecoder>(decoderRef);
            fixed (void *bufferDescRef_ = bufferDescRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)decoderRef_, numBuffers, bufferDescRef_, (*(void ***)this._nativePointer)[65]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Allows the driver to return IHV specific information used when initializing the new hardware key.</p>
        /// </summary>
        /// <param name = "cryptoSessionRef"><dd>  <p>A reference to the <see cref = "SharpDX.Direct3D11.CryptoSession"/> interface.  To get this reference, call <strong>ID3D11VideoDevice1::CreateCryptoSession</strong>.</p> </dd></param>
        /// <param name = "privateInputSize"><dd>  <p>The size of the memory referenced by the <em>pPrivateInputData</em> parameter.</p> </dd></param>
        /// <param name = "privatInputDataRef"><dd>  <p>The private input data. The contents of this parameter is defined by the implementation of the secure execution environment. It may contain data about the license or about the stream properties.</p> </dd></param>
        /// <param name = "privateOutputDataRef"><dd>  <p>A reference to the private output data. The return data is defined by the implementation of the secure execution environment. It may contain graphics-specific data to be associated with the underlying hardware key.</p> </dd></param>
        /// <returns><p>This method returns one of the following error codes.</p><table> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>The operation completed successfully.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>There is insufficient memory to complete the operation.</td></tr> </table><p>?</p></returns>
        /// <doc-id>dn894130</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoContext1::GetDataForNewHardwareKey([In] ID3D11CryptoSession* pCryptoSession,[In] unsigned int PrivateInputSize,[In, Buffer] const void* pPrivatInputData,[Out] unsigned longlong* pPrivateOutputData)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext1::GetDataForNewHardwareKey</unmanaged-short>
        public unsafe void GetDataForNewHardwareKey(SharpDX.Direct3D11.CryptoSession cryptoSessionRef, System.Int32 privateInputSize, System.IntPtr privatInputDataRef, out System.Int64 privateOutputDataRef)
        {
            System.IntPtr cryptoSessionRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            cryptoSessionRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.CryptoSession>(cryptoSessionRef);
            fixed (void *privateOutputDataRef_ = &privateOutputDataRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)cryptoSessionRef_, privateInputSize, (void *)privatInputDataRef, privateOutputDataRef_, (*(void ***)this._nativePointer)[66]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Checks the status of a crypto session.</p>
        /// </summary>
        /// <param name = "cryptoSessionRef"><dd>  <p>Specifies a <strong><see cref = "SharpDX.Direct3D11.CryptoSession"/></strong> for which status is checked.</p> </dd></param>
        /// <param name = "statusRef"><dd>  <p>A <see cref = "SharpDX.Direct3D11.CryptoSessionStatus"/> that is populated with the crypto session status upon completion.</p> </dd></param>
        /// <returns><p>This method returns one of the following error codes.</p><table> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>The operation completed successfully.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed or this function was called using an invalid calling pattern.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>There is insufficient memory to complete the operation.</td></tr> </table><p>?</p></returns>
        /// <doc-id>dn894127</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoContext1::CheckCryptoSessionStatus([In] ID3D11CryptoSession* pCryptoSession,[Out] D3D11_CRYPTO_SESSION_STATUS* pStatus)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext1::CheckCryptoSessionStatus</unmanaged-short>
        public unsafe void CheckCryptoSessionStatus(SharpDX.Direct3D11.CryptoSession cryptoSessionRef, out SharpDX.Direct3D11.CryptoSessionStatus statusRef)
        {
            System.IntPtr cryptoSessionRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            cryptoSessionRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.CryptoSession>(cryptoSessionRef);
            fixed (void *statusRef_ = &statusRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)cryptoSessionRef_, statusRef_, (*(void ***)this._nativePointer)[67]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Indicates that decoder downsampling will be used and that the driver should allocate the appropriate reference frames.  </p>
        /// </summary>
        /// <param name = "decoderRef"><dd>  <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoDecoder"/></strong> interface.</p> </dd></param>
        /// <param name = "inputColorSpace"><dd>  <p>The color space information of the reference frame data.</p> </dd></param>
        /// <param name = "outputDescRef"><dd>  <p>The resolution, format, and colorspace of the output/display frames.  This is the destination resolution and format of the downsample operation.</p> </dd></param>
        /// <param name = "referenceFrameCount"><dd>  <p>The number of reference frames to be used in the operation.</p> </dd></param>
        /// <returns><p>This method returns one of the following error codes.</p><table> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>The operation completed successfully.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed or this function was called using an invalid calling pattern.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>There is insufficient memory to complete the operation.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>This function can only be called once for a specific <strong><see cref = "SharpDX.Direct3D11.VideoDecoder"/></strong> interface. This method must be called prior to the first call to <strong>DecoderBeginFrame</strong>. To update the downsampling parameters, use <strong>DecoderUpdateDownsampling</strong>.</p>
        /// </remarks>
        /// <doc-id>dn894128</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoContext1::DecoderEnableDownsampling([In] ID3D11VideoDecoder* pDecoder,[In] DXGI_COLOR_SPACE_TYPE InputColorSpace,[In] const D3D11_VIDEO_SAMPLE_DESC* pOutputDesc,[In] unsigned int ReferenceFrameCount)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext1::DecoderEnableDownsampling</unmanaged-short>
        public unsafe void DecoderEnableDownsampling(SharpDX.Direct3D11.VideoDecoder decoderRef, SharpDX.DXGI.ColorSpaceType inputColorSpace, SharpDX.Direct3D11.VideoSampleDescription outputDescRef, System.Int32 referenceFrameCount)
        {
            System.IntPtr decoderRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            decoderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoDecoder>(decoderRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)decoderRef_, unchecked ((System.Int32)inputColorSpace), &outputDescRef, referenceFrameCount, (*(void ***)this._nativePointer)[68]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Updates the decoder downsampling parameters.</p>
        /// </summary>
        /// <param name = "decoderRef"><dd>  <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoDecoder"/></strong> interface.</p> </dd></param>
        /// <param name = "outputDescRef"><dd>  <p>The resolution, format, and colorspace of the output/display frames.  This is the destination resolution and format of the downsample operation.</p> </dd></param>
        /// <returns><p>This method returns one of the following error codes.</p><table> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>The operation completed successfully.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed or this function was called using an invalid calling pattern.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>There is insufficient memory to complete the operation.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>This method can only be called after decode downsampling is enabled by calling <strong>DecoderEnableDownsampling</strong>. This method is only supported if the <strong>D3D11_VIDEO_DECODER_CAPS_DOWNSAMPLE_DYNAMIC</strong> capability is reported.</p>
        /// </remarks>
        /// <doc-id>dn894129</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoContext1::DecoderUpdateDownsampling([In] ID3D11VideoDecoder* pDecoder,[In] const D3D11_VIDEO_SAMPLE_DESC* pOutputDesc)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext1::DecoderUpdateDownsampling</unmanaged-short>
        public unsafe void DecoderUpdateDownsampling(SharpDX.Direct3D11.VideoDecoder decoderRef, SharpDX.Direct3D11.VideoSampleDescription outputDescRef)
        {
            System.IntPtr decoderRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            decoderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoDecoder>(decoderRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)decoderRef_, &outputDescRef, (*(void ***)this._nativePointer)[69]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the color space information for the video processor output surface.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd>  <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface.</p> </dd></param>
        /// <param name = "colorSpace"><dd>  <p>A  <strong><see cref = "SharpDX.DXGI.ColorSpaceType"/></strong> value that specifies the colorspace for the video processor output surface.</p> </dd></param>
        /// <doc-id>dn894137</doc-id>
        /// <unmanaged>void ID3D11VideoContext1::VideoProcessorSetOutputColorSpace1([In] ID3D11VideoProcessor* pVideoProcessor,[In] DXGI_COLOR_SPACE_TYPE ColorSpace)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext1::VideoProcessorSetOutputColorSpace1</unmanaged-short>
        public unsafe void VideoProcessorSetOutputColorSpace1(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, SharpDX.DXGI.ColorSpaceType colorSpace)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, unchecked ((System.Int32)colorSpace), (*(void ***)this._nativePointer)[70]);
        }

        /// <summary>
        /// <p>Sets a value indicating whether the output surface from a call to <strong>ID3D11VideoContext::VideoProcessorBlt</strong> will be read by Direct3D shaders.</p>
        /// </summary>
        /// <param name = "videoProcessorRef">No documentation.</param>
        /// <param name = "shaderUsage">No documentation.</param>
        /// <doc-id>dn894138</doc-id>
        /// <unmanaged>void ID3D11VideoContext1::VideoProcessorSetOutputShaderUsage([In] ID3D11VideoProcessor* pVideoProcessor,[In] BOOL ShaderUsage)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext1::VideoProcessorSetOutputShaderUsage</unmanaged-short>
        public unsafe void VideoProcessorSetOutputShaderUsage(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, SharpDX.Mathematics.Interop.RawBool shaderUsage)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid0(this._nativePointer, (void *)videoProcessorRef_, shaderUsage, (*(void ***)this._nativePointer)[71]);
        }

        /// <summary>
        /// <p>Gets the color space information for the video processor output surface.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd>  <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface.</p> </dd></param>
        /// <param name = "colorSpaceRef"><dd>  <p>A reference to a <strong><see cref = "SharpDX.DXGI.ColorSpaceType"/></strong> value that indicates the colorspace for the video processor output surface.</p> </dd></param>
        /// <doc-id>dn894133</doc-id>
        /// <unmanaged>void ID3D11VideoContext1::VideoProcessorGetOutputColorSpace1([In] ID3D11VideoProcessor* pVideoProcessor,[Out] DXGI_COLOR_SPACE_TYPE* pColorSpace)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext1::VideoProcessorGetOutputColorSpace1</unmanaged-short>
        public unsafe void VideoProcessorGetOutputColorSpace1(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, out SharpDX.DXGI.ColorSpaceType colorSpaceRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *colorSpaceRef_ = &colorSpaceRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, colorSpaceRef_, (*(void ***)this._nativePointer)[72]);
        }

        /// <summary>
        /// <p>Gets a value indicating whether the output surface from a call to <strong>ID3D11VideoContext::VideoProcessorBlt</strong> can be read by Direct3D shaders.</p>
        /// </summary>
        /// <param name = "videoProcessorRef">No documentation.</param>
        /// <param name = "shaderUsageRef">No documentation.</param>
        /// <doc-id>dn894134</doc-id>
        /// <unmanaged>void ID3D11VideoContext1::VideoProcessorGetOutputShaderUsage([In] ID3D11VideoProcessor* pVideoProcessor,[Out] BOOL* pShaderUsage)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext1::VideoProcessorGetOutputShaderUsage</unmanaged-short>
        public unsafe void VideoProcessorGetOutputShaderUsage(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, out SharpDX.Mathematics.Interop.RawBool shaderUsageRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            shaderUsageRef = default (SharpDX.Mathematics.Interop.RawBool);
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *shaderUsageRef_ = &shaderUsageRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, shaderUsageRef_, (*(void ***)this._nativePointer)[73]);
        }

        /// <summary>
        /// <p>Sets the color space information for the video processor input stream.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd>  <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface.</p> </dd></param>
        /// <param name = "streamIndex"><dd>  <p>An index identifying the input stream.</p> </dd></param>
        /// <param name = "colorSpace"><dd>  <p>A  <strong><see cref = "SharpDX.DXGI.ColorSpaceType"/></strong> value that specifies the colorspace for the video processor input stream.</p> </dd></param>
        /// <doc-id>dn894139</doc-id>
        /// <unmanaged>void ID3D11VideoContext1::VideoProcessorSetStreamColorSpace1([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[In] DXGI_COLOR_SPACE_TYPE ColorSpace)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext1::VideoProcessorSetStreamColorSpace1</unmanaged-short>
        public unsafe void VideoProcessorSetStreamColorSpace1(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, SharpDX.DXGI.ColorSpaceType colorSpace)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, streamIndex, unchecked ((System.Int32)colorSpace), (*(void ***)this._nativePointer)[74]);
        }

        /// <summary>
        /// <p>Specifies whether the video processor input stream should be flipped vertically or horizontally.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd>  <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface.</p> </dd></param>
        /// <param name = "streamIndex"><dd>  <p>An index identifying the input stream.</p> </dd></param>
        /// <param name = "enable"><dd>  <p>True if mirroring should be enabled; otherwise, false.</p> </dd></param>
        /// <param name = "flipHorizontal"><dd>  <p>True if the stream should be flipped horizontally; otherwise, false.</p> </dd></param>
        /// <param name = "flipVertical"><dd>  <p>True if the stream should be flipped vertically; otherwise, false.</p> </dd></param>
        /// <remarks>
        /// <p>When used in combination, transformations on the processor input stream should be applied in the following order:</p><ul> <li>Rotation</li> <li>Mirroring</li> <li>Source clipping</li> </ul>
        /// </remarks>
        /// <doc-id>dn894140</doc-id>
        /// <unmanaged>void ID3D11VideoContext1::VideoProcessorSetStreamMirror([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[In] BOOL Enable,[In] BOOL FlipHorizontal,[In] BOOL FlipVertical)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext1::VideoProcessorSetStreamMirror</unmanaged-short>
        public unsafe void VideoProcessorSetStreamMirror(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, SharpDX.Mathematics.Interop.RawBool enable, SharpDX.Mathematics.Interop.RawBool flipHorizontal, SharpDX.Mathematics.Interop.RawBool flipVertical)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid0(this._nativePointer, (void *)videoProcessorRef_, streamIndex, enable, flipHorizontal, flipVertical, (*(void ***)this._nativePointer)[75]);
        }

        /// <summary>
        /// <p>Gets the color space information for the video processor input stream.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd>  <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface.</p> </dd></param>
        /// <param name = "streamIndex"><dd>  <p>An index identifying the input stream.</p> </dd></param>
        /// <param name = "colorSpaceRef"><dd>  <p>A reference to a  <strong><see cref = "SharpDX.DXGI.ColorSpaceType"/></strong> value that specifies the colorspace for the video processor input stream.</p> </dd></param>
        /// <doc-id>dn894135</doc-id>
        /// <unmanaged>void ID3D11VideoContext1::VideoProcessorGetStreamColorSpace1([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[Out] DXGI_COLOR_SPACE_TYPE* pColorSpace)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext1::VideoProcessorGetStreamColorSpace1</unmanaged-short>
        public unsafe void VideoProcessorGetStreamColorSpace1(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, out SharpDX.DXGI.ColorSpaceType colorSpaceRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *colorSpaceRef_ = &colorSpaceRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, streamIndex, colorSpaceRef_, (*(void ***)this._nativePointer)[76]);
        }

        /// <summary>
        /// <p>Gets values that indicate whether the video processor input stream is  being flipped vertically or horizontally.</p>
        /// </summary>
        /// <param name = "videoProcessorRef"><dd>  <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface.</p> </dd></param>
        /// <param name = "streamIndex"><dd>  <p>An index identifying the input stream.</p> </dd></param>
        /// <param name = "enableRef"><dd>  <p>A reference to a boolean value indicating whether mirroring is enabled. True if mirroring is enabled; otherwise, false.</p> </dd></param>
        /// <param name = "flipHorizontalRef"><dd>  <p>A reference to a boolean value indicating whether the stream is being flipped horizontally. True if the stream is being flipped horizontally; otherwise, false.</p> </dd></param>
        /// <param name = "flipVerticalRef"><dd>  <p>A reference to a boolean value indicating whether the stream is being flipped vertically. True if the stream is being flipped vertically; otherwise, false.</p> </dd></param>
        /// <doc-id>dn894136</doc-id>
        /// <unmanaged>void ID3D11VideoContext1::VideoProcessorGetStreamMirror([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[Out] BOOL* pEnable,[Out] BOOL* pFlipHorizontal,[Out] BOOL* pFlipVertical)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext1::VideoProcessorGetStreamMirror</unmanaged-short>
        public unsafe void VideoProcessorGetStreamMirror(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, out SharpDX.Mathematics.Interop.RawBool enableRef, out SharpDX.Mathematics.Interop.RawBool flipHorizontalRef, out SharpDX.Mathematics.Interop.RawBool flipVerticalRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            enableRef = default (SharpDX.Mathematics.Interop.RawBool);
            flipHorizontalRef = default (SharpDX.Mathematics.Interop.RawBool);
            flipVerticalRef = default (SharpDX.Mathematics.Interop.RawBool);
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *flipVerticalRef_ = &flipVerticalRef)
                fixed (void *flipHorizontalRef_ = &flipHorizontalRef)
                    fixed (void *enableRef_ = &enableRef)
                        SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, streamIndex, enableRef_, flipHorizontalRef_, flipVerticalRef_, (*(void ***)this._nativePointer)[77]);
        }

        /// <summary>
        /// <p>Returns driver hints that indicate which of the video processor operations are best performed using multi-plane overlay hardware rather than <strong>ID3D11VideoContext::VideoProcessorBlt</strong> method.</p>
        /// </summary>
        /// <param name = "videoProcessorRef">No documentation.</param>
        /// <param name = "outputWidth">No documentation.</param>
        /// <param name = "outputHeight">No documentation.</param>
        /// <param name = "outputFormat">No documentation.</param>
        /// <param name = "streamCount">No documentation.</param>
        /// <param name = "streamsRef">No documentation.</param>
        /// <param name = "behaviorHintsRef">No documentation.</param>
        /// <returns><p>This method returns one of the following error codes.</p><table> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>The operation completed successfully.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed or this function was called using an invalid calling pattern.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>There is insufficient memory to complete the operation.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>This method computes the behavior hints using the current state of the video processor as set by the "SetOutput" and "SetStream" methods of <strong><see cref = "SharpDX.Direct3D11.VideoContext"/></strong> and <strong><see cref = "SharpDX.Direct3D11.VideoContext1"/></strong>. You must set the proper state before calling this method to ensure that the returned hints contain useful data.</p>
        /// </remarks>
        /// <doc-id>dn894132</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoContext1::VideoProcessorGetBehaviorHints([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int OutputWidth,[In] unsigned int OutputHeight,[In] DXGI_FORMAT OutputFormat,[In] unsigned int StreamCount,[In, Buffer] const D3D11_VIDEO_PROCESSOR_STREAM_BEHAVIOR_HINT* pStreams,[Out] unsigned int* pBehaviorHints)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext1::VideoProcessorGetBehaviorHints</unmanaged-short>
        public unsafe void VideoProcessorGetBehaviorHints(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 outputWidth, System.Int32 outputHeight, SharpDX.DXGI.Format outputFormat, System.Int32 streamCount, SharpDX.Direct3D11.VideoProcessorStreamBehaviorHint[] streamsRef, out System.Int32 behaviorHintsRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *behaviorHintsRef_ = &behaviorHintsRef)
                fixed (void *streamsRef_ = streamsRef)
                    __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)videoProcessorRef_, outputWidth, outputHeight, unchecked ((System.Int32)outputFormat), streamCount, streamsRef_, behaviorHintsRef_, (*(void ***)this._nativePointer)[78]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("C4E7374C-6243-4D1B-AE87-52B4F740E261")]
    public partial class VideoContext2 : SharpDX.Direct3D11.VideoContext1
    {
        public VideoContext2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator VideoContext2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new VideoContext2(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "videoProcessorRef">No documentation.</param>
        /// <param name = "type">No documentation.</param>
        /// <param name = "size">No documentation.</param>
        /// <param name = "hDRMetaDataRef">No documentation.</param>
        /// <unmanaged>void ID3D11VideoContext2::VideoProcessorSetOutputHDRMetaData([In] ID3D11VideoProcessor* pVideoProcessor,[In] DXGI_HDR_METADATA_TYPE Type,[In] unsigned int Size,[In, Buffer, Optional] const void* pHDRMetaData)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext2::VideoProcessorSetOutputHDRMetaData</unmanaged-short>
        public unsafe void VideoProcessorSetOutputHDRMetaData(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, SharpDX.DXGI.HdrMetadataType type, System.Int32 size, System.IntPtr hDRMetaDataRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, unchecked ((System.Int32)type), size, (void *)hDRMetaDataRef, (*(void ***)this._nativePointer)[79]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "videoProcessorRef">No documentation.</param>
        /// <param name = "typeRef">No documentation.</param>
        /// <param name = "size">No documentation.</param>
        /// <param name = "metaDataRef">No documentation.</param>
        /// <unmanaged>void ID3D11VideoContext2::VideoProcessorGetOutputHDRMetaData([In] ID3D11VideoProcessor* pVideoProcessor,[Out] DXGI_HDR_METADATA_TYPE* pType,[In] unsigned int Size,[Out, Buffer, Optional] void* pMetaData)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext2::VideoProcessorGetOutputHDRMetaData</unmanaged-short>
        public unsafe void VideoProcessorGetOutputHDRMetaData(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, out SharpDX.DXGI.HdrMetadataType typeRef, System.Int32 size, System.IntPtr metaDataRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *typeRef_ = &typeRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, typeRef_, size, (void *)metaDataRef, (*(void ***)this._nativePointer)[80]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "videoProcessorRef">No documentation.</param>
        /// <param name = "streamIndex">No documentation.</param>
        /// <param name = "type">No documentation.</param>
        /// <param name = "size">No documentation.</param>
        /// <param name = "hDRMetaDataRef">No documentation.</param>
        /// <unmanaged>void ID3D11VideoContext2::VideoProcessorSetStreamHDRMetaData([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[In] DXGI_HDR_METADATA_TYPE Type,[In] unsigned int Size,[In, Buffer, Optional] const void* pHDRMetaData)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext2::VideoProcessorSetStreamHDRMetaData</unmanaged-short>
        public unsafe void VideoProcessorSetStreamHDRMetaData(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, SharpDX.DXGI.HdrMetadataType type, System.Int32 size, System.IntPtr hDRMetaDataRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, streamIndex, unchecked ((System.Int32)type), size, (void *)hDRMetaDataRef, (*(void ***)this._nativePointer)[81]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "videoProcessorRef">No documentation.</param>
        /// <param name = "streamIndex">No documentation.</param>
        /// <param name = "typeRef">No documentation.</param>
        /// <param name = "size">No documentation.</param>
        /// <param name = "metaDataRef">No documentation.</param>
        /// <unmanaged>void ID3D11VideoContext2::VideoProcessorGetStreamHDRMetaData([In] ID3D11VideoProcessor* pVideoProcessor,[In] unsigned int StreamIndex,[Out] DXGI_HDR_METADATA_TYPE* pType,[In] unsigned int Size,[Out, Buffer, Optional] void* pMetaData)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext2::VideoProcessorGetStreamHDRMetaData</unmanaged-short>
        public unsafe void VideoProcessorGetStreamHDRMetaData(SharpDX.Direct3D11.VideoProcessor videoProcessorRef, System.Int32 streamIndex, out SharpDX.DXGI.HdrMetadataType typeRef, System.Int32 size, System.IntPtr metaDataRef)
        {
            System.IntPtr videoProcessorRef_ = System.IntPtr.Zero;
            videoProcessorRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessor>(videoProcessorRef);
            fixed (void *typeRef_ = &typeRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)videoProcessorRef_, streamIndex, typeRef_, size, (void *)metaDataRef, (*(void ***)this._nativePointer)[82]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("A9E2FAA0-CB39-418F-A0B7-D8AAD4DE672E")]
    public partial class VideoContext3 : SharpDX.Direct3D11.VideoContext2
    {
        public VideoContext3(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator VideoContext3(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new VideoContext3(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "decoderRef">No documentation.</param>
        /// <param name = "viewRef">No documentation.</param>
        /// <param name = "contentKeySize">No documentation.</param>
        /// <param name = "contentKeyRef">No documentation.</param>
        /// <param name = "numComponentHistograms">No documentation.</param>
        /// <param name = "histogramOffsetsRef">No documentation.</param>
        /// <param name = "histogramBuffersOut">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D11VideoContext3::DecoderBeginFrame1([In] ID3D11VideoDecoder* pDecoder,[In] ID3D11VideoDecoderOutputView* pView,[In] unsigned int ContentKeySize,[In, Buffer, Optional] const void* pContentKey,[In] unsigned int NumComponentHistograms,[In, Buffer, Optional] const unsigned int* pHistogramOffsets,[In, Buffer, Optional] const ID3D11Buffer** ppHistogramBuffers)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext3::DecoderBeginFrame1</unmanaged-short>
        public unsafe void DecoderBeginFrame1(SharpDX.Direct3D11.VideoDecoder decoderRef, SharpDX.Direct3D11.VideoDecoderOutputView viewRef, System.Int32 contentKeySize, System.IntPtr contentKeyRef, System.Int32 numComponentHistograms, System.Int32[] histogramOffsetsRef, SharpDX.Direct3D11.Buffer[] histogramBuffersOut)
        {
            System.IntPtr decoderRef_ = System.IntPtr.Zero;
            System.IntPtr viewRef_ = System.IntPtr.Zero;
            System.IntPtr*histogramBuffersOut_;
            histogramBuffersOut_ = (System.IntPtr*)0;
            if (histogramBuffersOut != null)
            {
                System.IntPtr*_histogramBuffersOut = stackalloc System.IntPtr[histogramBuffersOut.Length];
                histogramBuffersOut_ = _histogramBuffersOut;
            }

            SharpDX.Result __result__;
            decoderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoDecoder>(decoderRef);
            viewRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoDecoderOutputView>(viewRef);
            if (histogramBuffersOut != null)
                for (int i = 0; i < histogramBuffersOut.Length; ++i)
                    (histogramBuffersOut_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Buffer>(histogramBuffersOut[i]);
            fixed (void *histogramOffsetsRef_ = histogramOffsetsRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)decoderRef_, (void *)viewRef_, contentKeySize, (void *)contentKeyRef, numComponentHistograms, histogramOffsetsRef_, (void *)histogramBuffersOut_, (*(void ***)this._nativePointer)[83]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "decoderRef">No documentation.</param>
        /// <param name = "numBuffers">No documentation.</param>
        /// <param name = "bufferDescRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D11VideoContext3::SubmitDecoderBuffers2([In] ID3D11VideoDecoder* pDecoder,[In] unsigned int NumBuffers,[In, Buffer] const D3D11_VIDEO_DECODER_BUFFER_DESC2* pBufferDesc)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext3::SubmitDecoderBuffers2</unmanaged-short>
        public unsafe void SubmitDecoderBuffers2(SharpDX.Direct3D11.VideoDecoder decoderRef, System.Int32 numBuffers, SharpDX.Direct3D11.VideoDecoderBufferDescription2[] bufferDescRef)
        {
            System.IntPtr decoderRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            decoderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoDecoder>(decoderRef);
            fixed (void *bufferDescRef_ = bufferDescRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)decoderRef_, numBuffers, bufferDescRef_, (*(void ***)this._nativePointer)[84]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "decoderRef">No documentation.</param>
        /// <param name = "viewRef">No documentation.</param>
        /// <param name = "contentKeySize">No documentation.</param>
        /// <param name = "contentKeyRef">No documentation.</param>
        /// <param name = "numComponentHistograms">No documentation.</param>
        /// <param name = "histogramOffsetsRef">No documentation.</param>
        /// <param name = "histogramBuffersOut">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D11VideoContext3::DecoderBeginFrame1([In] ID3D11VideoDecoder* pDecoder,[In] ID3D11VideoDecoderOutputView* pView,[In] unsigned int ContentKeySize,[In, Buffer, Optional] const void* pContentKey,[In] unsigned int NumComponentHistograms,[In, Buffer, Optional] const unsigned int* pHistogramOffsets,[In, Buffer, Optional] const ID3D11Buffer** ppHistogramBuffers)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext3::DecoderBeginFrame1</unmanaged-short>
        public unsafe void DecoderBeginFrame1(SharpDX.Direct3D11.VideoDecoder decoderRef, SharpDX.Direct3D11.VideoDecoderOutputView viewRef, System.Int32 contentKeySize, System.IntPtr contentKeyRef, System.Int32 numComponentHistograms, System.Int32[] histogramOffsetsRef, SharpDX.ComArray<SharpDX.Direct3D11.Buffer> histogramBuffersOut)
        {
            System.IntPtr decoderRef_ = System.IntPtr.Zero;
            System.IntPtr viewRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            decoderRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoDecoder>(decoderRef);
            viewRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoDecoderOutputView>(viewRef);
            fixed (void *histogramOffsetsRef_ = histogramOffsetsRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)decoderRef_, (void *)viewRef_, contentKeySize, (void *)contentKeyRef, numComponentHistograms, histogramOffsetsRef_, (void *)(histogramBuffersOut?.NativePointer ?? System.IntPtr.Zero), (*(void ***)this._nativePointer)[83]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "decoderRef">No documentation.</param>
        /// <param name = "viewRef">No documentation.</param>
        /// <param name = "contentKeySize">No documentation.</param>
        /// <param name = "contentKeyRef">No documentation.</param>
        /// <param name = "numComponentHistograms">No documentation.</param>
        /// <param name = "histogramOffsetsRef">No documentation.</param>
        /// <param name = "histogramBuffersOut">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D11VideoContext3::DecoderBeginFrame1([In] ID3D11VideoDecoder* pDecoder,[In] ID3D11VideoDecoderOutputView* pView,[In] unsigned int ContentKeySize,[In, Buffer, Optional] const void* pContentKey,[In] unsigned int NumComponentHistograms,[In, Buffer, Optional] const unsigned int* pHistogramOffsets,[In, Buffer, Optional] const ID3D11Buffer** ppHistogramBuffers)</unmanaged>
        /// <unmanaged-short>ID3D11VideoContext3::DecoderBeginFrame1</unmanaged-short>
        private unsafe void DecoderBeginFrame1(System.IntPtr decoderRef, System.IntPtr viewRef, System.Int32 contentKeySize, System.IntPtr contentKeyRef, System.Int32 numComponentHistograms, System.IntPtr histogramOffsetsRef, System.IntPtr histogramBuffersOut)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)decoderRef, (void *)viewRef, contentKeySize, (void *)contentKeyRef, numComponentHistograms, (void *)histogramOffsetsRef, (void *)histogramBuffersOut, (*(void ***)this._nativePointer)[83]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("3C9C5B51-995D-48d1-9B8D-FA5CAEDED65C")]
    public partial class VideoDecoder : SharpDX.Direct3D11.DeviceChild
    {
        public VideoDecoder(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator VideoDecoder(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new VideoDecoder(nativePtr);
        /// <summary>
        /// <p>Gets a handle to the driver.</p>
        /// </summary>
        /// <remarks>
        /// <p>The driver handle can be used to configure content protection.</p>
        /// </remarks>
        /// <doc-id>hh447780</doc-id>
        /// <unmanaged>GetDriverHandle</unmanaged>
        /// <unmanaged-short>GetDriverHandle</unmanaged-short>
        public System.IntPtr DriverHandle
        {
            get
            {
                GetDriverHandle(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the parameters that were used to create the decoder.</p>
        /// </summary>
        /// <param name = "videoDescRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoDecoderDescription"/></strong> structure that receives a description of the video stream.</p> </dd></param>
        /// <param name = "configRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoDecoderConfig"/></strong> structure that receives the decoder configuration.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447769</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoDecoder::GetCreationParameters([Out] D3D11_VIDEO_DECODER_DESC* pVideoDesc,[Out] D3D11_VIDEO_DECODER_CONFIG* pConfig)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDecoder::GetCreationParameters</unmanaged-short>
        public unsafe void GetCreationParameters(out SharpDX.Direct3D11.VideoDecoderDescription videoDescRef, out SharpDX.Direct3D11.VideoDecoderConfig configRef)
        {
            videoDescRef = default (SharpDX.Direct3D11.VideoDecoderDescription);
            configRef = default (SharpDX.Direct3D11.VideoDecoderConfig);
            SharpDX.Result __result__;
            fixed (void *configRef_ = &configRef)
                fixed (void *videoDescRef_ = &videoDescRef)
                    __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, videoDescRef_, configRef_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets a handle to the driver.</p>
        /// </summary>
        /// <param name = "driverHandleRef"><dd> <p>Receives a handle to the driver.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The driver handle can be used to configure content protection.</p>
        /// </remarks>
        /// <doc-id>hh447780</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoDecoder::GetDriverHandle([Out] void** pDriverHandle)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDecoder::GetDriverHandle</unmanaged-short>
        internal unsafe void GetDriverHandle(out System.IntPtr driverHandleRef)
        {
            SharpDX.Result __result__;
            fixed (void *driverHandleRef_ = &driverHandleRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, driverHandleRef_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("C2931AEA-2A85-4f20-860F-FBA1FD256E18")]
    public partial class VideoDecoderOutputView : SharpDX.Direct3D11.ResourceView
    {
        public VideoDecoderOutputView(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator VideoDecoderOutputView(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new VideoDecoderOutputView(nativePtr);
        /// <summary>
        /// <p>Gets the properties of the video decoder output view.
        /// </p>
        /// </summary>
        /// <doc-id>hh447768</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.Direct3D11.VideoDecoderOutputViewDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the properties of the video decoder output view.
        /// </p>
        /// </summary>
        /// <param name = "descRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoDecoderOutputViewDescription"/></strong> structure. The method fills the structure with the view properties.</p> </dd></param>
        /// <doc-id>hh447768</doc-id>
        /// <unmanaged>void ID3D11VideoDecoderOutputView::GetDesc([Out] D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDecoderOutputView::GetDesc</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.Direct3D11.VideoDecoderOutputViewDescription descRef)
        {
            descRef = default (SharpDX.Direct3D11.VideoDecoderOutputViewDescription);
            fixed (void *descRef_ = &descRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[8]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("10EC4D5B-975A-4689-B9E4-D0AAC30FE333")]
    public partial class VideoDevice : SharpDX.ComObject
    {
        public VideoDevice(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator VideoDevice(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new VideoDevice(nativePtr);
        /// <summary>
        /// <p>Gets the number of profiles that are supported by the driver.</p>
        /// </summary>
        /// <remarks>
        /// <p>To enumerate the profiles, call <strong>ID3D11VideoDevice::GetVideoDecoderProfile</strong>.</p>
        /// </remarks>
        /// <doc-id>hh447796</doc-id>
        /// <unmanaged>GetVideoDecoderProfileCount</unmanaged>
        /// <unmanaged-short>GetVideoDecoderProfileCount</unmanaged-short>
        public System.Int32 VideoDecoderProfileCount
        {
            get => GetVideoDecoderProfileCount();
        }

        /// <summary>
        /// <p>Creates a video decoder device for Microsoft Direct3D?11.</p>
        /// </summary>
        /// <param name = "videoDescRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoDecoderDescription"/></strong> structure that describes the video stream and the decoder profile.</p> </dd></param>
        /// <param name = "configRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoDecoderConfig"/></strong> structure that specifies the decoder configuration.</p> </dd></param>
        /// <param name = "decoderOut"><dd> <p>Receives a reference to the <strong><see cref = "SharpDX.Direct3D11.VideoDecoder"/></strong> interface. The caller must release the interface.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method allocates the necessary decoder buffers. </p><p>The <strong>ID3D11DeviceContext::ClearState</strong> method does not affect the internal state of the video decoder.</p>
        /// </remarks>
        /// <doc-id>hh447786</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoDevice::CreateVideoDecoder([In] const D3D11_VIDEO_DECODER_DESC* pVideoDesc,[In] const D3D11_VIDEO_DECODER_CONFIG* pConfig,[Out] ID3D11VideoDecoder** ppDecoder)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDevice::CreateVideoDecoder</unmanaged-short>
        public unsafe void CreateVideoDecoder(ref SharpDX.Direct3D11.VideoDecoderDescription videoDescRef, ref SharpDX.Direct3D11.VideoDecoderConfig configRef, out SharpDX.Direct3D11.VideoDecoder decoderOut)
        {
            System.IntPtr decoderOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *configRef_ = &configRef)
                fixed (void *videoDescRef_ = &videoDescRef)
                    __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, videoDescRef_, configRef_, &decoderOut_, (*(void ***)this._nativePointer)[3]);
            if (decoderOut_ != System.IntPtr.Zero)
                decoderOut = new SharpDX.Direct3D11.VideoDecoder(decoderOut_);
            else
                decoderOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a video processor device for Microsoft Direct3D?11.</p>
        /// </summary>
        /// <param name = "enumRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessorEnumerator"/></strong> interface. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessorEnumerator</strong>.</p> </dd></param>
        /// <param name = "rateConversionIndex"><dd> <p>Specifies the frame-rate conversion capabilities for the video processor. The value is a zero-based index that corresponds to the <em>TypeIndex</em> parameter of the <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorRateConversionCaps</strong> method. </p> </dd></param>
        /// <param name = "videoProcessorOut"><dd> <p>Receives a reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessor"/></strong> interface. The caller must release the interface.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The <strong>ID3D11DeviceContext::ClearState</strong> method does not affect the internal state of the video processor.</p>
        /// </remarks>
        /// <doc-id>hh447788</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoDevice::CreateVideoProcessor([In] ID3D11VideoProcessorEnumerator* pEnum,[In] unsigned int RateConversionIndex,[Out] ID3D11VideoProcessor** ppVideoProcessor)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDevice::CreateVideoProcessor</unmanaged-short>
        public unsafe void CreateVideoProcessor(SharpDX.Direct3D11.VideoProcessorEnumerator enumRef, System.Int32 rateConversionIndex, out SharpDX.Direct3D11.VideoProcessor videoProcessorOut)
        {
            System.IntPtr enumRef_ = System.IntPtr.Zero;
            System.IntPtr videoProcessorOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            enumRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessorEnumerator>(enumRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)enumRef_, rateConversionIndex, &videoProcessorOut_, (*(void ***)this._nativePointer)[4]);
            if (videoProcessorOut_ != System.IntPtr.Zero)
                videoProcessorOut = new SharpDX.Direct3D11.VideoProcessor(videoProcessorOut_);
            else
                videoProcessorOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a channel to communicate with the Microsoft Direct3D device or the graphics driver. The channel can be used to send commands and queries for content protection.</p>
        /// </summary>
        /// <param name = "channelType"><dd> <p>Specifies the type of channel, as a member of the <strong><see cref = "SharpDX.Direct3D11.AuthenticatedChannelType"/></strong> enumeration.</p> </dd></param>
        /// <param name = "authenticatedChannelOut"><dd> <p>Receives a reference to the <strong><see cref = "SharpDX.Direct3D11.AuthenticatedChannel"/></strong> interface. The caller must release the interface.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If the <em>ChannelType</em> parameter is <strong>D3D11_AUTHENTICATED_CHANNEL_D3D11</strong>, the method creates a channel with the Direct3D device. This type of channel does not support authentication.</p><p>If <em>ChannelType</em> is <strong>D3D11_AUTHENTICATED_CHANNEL_DRIVER_SOFTWARE</strong> or <strong>D3D11_AUTHENTICATED_CHANNEL_DRIVER_HARDWARE</strong>, the method creates an authenticated channel with the graphics driver.</p>
        /// </remarks>
        /// <doc-id>hh447784</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoDevice::CreateAuthenticatedChannel([In] D3D11_AUTHENTICATED_CHANNEL_TYPE ChannelType,[Out] ID3D11AuthenticatedChannel** ppAuthenticatedChannel)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDevice::CreateAuthenticatedChannel</unmanaged-short>
        public unsafe void CreateAuthenticatedChannel(SharpDX.Direct3D11.AuthenticatedChannelType channelType, out SharpDX.Direct3D11.AuthenticatedChannel authenticatedChannelOut)
        {
            System.IntPtr authenticatedChannelOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)channelType), &authenticatedChannelOut_, (*(void ***)this._nativePointer)[5]);
            if (authenticatedChannelOut_ != System.IntPtr.Zero)
                authenticatedChannelOut = new SharpDX.Direct3D11.AuthenticatedChannel(authenticatedChannelOut_);
            else
                authenticatedChannelOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a cryptographic session to encrypt video content that is sent to the graphics driver. </p>
        /// </summary>
        /// <param name = "cryptoTypeRef"><dd> <p>A reference to a <see cref = "System.Guid"/> that specifies the type of encryption to use. The following GUIDs are defined. </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>D3D11_CRYPTO_TYPE_AES128_CTR</strong></dt> </dl> </td><td> <p>128-bit Advanced Encryption Standard CTR mode (AES-CTR) block cipher.</p> </td></tr> </table> <p>?</p> </dd></param>
        /// <param name = "decoderProfileRef"><dd> <p>A reference to a <see cref = "System.Guid"/> that specifies the decoding profile. For a list of possible values, see <strong>ID3D11VideoDevice::GetVideoDecoderProfile</strong>. If decoding will not be used, set this parameter to <strong><c>null</c></strong>. </p> </dd></param>
        /// <param name = "keyExchangeTypeRef"><dd> <p>A reference to a <see cref = "System.Guid"/> that specifies the type of key exchange.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>D3D11_KEY_EXCHANGE_RSAES_OAEP</strong></dt> </dl> </td><td> <p>The caller will create the session key, encrypt it with RSA Encryption Scheme - Optimal Asymmetric Encryption Padding (RSAES-OAEP) by using the driver's public key, and pass the session key to the driver.</p> </td></tr> </table> <p>?</p> </dd></param>
        /// <param name = "cryptoSessionOut"><dd> <p>Receives a reference to the <strong><see cref = "SharpDX.Direct3D11.CryptoSession"/></strong> interface. The caller must release the interface.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The <strong>ID3D11DeviceContext::ClearState</strong> method does not affect the internal state of the cryptographic session.</p>
        /// </remarks>
        /// <doc-id>hh447785</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoDevice::CreateCryptoSession([In] const GUID* pCryptoType,[In, Optional] const GUID* pDecoderProfile,[In] const GUID* pKeyExchangeType,[Out] ID3D11CryptoSession** ppCryptoSession)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDevice::CreateCryptoSession</unmanaged-short>
        public unsafe void CreateCryptoSession(System.Guid cryptoTypeRef, System.Guid? decoderProfileRef, System.Guid keyExchangeTypeRef, out SharpDX.Direct3D11.CryptoSession cryptoSessionOut)
        {
            System.Guid decoderProfileRef_;
            System.IntPtr cryptoSessionOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (decoderProfileRef != null)
                decoderProfileRef_ = decoderProfileRef.Value;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &cryptoTypeRef, decoderProfileRef == null ? (void *)0 : &decoderProfileRef_, &keyExchangeTypeRef, &cryptoSessionOut_, (*(void ***)this._nativePointer)[6]);
            if (cryptoSessionOut_ != System.IntPtr.Zero)
                cryptoSessionOut = new SharpDX.Direct3D11.CryptoSession(cryptoSessionOut_);
            else
                cryptoSessionOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a resource view for a video decoder, describing the output sample for the decoding operation.</p>
        /// </summary>
        /// <param name = "resourceRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong> interface of the decoder surface. The resource must be created with the <strong>D3D11_BIND_DECODER</strong> flag. See <strong><see cref = "SharpDX.Direct3D11.BindFlags"/></strong>.</p> </dd></param>
        /// <param name = "descRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoDecoderOutputViewDescription"/></strong> structure that describes the view.</p> </dd></param>
        /// <param name = "vDOVViewOut"><dd> <p>Receives a reference to the <strong><see cref = "SharpDX.Direct3D11.VideoDecoderOutputView"/></strong> interface. The caller must release the interface. If this parameter is <strong><c>null</c></strong>, the method checks whether the view is supported, but does not create the view. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Set the <em>ppVDOVView</em> parameter to <strong><c>null</c></strong> to test whether a view is supported.</p>
        /// </remarks>
        /// <doc-id>hh447787</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoDevice::CreateVideoDecoderOutputView([In] ID3D11Resource* pResource,[In] const D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC* pDesc,[Out, Optional] ID3D11VideoDecoderOutputView** ppVDOVView)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDevice::CreateVideoDecoderOutputView</unmanaged-short>
        public unsafe void CreateVideoDecoderOutputView(SharpDX.Direct3D11.Resource resourceRef, ref SharpDX.Direct3D11.VideoDecoderOutputViewDescription descRef, out SharpDX.Direct3D11.VideoDecoderOutputView vDOVViewOut)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            System.IntPtr vDOVViewOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(resourceRef);
            fixed (void *descRef_ = &descRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)resourceRef_, descRef_, &vDOVViewOut_, (*(void ***)this._nativePointer)[7]);
            if (vDOVViewOut_ != System.IntPtr.Zero)
                vDOVViewOut = new SharpDX.Direct3D11.VideoDecoderOutputView(vDOVViewOut_);
            else
                vDOVViewOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a resource view for a video processor, describing the input sample for the video processing operation.</p>
        /// </summary>
        /// <param name = "resourceRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong> interface of the input surface.</p> </dd></param>
        /// <param name = "enumRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessorEnumerator"/></strong> interface that specifies the video processor. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessorEnumerator</strong>.</p> </dd></param>
        /// <param name = "descRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorInputViewDescription"/></strong> structure that describes the view.</p> </dd></param>
        /// <param name = "vPIViewOut"><dd> <p>Receives a reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessorInputView"/></strong> interface. The caller must release the resource. If this parameter is <strong><c>null</c></strong>, the method checks whether the view is supported, but does not create the view. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Set the <em>ppVPIView</em> parameter to <strong><c>null</c></strong> to test whether a view is supported.</p><p>The surface format is given in the <strong>FourCC</strong> member of the <strong><see cref = "SharpDX.Direct3D11.VideoProcessorInputViewDescription"/></strong> structure. The method fails if the video processor does not support this format as an input sample. An app must specify 0 when using 9_1, 9_2, or 9_3 feature levels. </p><p>Resources used for video processor input views must use the following bind flag combinations:</p><ul> <li>Any combination of bind flags that includes <strong>D3D11_BIND_DECODER</strong>,<strong>D3D11_BIND_VIDEO_ENCODER</strong>, <strong>D3D11_BIND_RENDER_TARGET</strong>, and <strong>D3D11_BIND_UNORDERED_ACCESS_VIEW</strong> can be used as for video processor input views (regardless of what other bind flags may be set).</li> <li>Bind flags = 0 is also allowed for a video processor input view.</li> <li>Other restrictions will apply such as:<ul> <li>No multi-sampling is allowed.</li> <li>The Texture2D must have been created using D3D11_USAGE_DEFAULT.</li> </ul> </li> </ul>
        /// </remarks>
        /// <doc-id>hh447790</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoDevice::CreateVideoProcessorInputView([In] ID3D11Resource* pResource,[In] ID3D11VideoProcessorEnumerator* pEnum,[In] const D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC* pDesc,[Out, Optional] ID3D11VideoProcessorInputView** ppVPIView)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDevice::CreateVideoProcessorInputView</unmanaged-short>
        public unsafe void CreateVideoProcessorInputView(SharpDX.Direct3D11.Resource resourceRef, SharpDX.Direct3D11.VideoProcessorEnumerator enumRef, SharpDX.Direct3D11.VideoProcessorInputViewDescription descRef, out SharpDX.Direct3D11.VideoProcessorInputView vPIViewOut)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            System.IntPtr enumRef_ = System.IntPtr.Zero;
            System.IntPtr vPIViewOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(resourceRef);
            enumRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessorEnumerator>(enumRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)resourceRef_, (void *)enumRef_, &descRef, &vPIViewOut_, (*(void ***)this._nativePointer)[8]);
            if (vPIViewOut_ != System.IntPtr.Zero)
                vPIViewOut = new SharpDX.Direct3D11.VideoProcessorInputView(vPIViewOut_);
            else
                vPIViewOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a resource view for a video processor, describing the output sample for the video processing operation.</p>
        /// </summary>
        /// <param name = "resourceRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.Resource"/></strong> interface of the output surface. The resource must be created with the <strong>D3D11_BIND_RENDER_TARGET</strong> flag. See <strong><see cref = "SharpDX.Direct3D11.BindFlags"/></strong>.</p> </dd></param>
        /// <param name = "enumRef"><dd> <p>A reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessorEnumerator"/></strong> interface that specifies the video processor. To get this reference, call <strong>ID3D11VideoDevice::CreateVideoProcessorEnumerator</strong>.</p> </dd></param>
        /// <param name = "descRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorOutputViewDescription"/></strong> structure that describes the view.</p> </dd></param>
        /// <param name = "vPOViewOut"><dd> <p>Receives a reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessorOutputView"/></strong> interface. The caller must release the resource. If this parameter is <strong><c>null</c></strong>, the method checks whether the view is supported, but does not create the view. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Set the <em>ppVPOView</em> parameter to <strong><c>null</c></strong> to test whether a view is supported.</p><p>Resources used for video processor output views must use the following <strong><see cref = "SharpDX.Direct3D11.BindFlags"/></strong> combinations:</p><ul> <li> <strong>D3D11_BIND_RENDER_TARGET</strong> indicates that it can be used for a video processor output view. The following bind flags are allowed to be set with <strong>D3D11_BIND_RENDER_TARGET</strong>:<ul> <li> <strong>D3D11_BIND_VIDEO_ENCODER</strong> </li> <li> <strong>D3D11_BIND_SHADER_RESOURCE</strong> </li> </ul> </li> <li>Other restrictions will apply such as:<ul> <li>No multi-sampling is allowed.</li> <li>The Texture2D must have been created using D3D11_USAGE_DEFAULT.</li> </ul> </li> <li>Some YUV formats can be supported as a video processor output view, but might not be supported as a 3D render target.  D3D11 will allow the <strong>D3D11_BIND_RENDER_TARGET</strong> flag for these formats, but <strong>CreateRenderTargetView</strong> will not be allowed for these formats.</li> </ul><p>If stereo output is enabled, the output view must have 2 array elements.  Otherwise, it must only have a single array element.</p>
        /// </remarks>
        /// <doc-id>hh447791</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoDevice::CreateVideoProcessorOutputView([In] ID3D11Resource* pResource,[In] ID3D11VideoProcessorEnumerator* pEnum,[In] const D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC* pDesc,[Out, Optional] ID3D11VideoProcessorOutputView** ppVPOView)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDevice::CreateVideoProcessorOutputView</unmanaged-short>
        public unsafe void CreateVideoProcessorOutputView(SharpDX.Direct3D11.Resource resourceRef, SharpDX.Direct3D11.VideoProcessorEnumerator enumRef, SharpDX.Direct3D11.VideoProcessorOutputViewDescription descRef, out SharpDX.Direct3D11.VideoProcessorOutputView vPOViewOut)
        {
            System.IntPtr resourceRef_ = System.IntPtr.Zero;
            System.IntPtr enumRef_ = System.IntPtr.Zero;
            System.IntPtr vPOViewOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            resourceRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.Resource>(resourceRef);
            enumRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.VideoProcessorEnumerator>(enumRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)resourceRef_, (void *)enumRef_, &descRef, &vPOViewOut_, (*(void ***)this._nativePointer)[9]);
            if (vPOViewOut_ != System.IntPtr.Zero)
                vPOViewOut = new SharpDX.Direct3D11.VideoProcessorOutputView(vPOViewOut_);
            else
                vPOViewOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Enumerates the video processor capabilities of the driver.</p>
        /// </summary>
        /// <param name = "descRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorContentDescription"/></strong> structure that describes the video content.</p> </dd></param>
        /// <param name = "enumOut"><dd> <p>Receives a reference to the <strong><see cref = "SharpDX.Direct3D11.VideoProcessorEnumerator"/></strong> interface. The caller must release the interface.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>To create the video processor device, pass the <strong><see cref = "SharpDX.Direct3D11.VideoProcessorEnumerator"/></strong> reference to the <strong>ID3D11VideoDevice::CreateVideoProcessor</strong> method.</p>
        /// </remarks>
        /// <doc-id>hh447789</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoDevice::CreateVideoProcessorEnumerator([In] const D3D11_VIDEO_PROCESSOR_CONTENT_DESC* pDesc,[Out] ID3D11VideoProcessorEnumerator** ppEnum)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDevice::CreateVideoProcessorEnumerator</unmanaged-short>
        public unsafe void CreateVideoProcessorEnumerator(ref SharpDX.Direct3D11.VideoProcessorContentDescription descRef, out SharpDX.Direct3D11.VideoProcessorEnumerator enumOut)
        {
            System.IntPtr enumOut_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *descRef_ = &descRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, descRef_, &enumOut_, (*(void ***)this._nativePointer)[10]);
            if (enumOut_ != System.IntPtr.Zero)
                enumOut = new SharpDX.Direct3D11.VideoProcessorEnumerator(enumOut_);
            else
                enumOut = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the number of profiles that are supported by the driver.</p>
        /// </summary>
        /// <returns><p>Returns the number of profiles.</p></returns>
        /// <remarks>
        /// <p>To enumerate the profiles, call <strong>ID3D11VideoDevice::GetVideoDecoderProfile</strong>.</p>
        /// </remarks>
        /// <doc-id>hh447796</doc-id>
        /// <unmanaged>unsigned int ID3D11VideoDevice::GetVideoDecoderProfileCount()</unmanaged>
        /// <unmanaged-short>ID3D11VideoDevice::GetVideoDecoderProfileCount</unmanaged-short>
        internal unsafe System.Int32 GetVideoDecoderProfileCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[11]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets a profile that is supported by the driver.</p>
        /// </summary>
        /// <param name = "index"><dd> <p>The zero-based index of the profile. To get the number of profiles that the driver supports, call <strong>ID3D11VideoDevice::GetVideoDecoderProfileCount</strong>.</p> </dd></param>
        /// <param name = "decoderProfileRef"><dd> <p>Receives a <see cref = "System.Guid"/> that identifies the profile.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447795</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoDevice::GetVideoDecoderProfile([In] unsigned int Index,[Out] GUID* pDecoderProfile)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDevice::GetVideoDecoderProfile</unmanaged-short>
        public unsafe void GetVideoDecoderProfile(System.Int32 index, out System.Guid decoderProfileRef)
        {
            decoderProfileRef = default (System.Guid);
            SharpDX.Result __result__;
            fixed (void *decoderProfileRef_ = &decoderProfileRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, index, decoderProfileRef_, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Given aprofile, checks whether the driver supports a specified output format.</p>
        /// </summary>
        /// <param name = "decoderProfileRef"><dd> <p>A reference to a <see cref = "System.Guid"/> that identifies the profile. To get the list of supported profiles, call <strong>ID3D11VideoDevice::GetVideoDecoderProfile</strong>.</p> </dd></param>
        /// <param name = "format"><dd> <p>A <strong><see cref = "SharpDX.DXGI.Format"/></strong> value that specifies the output format. Typical values include <strong>DXGI_FORMAT_NV12</strong> and <strong>DXGI_FORMAT_420_OPAQUE</strong>.</p> </dd></param>
        /// <param name = "supportedRef"><dd> <p>Receives the value <strong>TRUE</strong> if the format is supported, or <strong><see cref = "SharpDX.Result.False"/></strong> otherwise.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If the driver does not support the profile given in <em>pDecoderProfile</em>, the method returns <strong>E_INVALIDARG</strong>. If the driver supports the profile, but the DXGI format is not compatible with the profile, the method succeeds but returns the value <strong><see cref = "SharpDX.Result.False"/></strong> in <em>pSupported</em>. </p>
        /// </remarks>
        /// <doc-id>hh447783</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoDevice::CheckVideoDecoderFormat([In] const GUID* pDecoderProfile,[In] DXGI_FORMAT Format,[Out] BOOL* pSupported)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDevice::CheckVideoDecoderFormat</unmanaged-short>
        public unsafe void CheckVideoDecoderFormat(System.Guid decoderProfileRef, SharpDX.DXGI.Format format, out SharpDX.Mathematics.Interop.RawBool supportedRef)
        {
            supportedRef = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *supportedRef_ = &supportedRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &decoderProfileRef, unchecked ((System.Int32)format), supportedRef_, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the number of decoder configurations that the driver supports for a specified video description.</p>
        /// </summary>
        /// <param name = "descRef"><dd> <p>A reference to a  <strong><see cref = "SharpDX.Direct3D11.VideoDecoderDescription"/></strong> structure that describes the video stream.</p> </dd></param>
        /// <param name = "countRef"><dd> <p>Receives the number of decoder configurations.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>To enumerate the decoder configurations, call <strong>ID3D11VideoDevice::GetVideoDecoderConfig</strong>.</p>
        /// </remarks>
        /// <doc-id>hh447794</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoDevice::GetVideoDecoderConfigCount([In] const D3D11_VIDEO_DECODER_DESC* pDesc,[Out] unsigned int* pCount)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDevice::GetVideoDecoderConfigCount</unmanaged-short>
        public unsafe void GetVideoDecoderConfigCount(ref SharpDX.Direct3D11.VideoDecoderDescription descRef, out System.Int32 countRef)
        {
            SharpDX.Result __result__;
            fixed (void *countRef_ = &countRef)
                fixed (void *descRef_ = &descRef)
                    __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, descRef_, countRef_, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets a decoder configuration that is supported by the driver.</p>
        /// </summary>
        /// <param name = "descRef"><dd> <p>A reference to a  <strong><see cref = "SharpDX.Direct3D11.VideoDecoderDescription"/></strong> structure that describes the video stream.</p> </dd></param>
        /// <param name = "index"><dd> <p>The zero-based index of the decoder configuration. To get the number of configurations that the driver supports, call <strong>ID3D11VideoDevice::GetVideoDecoderConfigCount</strong>.</p> </dd></param>
        /// <param name = "configRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoDecoderConfig"/></strong> structure. The method fills in the structure with the decoder configuration.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447793</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoDevice::GetVideoDecoderConfig([In] const D3D11_VIDEO_DECODER_DESC* pDesc,[In] unsigned int Index,[Out] D3D11_VIDEO_DECODER_CONFIG* pConfig)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDevice::GetVideoDecoderConfig</unmanaged-short>
        public unsafe void GetVideoDecoderConfig(ref SharpDX.Direct3D11.VideoDecoderDescription descRef, System.Int32 index, out SharpDX.Direct3D11.VideoDecoderConfig configRef)
        {
            configRef = default (SharpDX.Direct3D11.VideoDecoderConfig);
            SharpDX.Result __result__;
            fixed (void *configRef_ = &configRef)
                fixed (void *descRef_ = &descRef)
                    __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, descRef_, index, configRef_, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Queries the driver for its content protection capabilities. </p>
        /// </summary>
        /// <param name = "cryptoTypeRef"><dd> <p>A reference to a <see cref = "System.Guid"/> that specifies the type of encryption to be used. The following GUIDs are defined.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>D3D11_CRYPTO_TYPE_AES128_CTR</strong></dt> </dl> </td><td> <p>128-bit Advanced Encryption Standard CTR mode (AES-CTR) block cipher.</p> </td></tr> </table> <p>?</p> <p>If no encryption will be used, set this parameter to <strong><c>null</c></strong>.</p> </dd></param>
        /// <param name = "decoderProfileRef"><dd> <p>A reference to a <see cref = "System.Guid"/> that specifies the decoding profile. To get profiles that the driver supports, call <strong>ID3D11VideoDevice::GetVideoDecoderProfile</strong>. If decoding will not be used, set this parameter to <strong><c>null</c></strong>.</p> <p>The driver might disallow some combinations of encryption type and profile.</p> </dd></param>
        /// <param name = "capsRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoContentProtectionCaps"/></strong> structure. The method fills in this structure with the driver's content protection capabilities. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447792</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoDevice::GetContentProtectionCaps([In, Optional] const GUID* pCryptoType,[In, Optional] const GUID* pDecoderProfile,[Out] D3D11_VIDEO_CONTENT_PROTECTION_CAPS* pCaps)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDevice::GetContentProtectionCaps</unmanaged-short>
        public unsafe void GetContentProtectionCaps(System.Guid? cryptoTypeRef, System.Guid? decoderProfileRef, out SharpDX.Direct3D11.VideoContentProtectionCaps capsRef)
        {
            System.Guid cryptoTypeRef_;
            System.Guid decoderProfileRef_;
            capsRef = default (SharpDX.Direct3D11.VideoContentProtectionCaps);
            SharpDX.Result __result__;
            if (cryptoTypeRef != null)
                cryptoTypeRef_ = cryptoTypeRef.Value;
            if (decoderProfileRef != null)
                decoderProfileRef_ = decoderProfileRef.Value;
            fixed (void *capsRef_ = &capsRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, cryptoTypeRef == null ? (void *)0 : &cryptoTypeRef_, decoderProfileRef == null ? (void *)0 : &decoderProfileRef_, capsRef_, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets a cryptographic key-exchange mechanism that is supported by the driver.</p>
        /// </summary>
        /// <param name = "cryptoTypeRef"><dd> <p>A reference to a <see cref = "System.Guid"/> that specifies the type of encryption to be used. The following GUIDs are defined.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>D3D11_CRYPTO_TYPE_AES128_CTR</strong></dt> </dl> </td><td> <p>128-bit Advanced Encryption Standard CTR mode (AES-CTR) block cipher.</p> </td></tr> </table> <p>?</p> </dd></param>
        /// <param name = "decoderProfileRef"><dd> <p>A reference to a <see cref = "System.Guid"/> that specifies the decoding profile. To get  profiles that the driver supports, call <strong>ID3D11VideoDevice::GetVideoDecoderProfile</strong>. If decoding will not be used, set this parameter to <strong><c>null</c></strong>.</p> </dd></param>
        /// <param name = "index"><dd> <p>The zero-based index of the key-exchange type. The driver reports the number of types in the <strong>KeyExchangeTypeCount</strong> member of the <strong><see cref = "SharpDX.Direct3D11.VideoContentProtectionCaps"/></strong> structure.</p> </dd></param>
        /// <param name = "keyExchangeTypeRef"><dd> <p>Receives a <see cref = "System.Guid"/> that identifies the type of key exchange.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447782</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoDevice::CheckCryptoKeyExchange([In] const GUID* pCryptoType,[In, Optional] const GUID* pDecoderProfile,[In] unsigned int Index,[Out] GUID* pKeyExchangeType)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDevice::CheckCryptoKeyExchange</unmanaged-short>
        public unsafe void CheckCryptoKeyExchange(System.Guid cryptoTypeRef, System.Guid? decoderProfileRef, System.Int32 index, out System.Guid keyExchangeTypeRef)
        {
            System.Guid decoderProfileRef_;
            keyExchangeTypeRef = default (System.Guid);
            SharpDX.Result __result__;
            if (decoderProfileRef != null)
                decoderProfileRef_ = decoderProfileRef.Value;
            fixed (void *keyExchangeTypeRef_ = &keyExchangeTypeRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &cryptoTypeRef, decoderProfileRef == null ? (void *)0 : &decoderProfileRef_, index, keyExchangeTypeRef_, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets private data on the video device and associates that data with a <see cref = "System.Guid"/>.
        /// </p>
        /// </summary>
        /// <param name = "guid"><dd> <p>The <see cref = "System.Guid"/> associated with the data.</p> </dd></param>
        /// <param name = "dataSize"><dd> <p>The size of the data, in bytes.</p> </dd></param>
        /// <param name = "dataRef"><dd> <p>A reference to the data.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447797</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoDevice::SetPrivateData([In] const GUID&amp; guid,[In] unsigned int DataSize,[In, Buffer, Optional] const void* pData)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDevice::SetPrivateData</unmanaged-short>
        public unsafe void SetPrivateData(System.Guid guid, System.Int32 dataSize, System.IntPtr dataRef)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &guid, dataSize, (void *)dataRef, (*(void ***)this._nativePointer)[18]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets a private <strong><see cref = "SharpDX.IUnknown"/></strong> reference on the video device and associates that reference with a <see cref = "System.Guid"/>.
        /// </p>
        /// </summary>
        /// <param name = "guid">No documentation.</param>
        /// <param name = "dataRef">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447798</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoDevice::SetPrivateDataInterface([In] const GUID&amp; guid,[In, Optional] const IUnknown* pData)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDevice::SetPrivateDataInterface</unmanaged-short>
        public unsafe void SetPrivateDataInterface(System.Guid guid, SharpDX.IUnknown dataRef)
        {
            System.IntPtr dataRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            dataRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.IUnknown>(dataRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &guid, (void *)dataRef_, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("29DA1D51-1321-4454-804B-F5FC9F861F0F")]
    public partial class VideoDevice1 : SharpDX.Direct3D11.VideoDevice
    {
        public VideoDevice1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator VideoDevice1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new VideoDevice1(nativePtr);
        /// <summary>
        /// <p>Retrieves optional sizes for private driver data. </p>
        /// </summary>
        /// <param name = "cryptoTypeRef"><dd>  <p>Indicates the crypto type for which the private input and output size is queried.</p> </dd></param>
        /// <param name = "decoderProfileRef"><dd>  <p>Indicates the decoder profile for which the private input and output size is queried.</p> </dd></param>
        /// <param name = "keyExchangeTypeRef"><dd>  <p>Indicates the key exchange type for which the private input and output size is queried.</p> </dd></param>
        /// <param name = "privateInputSizeRef"><dd>  <p>Returns the size of private data that the driver needs for input commands.</p> </dd></param>
        /// <param name = "privateOutputSizeRef"><dd>  <p>Returns the size of private data that the driver needs for output commands.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <see cref = "SharpDX.Result.Ok"/>. Otherwise, it returns an <see cref = "SharpDX.Result"/> error code.</p></returns>
        /// <remarks>
        /// <p>When <em>pKeyExchangeType</em> is <strong>D3D11_KEY_EXCHANGE_HW_PROTECTION</strong>, the following behavior is expected in the <strong>ID3D11VideoContext::NegotiateCryptoSessionKeyExchange</strong> method:</p><ul> <li>The <em>DataSize</em> parameter is set to the size of the <strong><see cref = "SharpDX.Direct3D11.KeyExchangeHwProtectionData"/></strong> structure.</li> <li><em>pData</em> points to a <strong><see cref = "SharpDX.Direct3D11.KeyExchangeHwProtectionData"/></strong> structure. <ul> <li>The <strong>pInputData</strong> of this structure points to a <strong><see cref = "SharpDX.Direct3D11.KeyExchangeHwProtectionInputData"/></strong> structure where:<ul> <li><strong>pbInput</strong>[0] ? <strong>pbInput</strong>[N-1] contains memory reserved for use by the driver. The number of bytes (N) reserved for the driver is determined by the <strong>pPrivateInputSize</strong> value returned by the <strong>ID3D11VideoDevice1::GetCryptoSessionPrivateDataSize</strong> function.</li> <li><strong>pbInput</strong>[N] contains the first byte of the DRM command packet.</li> </ul> </li> <li>The <strong>pOutputData</strong> of this structure points to a <strong><see cref = "SharpDX.Direct3D11.KeyExchangeHwProtectionOutputData"/></strong> structure where:<ul> <li><strong>pbOutput</strong>[0] ? <strong>pbOutput</strong>[N-1] contains memory reserved for use by the driver. The number of bytes (N) reserved for the driver is determined by the <strong>pPrivateOutputSize</strong> value returned by the <strong>ID3D11VideoDevice1::GetCryptoSessionPrivateDataSize</strong> function.</li> <li><strong>pbOutput</strong>[N] contains the first byte of the DRM command packet.</li> </ul> </li> </ul> </li> </ul>
        /// </remarks>
        /// <doc-id>dn894143</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoDevice1::GetCryptoSessionPrivateDataSize([In] const GUID* pCryptoType,[In, Optional] const GUID* pDecoderProfile,[In] const GUID* pKeyExchangeType,[Out] unsigned int* pPrivateInputSize,[Out] unsigned int* pPrivateOutputSize)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDevice1::GetCryptoSessionPrivateDataSize</unmanaged-short>
        public unsafe void GetCryptoSessionPrivateDataSize(System.Guid cryptoTypeRef, System.Guid? decoderProfileRef, System.Guid keyExchangeTypeRef, out System.Int32 privateInputSizeRef, out System.Int32 privateOutputSizeRef)
        {
            System.Guid decoderProfileRef_;
            SharpDX.Result __result__;
            if (decoderProfileRef != null)
                decoderProfileRef_ = decoderProfileRef.Value;
            fixed (void *privateOutputSizeRef_ = &privateOutputSizeRef)
                fixed (void *privateInputSizeRef_ = &privateInputSizeRef)
                    __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &cryptoTypeRef, decoderProfileRef == null ? (void *)0 : &decoderProfileRef_, &keyExchangeTypeRef, privateInputSizeRef_, privateOutputSizeRef_, (*(void ***)this._nativePointer)[20]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves capabilities and limitations of the video decoder.</p>
        /// </summary>
        /// <param name = "decoderProfileRef"><dd>  <p>The decode profile for which the capabilities are queried.</p> </dd></param>
        /// <param name = "sampleWidth"><dd>  <p>The video width for which the capabilities are queried.</p> </dd></param>
        /// <param name = "sampleHeight"><dd>  <p>The video height for which the capabilities are queried.</p> </dd></param>
        /// <param name = "frameRateRef"><dd>  <p>The frame rate of the video content. This information is used by the driver to determine whether the video can be decoded in real-time.</p> </dd></param>
        /// <param name = "bitRate"><dd>  <p>The bit rate of the video stream. A value of zero indicates that the bit rate can be ignored.</p> </dd></param>
        /// <param name = "cryptoTypeRef"><dd>  <p>The type of cryptography used to encrypt the video stream. A value of <c>null</c> indicates that the video stream is not encrypted.</p> </dd></param>
        /// <param name = "decoderCapsRef"><dd>  <p>A reference to a bitwise OR combination of <strong><see cref = "SharpDX.Direct3D11.VideoDecoderCaps"/></strong> values specifying the decoder capabilities. </p> </dd></param>
        /// <returns><p>This method returns one of the following error codes.</p><table> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>The operation completed successfully.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed or this function was called using an invalid calling pattern.</td></tr> </table><p>?</p></returns>
        /// <doc-id>dn894144</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoDevice1::GetVideoDecoderCaps([In] const GUID* pDecoderProfile,[In] unsigned int SampleWidth,[In] unsigned int SampleHeight,[In] const DXGI_RATIONAL* pFrameRate,[In] unsigned int BitRate,[In, Optional] const GUID* pCryptoType,[Out] unsigned int* pDecoderCaps)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDevice1::GetVideoDecoderCaps</unmanaged-short>
        public unsafe void GetVideoDecoderCaps(System.Guid decoderProfileRef, System.Int32 sampleWidth, System.Int32 sampleHeight, SharpDX.DXGI.Rational frameRateRef, System.Int32 bitRate, System.Guid? cryptoTypeRef, out System.Int32 decoderCapsRef)
        {
            System.Guid cryptoTypeRef_;
            SharpDX.Result __result__;
            if (cryptoTypeRef != null)
                cryptoTypeRef_ = cryptoTypeRef.Value;
            fixed (void *decoderCapsRef_ = &decoderCapsRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, &decoderProfileRef, sampleWidth, sampleHeight, &frameRateRef, bitRate, cryptoTypeRef == null ? (void *)0 : &cryptoTypeRef_, decoderCapsRef_, (*(void ***)this._nativePointer)[21]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Indicates whether the video decoder supports downsampling with the specified input format, and whether real-time downsampling is supported.</p>
        /// </summary>
        /// <param name = "inputDescRef"><dd>  <p>An object describing the decoding profile, the resolution, and format of the input stream.  This is the resolution and format to be downsampled.</p> </dd></param>
        /// <param name = "inputColorSpace"><dd>  <p>A  <strong><see cref = "SharpDX.DXGI.ColorSpaceType"/></strong> value that specifies the colorspace of the reference frame data.</p> </dd></param>
        /// <param name = "inputConfigRef"><dd>  <p>The configuration data associated with the decode profile.</p> </dd></param>
        /// <param name = "frameRateRef"><dd>  <p>The frame rate of the video content. This is used by the driver to determine whether the video can be decoded in real-time. </p> </dd></param>
        /// <param name = "outputDescRef"><dd>  <p>An object describing the resolution, format, and colorspace of the output frames.  This is the destination resolution and format of the downsample operation.</p> </dd></param>
        /// <param name = "supportedRef"><dd>  <p>Pointer to a boolean value set by the driver that indicates if downsampling is supported with the specified input data. True if the driver supports the requested downsampling;  otherwise, false.</p> </dd></param>
        /// <param name = "realTimeHintRef"><dd>  <p>Pointer to a boolean value set by the driver that indicates if real-time decoding is supported with the specified input data. True if the driver supports the requested real-time decoding;  otherwise, false. Note that the returned value is based on the current configuration of the video decoder and does not guarantee that real-time decoding will be supported for future downsampling operations.</p> </dd></param>
        /// <returns><p>This method returns one of the following error codes.</p><table> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>The operation completed successfully.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed or this function was called using an invalid calling pattern.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>You  should call <strong>GetVideoDecoderCaps</strong> to determine whether decoder downsampling is supported before checking support for a  specific configuration.</p>
        /// </remarks>
        /// <doc-id>dn894142</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoDevice1::CheckVideoDecoderDownsampling([In] const D3D11_VIDEO_DECODER_DESC* pInputDesc,[In] DXGI_COLOR_SPACE_TYPE InputColorSpace,[In] const D3D11_VIDEO_DECODER_CONFIG* pInputConfig,[In] const DXGI_RATIONAL* pFrameRate,[In] const D3D11_VIDEO_SAMPLE_DESC* pOutputDesc,[Out] BOOL* pSupported,[Out] BOOL* pRealTimeHint)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDevice1::CheckVideoDecoderDownsampling</unmanaged-short>
        public unsafe void CheckVideoDecoderDownsampling(ref SharpDX.Direct3D11.VideoDecoderDescription inputDescRef, SharpDX.DXGI.ColorSpaceType inputColorSpace, ref SharpDX.Direct3D11.VideoDecoderConfig inputConfigRef, SharpDX.DXGI.Rational frameRateRef, SharpDX.Direct3D11.VideoSampleDescription outputDescRef, out SharpDX.Mathematics.Interop.RawBool supportedRef, out SharpDX.Mathematics.Interop.RawBool realTimeHintRef)
        {
            supportedRef = default (SharpDX.Mathematics.Interop.RawBool);
            realTimeHintRef = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *realTimeHintRef_ = &realTimeHintRef)
                fixed (void *supportedRef_ = &supportedRef)
                    fixed (void *inputConfigRef_ = &inputConfigRef)
                        fixed (void *inputDescRef_ = &inputDescRef)
                            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, inputDescRef_, unchecked ((System.Int32)inputColorSpace), inputConfigRef_, &frameRateRef, &outputDescRef, supportedRef_, realTimeHintRef_, (*(void ***)this._nativePointer)[22]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Allows the driver to recommend optimal output downsample parameters from the input parameters.</p>
        /// </summary>
        /// <param name = "inputDescRef"><dd>  <p>A <strong><see cref = "SharpDX.Direct3D11.VideoDecoderDescription"/></strong> object describing the decoding profile, the resolution, and format of the input stream.  This is the resolution and format to be downsampled.</p> </dd></param>
        /// <param name = "inputColorSpace"><dd>  <p>A  <strong><see cref = "SharpDX.DXGI.ColorSpaceType"/></strong> value that specifies the colorspace of the reference frame data.</p> </dd></param>
        /// <param name = "inputConfigRef"><dd>  <p>The configuration data associated with the decode profile.</p> </dd></param>
        /// <param name = "frameRateRef"><dd>  <p>The frame rate of the video content. This is used by the driver to determine whether the video can be decoded in real-time. </p> </dd></param>
        /// <param name = "recommendedOutputDescRef"><dd>  <p>Pointer to a <strong><see cref = "SharpDX.Direct3D11.VideoSampleDescription"/></strong> structure that the driver populates with the recommended output buffer parameters for a downsample operation. The driver will attempt to recommend parameters that can support real-time decoding. If it is unable to do so, the driver will recommend values that are as close to the real-time solution as possible.</p> </dd></param>
        /// <returns><p>This method returns one of the following error codes.</p><table> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>The operation completed successfully.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed or this function was called using an invalid calling pattern.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>You  should call <strong>GetVideoDecoderCaps</strong> to determine whether decoder downsampling is supported before checking support for a  specific configuration.</p>
        /// </remarks>
        /// <doc-id>dn894145</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoDevice1::RecommendVideoDecoderDownsampleParameters([In] const D3D11_VIDEO_DECODER_DESC* pInputDesc,[In] DXGI_COLOR_SPACE_TYPE InputColorSpace,[In] const D3D11_VIDEO_DECODER_CONFIG* pInputConfig,[In] const DXGI_RATIONAL* pFrameRate,[Out] D3D11_VIDEO_SAMPLE_DESC* pRecommendedOutputDesc)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDevice1::RecommendVideoDecoderDownsampleParameters</unmanaged-short>
        public unsafe void RecommendVideoDecoderDownsampleParameters(ref SharpDX.Direct3D11.VideoDecoderDescription inputDescRef, SharpDX.DXGI.ColorSpaceType inputColorSpace, ref SharpDX.Direct3D11.VideoDecoderConfig inputConfigRef, SharpDX.DXGI.Rational frameRateRef, out SharpDX.Direct3D11.VideoSampleDescription recommendedOutputDescRef)
        {
            recommendedOutputDescRef = default (SharpDX.Direct3D11.VideoSampleDescription);
            SharpDX.Result __result__;
            fixed (void *recommendedOutputDescRef_ = &recommendedOutputDescRef)
                fixed (void *inputConfigRef_ = &inputConfigRef)
                    fixed (void *inputDescRef_ = &inputDescRef)
                        __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, inputDescRef_, unchecked ((System.Int32)inputColorSpace), inputConfigRef_, &frameRateRef, recommendedOutputDescRef_, (*(void ***)this._nativePointer)[23]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("59C0CB01-35F0-4A70-8F67-87905C906A53")]
    public partial class VideoDevice2 : SharpDX.Direct3D11.VideoDevice1
    {
        public VideoDevice2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator VideoDevice2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new VideoDevice2(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "feature">No documentation.</param>
        /// <param name = "featureSupportDataRef">No documentation.</param>
        /// <param name = "featureSupportDataSize">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D11VideoDevice2::CheckFeatureSupport([In] D3D11_FEATURE_VIDEO Feature,[Out, Buffer] void* pFeatureSupportData,[In] unsigned int FeatureSupportDataSize)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDevice2::CheckFeatureSupport</unmanaged-short>
        public unsafe void CheckFeatureSupport(SharpDX.Direct3D11.FeatureVideo feature, System.IntPtr featureSupportDataRef, System.Int32 featureSupportDataSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)feature), (void *)featureSupportDataRef, featureSupportDataSize, (*(void ***)this._nativePointer)[24]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "cryptoSessionRef">No documentation.</param>
        /// <param name = "flags">No documentation.</param>
        /// <param name = "dataSize">No documentation.</param>
        /// <param name = "dataRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID3D11VideoDevice2::NegotiateCryptoSessionKeyExchangeMT([In] ID3D11CryptoSession* pCryptoSession,[In] D3D11_CRYPTO_SESSION_KEY_EXCHANGE_FLAGS flags,[In] unsigned int DataSize,[Out, Buffer] void* pData)</unmanaged>
        /// <unmanaged-short>ID3D11VideoDevice2::NegotiateCryptoSessionKeyExchangeMT</unmanaged-short>
        public unsafe void NegotiateCryptoSessionKeyExchangeMT(SharpDX.Direct3D11.CryptoSession cryptoSessionRef, SharpDX.Direct3D11.CryptoSessionKeyExchangeFlags flags, System.Int32 dataSize, System.IntPtr dataRef)
        {
            System.IntPtr cryptoSessionRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            cryptoSessionRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct3D11.CryptoSession>(cryptoSessionRef);
            __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, (void *)cryptoSessionRef_, unchecked ((System.Int32)flags), dataSize, (void *)dataRef, (*(void ***)this._nativePointer)[25]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("1D7B0652-185F-41c6-85CE-0C5BE3D4AE6C")]
    public partial class VideoProcessor : SharpDX.Direct3D11.DeviceChild
    {
        public VideoProcessor(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator VideoProcessor(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new VideoProcessor(nativePtr);
        /// <summary>
        /// <p>Gets the content description that was used to create the video processor.</p>
        /// </summary>
        /// <doc-id>hh447811</doc-id>
        /// <unmanaged>GetContentDesc</unmanaged>
        /// <unmanaged-short>GetContentDesc</unmanaged-short>
        public SharpDX.Direct3D11.VideoProcessorContentDescription ContentDescription
        {
            get
            {
                GetContentDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the rate conversion capabilities of the video processor.</p>
        /// </summary>
        /// <doc-id>hh447813</doc-id>
        /// <unmanaged>GetRateConversionCaps</unmanaged>
        /// <unmanaged-short>GetRateConversionCaps</unmanaged-short>
        public SharpDX.Direct3D11.VideoProcessorRateConversionCaps RateConversionCaps
        {
            get
            {
                GetRateConversionCaps(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the content description that was used to create the video processor.</p>
        /// </summary>
        /// <param name = "descRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorContentDescription"/></strong> structure that receives the content description.</p> </dd></param>
        /// <doc-id>hh447811</doc-id>
        /// <unmanaged>void ID3D11VideoProcessor::GetContentDesc([Out] D3D11_VIDEO_PROCESSOR_CONTENT_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11VideoProcessor::GetContentDesc</unmanaged-short>
        internal unsafe void GetContentDescription(out SharpDX.Direct3D11.VideoProcessorContentDescription descRef)
        {
            descRef = default (SharpDX.Direct3D11.VideoProcessorContentDescription);
            fixed (void *descRef_ = &descRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[7]);
        }

        /// <summary>
        /// <p>Gets the rate conversion capabilities of the video processor.</p>
        /// </summary>
        /// <param name = "capsRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorRateConversionCaps"/></strong> structure that receives the rate conversion capabilities.</p> </dd></param>
        /// <doc-id>hh447813</doc-id>
        /// <unmanaged>void ID3D11VideoProcessor::GetRateConversionCaps([Out] D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS* pCaps)</unmanaged>
        /// <unmanaged-short>ID3D11VideoProcessor::GetRateConversionCaps</unmanaged-short>
        internal unsafe void GetRateConversionCaps(out SharpDX.Direct3D11.VideoProcessorRateConversionCaps capsRef)
        {
            capsRef = default (SharpDX.Direct3D11.VideoProcessorRateConversionCaps);
            fixed (void *capsRef_ = &capsRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, capsRef_, (*(void ***)this._nativePointer)[8]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("31627037-53AB-4200-9061-05FAA9AB45F9")]
    public partial class VideoProcessorEnumerator : SharpDX.Direct3D11.DeviceChild
    {
        public VideoProcessorEnumerator(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator VideoProcessorEnumerator(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new VideoProcessorEnumerator(nativePtr);
        /// <summary>
        /// <p>Gets the content description that was used to create this enumerator.</p>
        /// </summary>
        /// <doc-id>hh447803</doc-id>
        /// <unmanaged>GetVideoProcessorContentDesc</unmanaged>
        /// <unmanaged-short>GetVideoProcessorContentDesc</unmanaged-short>
        public SharpDX.Direct3D11.VideoProcessorContentDescription VideoProcessorContentDescription
        {
            get
            {
                GetVideoProcessorContentDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the capabilities of the video processor.</p>
        /// </summary>
        /// <doc-id>hh447802</doc-id>
        /// <unmanaged>GetVideoProcessorCaps</unmanaged>
        /// <unmanaged-short>GetVideoProcessorCaps</unmanaged-short>
        public SharpDX.Direct3D11.VideoProcessorCaps VideoProcessorCaps
        {
            get
            {
                GetVideoProcessorCaps(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the content description that was used to create this enumerator.</p>
        /// </summary>
        /// <param name = "contentDescRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorContentDescription"/></strong> structure that receives the content description.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447803</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoProcessorEnumerator::GetVideoProcessorContentDesc([Out] D3D11_VIDEO_PROCESSOR_CONTENT_DESC* pContentDesc)</unmanaged>
        /// <unmanaged-short>ID3D11VideoProcessorEnumerator::GetVideoProcessorContentDesc</unmanaged-short>
        internal unsafe void GetVideoProcessorContentDescription(out SharpDX.Direct3D11.VideoProcessorContentDescription contentDescRef)
        {
            contentDescRef = default (SharpDX.Direct3D11.VideoProcessorContentDescription);
            SharpDX.Result __result__;
            fixed (void *contentDescRef_ = &contentDescRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, contentDescRef_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Queries whether the video processor supports a specified video format.</p>
        /// </summary>
        /// <param name = "format"><dd> <p>The video format to query, specified as a <strong><see cref = "SharpDX.DXGI.Format"/></strong> value.</p> </dd></param>
        /// <param name = "flagsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref = "SharpDX.Direct3D11.VideoProcessorFormatSupport"/></strong> enumeration.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447801</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoProcessorEnumerator::CheckVideoProcessorFormat([In] DXGI_FORMAT Format,[Out] unsigned int* pFlags)</unmanaged>
        /// <unmanaged-short>ID3D11VideoProcessorEnumerator::CheckVideoProcessorFormat</unmanaged-short>
        public unsafe void CheckVideoProcessorFormat(SharpDX.DXGI.Format format, out System.Int32 flagsRef)
        {
            SharpDX.Result __result__;
            fixed (void *flagsRef_ = &flagsRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)format), flagsRef_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the capabilities of the video processor.</p>
        /// </summary>
        /// <param name = "capsRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorCaps"/></strong> structure that receives the capabilities.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447802</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps([Out] D3D11_VIDEO_PROCESSOR_CAPS* pCaps)</unmanaged>
        /// <unmanaged-short>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</unmanaged-short>
        internal unsafe void GetVideoProcessorCaps(out SharpDX.Direct3D11.VideoProcessorCaps capsRef)
        {
            capsRef = default (SharpDX.Direct3D11.VideoProcessorCaps);
            SharpDX.Result __result__;
            fixed (void *capsRef_ = &capsRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, capsRef_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns a group of video processor capabilities that are associated with frame-rate conversion, including deinterlacing and inverse telecine.</p>
        /// </summary>
        /// <param name = "typeIndex"><dd> <p>The zero-based index of the group to retrieve. To get the maximum index, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps</strong> and check the <strong>RateConversionCapsCount</strong> member of the <strong><see cref = "SharpDX.Direct3D11.VideoProcessorCaps"/></strong> structure.</p> </dd></param>
        /// <param name = "capsRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorRateConversionCaps"/></strong> structure that receives the frame-rate conversion capabilities.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The capabilities defined in the <strong><see cref = "SharpDX.Direct3D11.VideoProcessorRateConversionCaps"/></strong> structure are interdependent. Therefore, the driver can support multiple, distinct groups of these capabilities. </p>
        /// </remarks>
        /// <doc-id>hh447806</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoProcessorEnumerator::GetVideoProcessorRateConversionCaps([In] unsigned int TypeIndex,[Out] D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS* pCaps)</unmanaged>
        /// <unmanaged-short>ID3D11VideoProcessorEnumerator::GetVideoProcessorRateConversionCaps</unmanaged-short>
        public unsafe void GetVideoProcessorRateConversionCaps(System.Int32 typeIndex, out SharpDX.Direct3D11.VideoProcessorRateConversionCaps capsRef)
        {
            capsRef = default (SharpDX.Direct3D11.VideoProcessorRateConversionCaps);
            SharpDX.Result __result__;
            fixed (void *capsRef_ = &capsRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, typeIndex, capsRef_, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets a list of custom frame rates that a video processor supports.</p>
        /// </summary>
        /// <param name = "typeIndex"><dd> <p>The zero-based index of the frame-rate capability group. To get the maxmum index, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps </strong> and check the <strong>RateConversionCapsCount</strong> member of the <strong><see cref = "SharpDX.Direct3D11.VideoProcessorCaps"/></strong> structure.</p> </dd></param>
        /// <param name = "customRateIndex"><dd> <p>The zero-based index of the custom rate to retrieve. To get the maximum index, call <strong>ID3D11VideoProcessorEnumerator::GetVideoProcessorRateConversionCaps</strong> and check the <strong>CustomRateCount</strong> member of the <strong><see cref = "SharpDX.Direct3D11.VideoProcessorRateConversionCaps"/></strong> structure.</p> <p>This index value is always relative to the capability group specified in the <em>TypeIndex</em> parameter.</p> </dd></param>
        /// <param name = "rateRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorCustomRate"/></strong> structure that receives the custom rate.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447804</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoProcessorEnumerator::GetVideoProcessorCustomRate([In] unsigned int TypeIndex,[In] unsigned int CustomRateIndex,[Out] D3D11_VIDEO_PROCESSOR_CUSTOM_RATE* pRate)</unmanaged>
        /// <unmanaged-short>ID3D11VideoProcessorEnumerator::GetVideoProcessorCustomRate</unmanaged-short>
        public unsafe void GetVideoProcessorCustomRate(System.Int32 typeIndex, System.Int32 customRateIndex, out SharpDX.Direct3D11.VideoProcessorCustomRate rateRef)
        {
            rateRef = default (SharpDX.Direct3D11.VideoProcessorCustomRate);
            SharpDX.Result __result__;
            fixed (void *rateRef_ = &rateRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, typeIndex, customRateIndex, rateRef_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the range of values for an image filter.</p>
        /// </summary>
        /// <param name = "filter"><dd> <p>The type of image filter, specified as a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorFilter"/></strong> value.</p> </dd></param>
        /// <param name = "rangeRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorFilterRange"/></strong> structure. The method fills the structure with the range of values for the specified filter.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh447805</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoProcessorEnumerator::GetVideoProcessorFilterRange([In] D3D11_VIDEO_PROCESSOR_FILTER Filter,[Out] D3D11_VIDEO_PROCESSOR_FILTER_RANGE* pRange)</unmanaged>
        /// <unmanaged-short>ID3D11VideoProcessorEnumerator::GetVideoProcessorFilterRange</unmanaged-short>
        public unsafe void GetVideoProcessorFilterRange(SharpDX.Direct3D11.VideoProcessorFilter filter, out SharpDX.Direct3D11.VideoProcessorFilterRange rangeRef)
        {
            rangeRef = default (SharpDX.Direct3D11.VideoProcessorFilterRange);
            SharpDX.Result __result__;
            fixed (void *rangeRef_ = &rangeRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)filter), rangeRef_, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("465217F2-5568-43CF-B5B9-F61D54531CA1")]
    public partial class VideoProcessorEnumerator1 : SharpDX.Direct3D11.VideoProcessorEnumerator
    {
        public VideoProcessorEnumerator1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator VideoProcessorEnumerator1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new VideoProcessorEnumerator1(nativePtr);
        /// <summary>
        /// <p>Indicates whether the driver supports the specified combination of format and colorspace conversions.</p>
        /// </summary>
        /// <param name = "inputFormat"><dd>  <p>The format of the video processor input.</p> </dd></param>
        /// <param name = "inputColorSpace"><dd>  <p>The colorspace of the video processor input.</p> </dd></param>
        /// <param name = "outputFormat"><dd>  <p>The format of the video processor output.</p> </dd></param>
        /// <param name = "outputColorSpace"><dd>  <p>The colorspace of the video processor output.</p> </dd></param>
        /// <param name = "supportedRef"><dd>  <p>Pointer to a boolean that is set by the driver to indicate if the specified combination of format and colorspace conversions is supported. True if the conversion is supported; otherwise, false.</p> </dd></param>
        /// <returns><p>This method returns one of the following error codes.</p><table> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>The operation completed successfully.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed or this function was called using an invalid calling pattern.</td></tr> </table><p>?</p></returns>
        /// <doc-id>dn894147</doc-id>
        /// <unmanaged>HRESULT ID3D11VideoProcessorEnumerator1::CheckVideoProcessorFormatConversion([In] DXGI_FORMAT InputFormat,[In] DXGI_COLOR_SPACE_TYPE InputColorSpace,[In] DXGI_FORMAT OutputFormat,[In] DXGI_COLOR_SPACE_TYPE OutputColorSpace,[Out] BOOL* pSupported)</unmanaged>
        /// <unmanaged-short>ID3D11VideoProcessorEnumerator1::CheckVideoProcessorFormatConversion</unmanaged-short>
        public unsafe void CheckVideoProcessorFormatConversion(SharpDX.DXGI.Format inputFormat, SharpDX.DXGI.ColorSpaceType inputColorSpace, SharpDX.DXGI.Format outputFormat, SharpDX.DXGI.ColorSpaceType outputColorSpace, out SharpDX.Mathematics.Interop.RawBool supportedRef)
        {
            supportedRef = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *supportedRef_ = &supportedRef)
                __result__ = SharpDX.Direct3D11.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)inputFormat), unchecked ((System.Int32)inputColorSpace), unchecked ((System.Int32)outputFormat), unchecked ((System.Int32)outputColorSpace), supportedRef_, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("11EC5A5F-51DC-4945-AB34-6E8C21300EA5")]
    public partial class VideoProcessorInputView : SharpDX.Direct3D11.ResourceView
    {
        public VideoProcessorInputView(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator VideoProcessorInputView(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new VideoProcessorInputView(nativePtr);
        /// <summary>
        /// <p>Gets the properties of the video processor input view.</p>
        /// </summary>
        /// <doc-id>hh447808</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.Direct3D11.VideoProcessorInputViewDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the properties of the video processor input view.</p>
        /// </summary>
        /// <param name = "descRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorInputViewDescription"/></strong> structure. The method fills the structure with the view properties.</p> </dd></param>
        /// <doc-id>hh447808</doc-id>
        /// <unmanaged>void ID3D11VideoProcessorInputView::GetDesc([Out] D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11VideoProcessorInputView::GetDesc</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.Direct3D11.VideoProcessorInputViewDescription descRef)
        {
            descRef = default (SharpDX.Direct3D11.VideoProcessorInputViewDescription);
            fixed (void *descRef_ = &descRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[8]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("A048285E-25A9-4527-BD93-D68B68C44254")]
    public partial class VideoProcessorOutputView : SharpDX.Direct3D11.ResourceView
    {
        public VideoProcessorOutputView(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator VideoProcessorOutputView(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new VideoProcessorOutputView(nativePtr);
        /// <summary>
        /// <p>Gets the properties of the video processor output view.</p>
        /// </summary>
        /// <doc-id>hh447810</doc-id>
        /// <unmanaged>GetDesc</unmanaged>
        /// <unmanaged-short>GetDesc</unmanaged-short>
        public SharpDX.Direct3D11.VideoProcessorOutputViewDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the properties of the video processor output view.</p>
        /// </summary>
        /// <param name = "descRef"><dd> <p>A reference to a <strong><see cref = "SharpDX.Direct3D11.VideoProcessorOutputViewDescription"/></strong> structure. The method fills the structure with the view properties.</p> </dd></param>
        /// <doc-id>hh447810</doc-id>
        /// <unmanaged>void ID3D11VideoProcessorOutputView::GetDesc([Out] D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC* pDesc)</unmanaged>
        /// <unmanaged-short>ID3D11VideoProcessorOutputView::GetDesc</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.Direct3D11.VideoProcessorOutputViewDescription descRef)
        {
            descRef = default (SharpDX.Direct3D11.VideoProcessorOutputViewDescription);
            fixed (void *descRef_ = &descRef)
                SharpDX.Direct3D11.LocalInterop.CalliStdCallvoid(this._nativePointer, descRef_, (*(void ***)this._nativePointer)[8]);
        }
    }
}